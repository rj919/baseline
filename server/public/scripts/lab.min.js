/**
* AUDIO JAVASCRIPT EXTENSION
* @author rcj1492
* @license Â©2017-2018 Collective Acuity
* @email support@collectiveacuity.com
*
* requirements:
* jquery
* lab.js
* aws-sdk
**/

// NOTES: Streaming Data to Flask
// https://www.one-tab.com/page/vQrQnClEQT6LDGm5ZeeG_g

//// import dependencies (when es6 is standard)
//import $ from 'jquery'
//import AWS from 'aws-sdk' 
//import { logConsole, ingestString, ingestMap } from 'lab'

function webaudioTool() {

    /* a method to turn on microphone and analyze audio data
    *    
    * Some code adapted from:
    * MIT License 2014 Scott Stensland
    * https://github.com/scottstensland/websockets-streaming-audio
    */
    
// construct audio context
    if (!('audio_context' in window)){
        var AudioContext = window.AudioContext || window.webkitAudioContext || false;
        window.audio_context = new AudioContext();
    }

    logConsole("Audio is starting up ...");

    var BUFF_SIZE = 16384;

    var audioInput = null,
        microphone_stream = null,
        gain_node = null,
        script_processor_node = null,
        script_processor_fft_node = null,
        analyserNode = null;

    if (!navigator.getUserMedia)
            navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia ||
                          navigator.mozGetUserMedia || navigator.msGetUserMedia;

    if (navigator.getUserMedia){

        navigator.getUserMedia({audio:true},
          function(stream) {
              start_microphone(stream);
          },
          function(e) {
              alert('Error capturing audio.');
          }
        );

    } else { alert('getUserMedia not supported in this browser.'); }

    function show_some_data(given_typed_array, num_row_to_display, label) {

        var size_buffer = given_typed_array.length;
        var index = 0;
        var max_index = num_row_to_display;

        console.log("__________ " + label);

        for (; index < max_index && index < size_buffer; index += 1) {

            console.log(given_typed_array[index]);
        }
    }

    function process_microphone_buffer(event) {

        var i, N, inp, microphone_output_buffer;

        microphone_output_buffer = event.inputBuffer.getChannelData(0); // just mono - 1 channel for now

    // microphone_output_buffer  <-- this buffer contains current gulp of data size BUFF_SIZE

        show_some_data(microphone_output_buffer, 5, "from getChannelData");
    }

    function start_microphone(stream){

        gain_node = window.audio_context.createGain();
        gain_node.connect( window.audio_context.destination );

        microphone_stream = window.audio_context.createMediaStreamSource(stream);
        microphone_stream.connect(gain_node);

        script_processor_node = window.audio_context.createScriptProcessor(BUFF_SIZE, 1, 1);
        script_processor_node.onaudioprocess = process_microphone_buffer;

        microphone_stream.connect(script_processor_node);

    // --- enable volume control for output speakers

        document.getElementById('volume').addEventListener('change', function() {

            var curr_volume = this.value;
            gain_node.gain.value = curr_volume;

            console.log("curr_volume ", curr_volume);
      });

    // --- setup FFT

        script_processor_fft_node = window.audio_context.createScriptProcessor(2048, 1, 1);
        script_processor_fft_node.connect(gain_node);

        analyserNode = window.audio_context.createAnalyser();
        analyserNode.smoothingTimeConstant = 0;
        analyserNode.fftSize = 2048;

        microphone_stream.connect(analyserNode);

        analyserNode.connect(script_processor_fft_node);

        script_processor_fft_node.onaudioprocess = function() {

    // get the average for the first channel
            var array = new Uint8Array(analyserNode.frequencyBinCount);
            analyserNode.getByteFrequencyData(array);

    // TODO:  tempo needs to be taken over a few seconds, not a few milliseconds.
            var p = mode( array, array.length);
            var t = mode( array, 25);
            var v = getAverageVolume( array );
    // draw the spectrogram
            if (microphone_stream.playbackState == microphone_stream.PLAYING_STATE) {
            // console.log( p, t, v );
                updateVTP(v,t,p);
            // show_some_data(array, 5, "from fft");
                console.log(JSON.stringify($('meta[name=vtp]').data()))
            }
        };
    }
}

function filterEcho(current_speech, previous_speech) {

    /* a method to remove echo from synthesized speech */
    
// define word remover
    function _remove_words(word_map){
        var current = word_map.current_words
        var previous = word_map.previous_words
        var cleaned = word_map.cleaned_words
    // return word map if no more words to evaluate
        if (!(current.length)){
            return word_map
    // evaluate words from back to front
        } else {
            var previous_index = previous.indexOf(current[-1])
        // add word to clean if match not found 
            if ( previous_index == -1) {
                cleaned.unshift(current[-1])
                current.splice(-1,1)
                _remove_words({current_words: current, previous_words: previous, cleaned_words: cleaned })
            } else {
            // skip word if current word is last in list
                if (current.length == 1){
                    current.splice(0, 1)
                    _remove_words({current_words: current, previous_words: previous, cleaned_words: cleaned })
            // skip word and add remaining words if previous ends
                } else if (previous_index == 0) {
                    current.splice(0, 1)
                    for (var i = 0; i < current.length; i++){
                        cleaned.unshift(current[-1])
                        current.splice(-1,1)
                    }
                    _remove_words({current_words: current, previous_words: previous, cleaned_words: cleaned })
            // remove extra length of previous and try to find next word
                } else {
                    previous.splice(previous_index, (previous.length - previous_index))
                    prior_index = previous.indexOf(current[-2])
                    if (prior_index == -1){
                        current.splice(-1,1)
                        _remove_words({current_words: current, previous_words: previous, cleaned_words: cleaned })
                    } else {
                        previous.splice(prior_index, (previous.length - prior_index))
                        current.splice(-1,1)
                        _remove_words({current_words: current, previous_words: previous, cleaned_words: cleaned })
                    }
                }
            }
        }   
    }

// tokenize speech
    var filtered_words = {
        current_words: current_speech.split(' '),
        previous_words: previous_speech.split(' '),
        cleaned_words: []
    }

// run remover
    filtered_words = _remove_words(filtered_words)
    
    return filtered_words.cleaned_words
    
}

function timestampTranscription(interim_text, interim_array){

    /* a method to convert transcribed text into an array of timestamped words */
    
// define function variables
    var timestamp_array = []
    var result_index = 0
    var token_index = 0
    var break_off = false
    var interim_tokens = interim_text.split(' ')

// look for most recent instance of each token in the interim array
    for (var i = 0; i < interim_tokens.length; i++){
        for (var j = result_index; j < interim_array.length; j++){
            var array_tokens = interim_array[j].text.split(' ')
            for (var k = token_index; k < array_tokens.length; k++){
                if (interim_tokens[i] == array_tokens[k]){
                    timestamp_array.push({ t: interim_tokens[i], dt: interim_array[j].dt })
                    result_index = j
                    token_index = k
                    break_off = true
                    break
                } else if (j + 1 == interim_array.length){
        
        // conduct a second pass for created words
                    for (var m = 0; m < interim_array.length; m++){
                        var second_array_tokens = interim_array[m].text.split(' ')
                        for (var n = 0; n < second_array_tokens.length; n++){
                            if (interim_tokens[i] == second_array_tokens[n]){
                                timestamp_array.push({ t: interim_tokens[i], dt: interim_array[m].dt })
                                result_index = m
                                token_index = n
                            } else {
                                timestamp_array.push({ t: interim_tokens[i], dt: ($.now() / 1000)})
                            }
                            break_off = true
                            break
                        }
                        if (break_off){
                            break
                        }
                    }
                    if (break_off){
                        break
                    }
                }
            }
            if (break_off){
                break_off = false
                break
            }               
        }
    }

// create unique timestamps
    var microsecond_count = 0.0
    var previous_time = 0.0
    for (var i = 0; i < timestamp_array.length; i++){
        if (timestamp_array[i].dt == previous_time){
            microsecond_count += 0.000001
            timestamp_array[i].dt = previous_time + microsecond_count
        } else {
            microsecond_count = 0.0
            previous_time = timestamp_array[i].dt
        }
    }
    
    return timestamp_array

}
    
function startSpeechRecognition(final_callback, interim_callback=null, output_format='text', filter_callable=null) {

    /* a method to turn on microphone and perform speech transcription
    *    
    * Some code adapted from:
    * MIT License 2016 Prateek Pant
    * https://github.com/pantprateek/genieYT/blob/master/player.html
    */
    
    // https://developers.google.com/web/updates/2013/01/Voice-Driven-Web-Apps-Introduction-to-the-Web-Speech-API

// TODO integrate other speech recognition services

// TODO pipe audio to backend for backend transcription

// test for speech recognition in scope
    if (!(window.hasOwnProperty('webkitSpeechRecognition'))){
    
        logConsole('webkitSpeechRecognition not supported by device')

    } else {
    
    // construct transcription client
        if (!('speech_recognition_client' in window)){
            window.speech_recognition_client = new webkitSpeechRecognition();
            window.speech_recognition_properties = {
                timestamp: 0,
                speech_in_progress: false,
                parsing_in_progress: false,
                transcribed_text: '',
                transcribed_markup: [],
                interim_text: '',
                interim_array: [],
                interim_callback: interim_callback,
                final_callback: final_callback,
                filter_callable: filter_callable
            }
        }

    // configure client
        window.speech_recognition_client.continuous = true
        window.speech_recognition_client.interimResults = true
        
    // change parsing in progress on start of transcription attempt
        window.speech_recognition_client.onstart = function() {
            window.speech_recognition_properties.parsing_in_progress = true
        }
        
    // process audio on result of transcription
        window.speech_recognition_client.onresult = function(event) {
        
            if ('speech_recognition_properties' in window){
            
        // update properties
                window.speech_recognition_properties.speech_in_progress = true
                if (!window.speech_recognition_properties.timestamp){
                    window.speech_recognition_properties.timestamp = event.timeStamp
                }
            
        // report interim speech
                if (event.results.length){

                    var interim_text = event.results[0][0].transcript
                    window.speech_recognition_properties.interim_text = interim_text
                    window.speech_recognition_properties.interim_array.push({ text: interim_text, dt: ($.now() / 1000) })
                    
             // process interim text
                    if (output_format == 'timestamp'){
                        var interim_output = timestampTranscription(interim_text, window.speech_recognition_properties.interim_array)
                    } else {
                        var interim_output = interim_text
                    }
             
             // invoke callback
                    if (window.speech_recognition_properties.interim_callback){
                        window.speech_recognition_properties.interim_callback(interim_output)
                    }
            
                }
                
        // report final speech
                for (var i = event.resultIndex; i < event.results.length; ++i) {
                
                    var transcribed_text = event.results[i][0].transcript
                         
                    if (event.results[i].isFinal) {
                        
            // process transcribed text
                        if (output_format == 'timestamp'){
                            var transcribed_output = timestampTranscription(transcribed_text, window.speech_recognition_properties.interim_array)
                            window.speech_recognition_properties.transcribed_markup = transcribed_output
                        } else {
                            var transcribed_output = transcribed_text
                        }
                        if (window.speech_recognition_properties.filter_callable){
                            transcribed_text = window.speech_recognition_properties.filter_callable(transcribed_output)
                        }
            
            // invoke callback
                        if (window.speech_recognition_properties.final_callback){
                            window.speech_recognition_properties.final_callback(transcribed_output)
                        }
                
            // reset the transcription results
                        window.speech_recognition_properties.transcribed_text = transcribed_text
                        window.speech_recognition_properties.interim_text = ''
                        window.speech_recognition_properties.interim_array = []
                        if ('speech_recognition_client' in window){
                            window.speech_recognition_client.stop()
                        }
                        
                    } 
                   
                }
            
            }
            
        }
        
    // report parsing error
        window.speech_recognition_client.onerror = function(event) {
          
            logConsole('Error transcribing speech: ' + event.error)
            
        }
        
    // restart transcription on end of transcription attempt
        window.speech_recognition_client.onend = function(event) {
         
            if ('speech_recognition_properties' in window){
            
                window.speech_recognition_properties.speech_in_progress=false
                
                if ('speech_recognition_on' in window){
                   window.speech_recognition_client.start()
                }
            
            }
            
        }
    
    // start transcription client
        window.speech_recognition_client.start();
        
    // reset audio to avoid disconnection on pauses
        window.speech_recognition_on = true
        window.speech_recognition_reset = setInterval(function(){
            if(window.speech_recognition_properties.speech_in_progress == false){
                if ('speech_recognition_client' in window){
                    window.speech_recognition_client.stop();
                } 
            }
        }, 10000);
        
    } 

}

function stopSpeechRecognition() {

// clear transcription reset listener
    if ('speech_recognition_reset' in window){
        clearInterval(window.speech_recognition_reset)
    }

// delete transcription tracker from window
    if ('speech_recognition_on' in window){
        delete window.speech_recognition_on
    }

// delete transcription properties
    if ('speech_recognition_properties' in window){
        delete window.speech_transcription_properties
    }
    
// stop client and delete client from window
    if ('speech_recognition_client' in window){
        window.speech_recognition_client.stop()
        delete window.speech_recognition_client
    }
    
}

function startSpeechTranscription(final_callback, interim_callback=null, output_format='text', filter_callable=null, error_handler=null) {

    /* a method to initialize audio transcription of speech */

// test for speech recognition in scope
    if (!(window.hasOwnProperty('webkitSpeechRecognition'))){
    
        logConsole('webkitSpeechRecognition not supported by device')

    } else {
    
    // add transcription properties to window
        if (!('speech_transcription_properties' in window)){
            window.speech_transcription_properties = {
                timestamp: 0,
                speech_in_progress: false,
                parsing_in_progress: false,
                transcribed_text: '',
                transcribed_markup: [],
                interim_text: '',
                interim_array: [],
                interim_callback: interim_callback,
                final_callback: final_callback,
                filter_callable: filter_callable
            }
        }
    
    // construct transcription client
        if (!('speech_transcription_client' in window)){
            window.speech_transcription_client = new webkitSpeechRecognition();
        }

    // configure client
        window.speech_transcription_client.continuous = true
        window.speech_transcription_client.interimResults = true
        
    // change parsing in progress on start of transcription attempt
        window.speech_transcription_client.onstart = function() {            
            window.speech_transcription_properties.parsing_in_progress = true
        }
        
    // process audio on result of transcription
        window.speech_transcription_client.onresult = function(event){
        
            if ('speech_transcription_properties' in window){
         
        // update transcription properties
                window.speech_transcription_properties.speech_in_progress = true
                if (!window.speech_transcription_properties.timestamp){
                    window.speech_transcription_properties.timestamp = event.timeStamp
                }
            
        // report interim speech
                if (event.results.length){
//                    const adjusted_time = (Math.round((event.timeStamp * 1000)) / 1000000)
//                    const interim_dt = adjusted_time + window.speech_transcription_properties.timestamp
//                    logConsole([event.timeStamp, adjusted_time, interim_dt])
                    var interim_text = event.results[0][0].transcript
                    window.speech_transcription_properties.interim_text = interim_text
                    window.speech_transcription_properties.interim_array.push({ text: interim_text, dt: ($.now() / 1000) })
                    
             // process interim text
                    if (output_format == 'timestamp'){
                        var interim_output = timestampTranscription(interim_text, window.speech_transcription_properties.interim_array)
                    } else {
                        var interim_output = interim_text
                    }
                    
             // invoke callback
                    if (window.speech_transcription_properties.interim_callback){
                        window.speech_transcription_properties.interim_callback(interim_output)
                    }
                    
                }
            
        // report final speech
                for (var i = event.resultIndex; i < event.results.length; ++i) {
                    var transcribed_text = event.results[i][0].transcript      
                    if (event.results[i].isFinal) {
                
            // process transcribed text
                        if (output_format == 'timestamp'){
                            var transcribed_output = timestampTranscription(transcribed_text, window.speech_transcription_properties.interim_array)
                            window.speech_transcription_properties.transcribed_markup = transcribed_output
                        } else {
                            var transcribed_output = transcribed_text
                        }
                        if (window.speech_transcription_properties.filter_callable){
                            transcribed_text = window.speech_transcription_properties.filter_callable(transcribed_output)
                        }
            
            // invoke callback
                        if (window.speech_transcription_properties.final_callback){
                            window.speech_transcription_properties.final_callback(transcribed_output)
                        }
                
            // stop transcription to reset
                        window.speech_transcription_properties.transcribed_text = transcribed_text
                        window.speech_transcription_properties.interim_text = ''
                        window.speech_transcription_properties.interim_array = []
                        if ('speech_transcription_client' in window){
                            window.speech_transcription_client.stop()
                        }
                        
                    } 
                   
                }
            
            }
            
            
        }
        
    // report parsing error
        window.speech_transcription_client.onerror = function(event) {     
            logConsole('Error transcribing speech: ' + event.error)
            if (error_handler){
                error_handler(event.error)
            }
        }
        
    // restart transcription on end of transcription attempt
        window.speech_transcription_client.onend = function(event) {
         
            if ('speech_transcription_properties' in window){
                window.speech_transcription_properties.speech_in_progress=false
                if ('speech_transcription_on' in window){
                   window.speech_transcription_client.start()
                }
            }
        
        }
    
    // start transcription client
        window.speech_transcription_client.start()
        
    // reset audio to avoid disconnection on pauses
        window.speech_transcription_on = true
        window.speech_transcription_reset = setInterval(function(){
            if(window.speech_transcription_properties.speech_in_progress == false){
                if ('speech_transcription_client' in window){
                    window.speech_transcription_client.stop();
                } 
            }
        }, 10000);
        
    }

}

function stopSpeechTranscription() {

// clear reset interval
    if ('speech_transcription_reset' in window){
        clearInterval(window.speech_transcription_reset)
    }

// delete transcription tracker from window
    if ('speech_transcription_on' in window){
        delete window.speech_transcription_on
    }

// delete transcription properties
    if ('speech_transcription_properties' in window){
        delete window.speech_transcription_properties
    }
    
// stop client and delete client from window
    if ('speech_transcription_client' in window){
        window.speech_transcription_client.stop()
        delete window.speech_transcription_client
    }

}

function playAudio(audio_data, content_type, volume_level=0.5, pause_transcription=true) {

    /* a method to play a base64 url encoded string of audio data */

    // https://code.wiki/page/B1gb2dU3/Playing-Audio-through-The-JavaScript-Audio-API
    // https://www.html5rocks.com/en/tutorials/webaudio/intro/
    // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext
    
// construct audio context
    if (!('audio_context' in window)){
        var AudioContext = window.AudioContext || window.webkitAudioContext;
        window.audio_context = new AudioContext();
    }
    if (!('volume_level' in window)){
         window.volume_level = window.audio_context.createGain()
    }
    
// validate mimetype
    var audio_mimetypes = [ 'audio/mpeg', 'audio/wav', 'audio/ogg' ]
    if (audio_mimetypes.indexOf(ingestString(content_type)) == -1){
        logConsole('content_type must be one of ' + JSON.stringify(audio_mimetypes))
    }

// validate volume level is a number between 0 and 1
    if (typeof(volume_level) != 'number'){
        volume_level = 1
    } else if (ingestNumber(volume_level) < 0 || ingestNumber(volume_level) > 1){
        volume_level = 1
    }
    
// define base64 player
    function play_base64(context, gain_node, audio_data, context_type){

    // construct dummy request
        var audio_string = 'data:' + content_type + ';base64,' + audio_data;
        var audio_request = new XMLHttpRequest()
        audio_request.open('GET', audio_string)
        audio_request.responseType = 'arraybuffer';

    // decode asynchronously
        audio_request.onload = function() {

            context.decodeAudioData(audio_request.response, function(buffer) {
                var audio_buffer = buffer
            // Create a source node from the buffer
                var source_node = context.createBufferSource()
                source_node.buffer = audio_buffer
            // Create a gain node to modulate volume
                gain_node.gain.value = volume_level
                source_node.connect(gain_node)
            // Connect to the final output node (the speakers)
                gain_node.connect(context.destination)
                // source.connect(context.destination)
            // Pause existing transcription
                if (pause_transcription){
                    if ('speech_recognition_client' in window){
                        source_node.onended = function(event){
                            window.speech_recognition_on = true
                            window.speech_recognition_client.start()
                        }
                        delete window.speech_recognition_on
                        window.speech_recognition_client.stop()
                    }
                    if ('speech_transcription_client' in window){
                        source_node.onended = function(event){
                            window.speech_transcription_on = true
                            window.speech_transcription_client.start()
                        }
                        delete window.speech_transcription_on
                        window.speech_transcription_client.stop()
                    }
                }
            // Play immediately
                source_node.start(0)
            });

        }

    // send dummy request
        audio_request.send()

    }

// play audio
    play_base64(window.audio_context, window.volume_level, audio_data, content_type)    
                 
//// construct audio string
//    var audio_string = 'data:' + content_type + ';base64,' + audio_data;
//    var audio = new Audio(audio_string)
//    if ('speech_recognition_client' in window){
//        audio.onended = function(event){
//            window.speech_recognition_on = true
//            window.speech_recognition_client.resume()
//            delete audio
//        }
//        window.speech_recognition_on = false
//        window.speech_recognition_client.stop()
//    }
//    audio.play()
    
}

function streamAudio(url) {

// TODO audio streaming using request URL and mp3/wav audio or websockets & workers

// https://github.com/revolunet/webaudio-wav-stream-player
//https://stackoverflow.com/questions/38589614/webaudio-streaming-with-fetch-domexception-unable-to-decode-audio-data/39988015#39988015
// https://github.com/miguelgrinberg/python-socketio/issues/77
// https://gist.github.com/revolunet/46d4187c3b6f28632a91421c1f2a9fad

}

function synthesizeSpeech(message_text, voice_id='Nicole', aws_polly_creds=null) {

    /* a method to turn on speaker and play synthesized speech
    *    
    * Some code adapted from:
    * MIT License 2014 breakspirit
    * https://stackoverflow.com/questions/8015702/how-to-play-audio-byte-array-not-file-with-javascript-in-a-browser
    */

// construct audio context
    if (!('audio_context' in window)){
        var AudioContext = window.AudioContext || window.webkitAudioContext;
        window.audio_context = new AudioContext();
    }
    
// define audio player for audio stream
    function play_bytearray(context, byteArray) {
    
        var arrayBuffer = new ArrayBuffer(byteArray.length);
        var bufferView = new Uint8Array(arrayBuffer);
        for (i = 0; i < byteArray.length; i++) {
          bufferView[i] = byteArray[i];
        }
    
        context.decodeAudioData(arrayBuffer, function(buffer) {
            buf = buffer;
            // Create a source node from the buffer
            var source = context.createBufferSource();
            source.buffer = buf;
            // Connect to the final output node (the speakers)
            source.connect(context.destination);
            // Play immediately
            source.start(0);
        });
        
    }

// validate voice id
    var voice_ids = [ "Geraint", "Gwyneth", "Mads", "Naja", "Hans", "Marlene", "Nicole", "Russell", "Amy", "Brian", "Emma", "Raveena", "Ivy", "Joanna", "Joey", "Justin", "Kendra", "Kimberly", "Matthew", "Salli", "Conchita", "Enrique", "Miguel", "Penelope", "Chantal", "Celine", "Mathieu", "Dora", "Karl", "Carla", "Giorgio", "Mizuki", "Liv", "Lotte", "Ruben", "Ewa", "Jacek", "Jan", "Maja", "Ricardo", "Vitoria", "Cristiano", "Ines", "Carmen", "Maxim", "Tatyana", "Astrid", "Filiz", "Vicki", "Takumi" ]
    if (voice_ids.indexOf(ingestString(voice_id)) == -1){
        logConsole('voice_id must be one of ' + JSON.stringify(voice_ids))
    }
    
// construct new polly object
// http://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Polly.html#constructor-property
    var polly_config = ingestMap(aws_polly_cred)
    var polly_options = {
        accessKeyId: polly_config.aws_polly_access_key_id,
        secretAccessKey: polly_config.aws_polly_secret_access_key,
        region: polly_config.aws_polly_default_region
    }
    var polly = new AWS.Polly(polly_options)

// send synthesize request
    var params = { 
        OutputFormat: "mp3", 
        Text: text_message, 
        TextType: "text", 
        VoiceId: voice_id
    }
    polly.synthesizeSpeech(params, function(err, data) {
        if (err){
            logConsole('Error synthesizing speech:' + err); // an error occurred
        } else {
            play_bytearray(window.audio_context, data.AudioStream)
            // logConsole(data);           // successful response
        }
        /*
        data = {
        AudioStream: <Binary String>, 
        ContentType: "audio/mpeg", 
        RequestCharacters: 37
        }
        */
    })

}

function synthesizeSpeechChrome(message_text) {

    // NOTE: DOES NOT WORK ON LINUX - API keys required to access https://cloud.google.com/speech/
    
    // http://qnimate.com/speech-recognition-and-synthesis-using-javascript/
    // https://stackoverflow.com/questions/21947730/chrome-speech-synthesis-with-longer-texts
    
//    var default_voiceURI = null;
//    var default_lang = null;
//    var timer = setInterval(function(){
//    
//        //window.speechSynthesis object contains information about speechSynthesis features available and also is used to control the SpeechSynthesisUtterance objects.
//        //extract all available voices
//        if ("speechSynthesis" in window){
//            
//            //getVoices() gives a list of available human voices and their suitable language.
//            var available_voices = speechSynthesis.getVoices();
//
//            //after running few times inside the timer callback the getVoices returns the list. Its also a bug.
//            if(available_voices.length !== 0) {
//                //available_voices.length returns the total number of voices available. Every voice is made for a particular language. Bad mix will produce bad pronouncation. 
//                
//                for(var count = 0; count < available_voices.length; count++)
//                
//                {
//
//                    //lang returns the langauage code for which the voice is made for.
//                    //voiceURI returns a unique identifier for that voice. 
//                    //voiceURI and lang come in pairs that means each voiceURI is trained for a particular language.
//                    //name is the displayable name for the voice.
//                    if(count == 0)
//                    {
//                        //we make the first voice as default.
//                        default_voiceURI = available_voices[count].voiceURI;
//                        default_lang = available_voices[count].lang;
//                    }
//                    
//                }
//                clearInterval(timer);
//            }
//            logConsole(available_voices)
//        }
//        else
//        {
//            alert("Speech Synthesis API not supported");
//            clearInterval(timer);
//        }
//    }, 10000)
    
    default_lang = 'en-US'
    
//    var speech_timer = function(){
    
        logConsole(default_lang)
        
        if (default_lang){
        
            if ('speechSynthesis' in window){
        
                if ("SpeechSynthesisUtterance" in window){
                
                    var utterance = new SpeechSynthesisUtterance()
                    utterance.text = message_text
                    utterance.volume = 1
                    utterance.lang = default_lang
        
                    //represents how fast the text will be spoken out. Value between 0.1 to 10.
                    utterance.rate = 1;
        
                    //represents the pitch. Value between 0 to 2.
                    utterance.pitch = 1;
        
                    //fired when utterance is started
                    utterance.onstart = function(){
                        console.log("Synthesis Started");
                    }
        
                    //fired when utterance is paused
                    utterance.onpause = function(){
                        console.log("Synthesis Paused");
                    }
        
                    //fired when utterance is resumed after pause
                    utterance.onresume = function(){
                        console.log("Synthesis Resumed after Pause");
                    }
        
                    //fired when utterance is stopped
                    utterance.onend = function(){
                        console.log("Synthesis Stopped");
                    }
                    
                    logConsole('synthesis attempt')
                    speechSynthesis.speak(utterance);
                }
                
            }
            
        }
        
  //  }
    
            
}

/**
* SOCKETS JAVASCRIPT EXTENSION
* @author rcj1492
* @license Â©2017-2018 Collective Acuity
* @email support@collectiveacuity.com
*
* requirements:
* jquery
* socket.io-client
* lab.js
* requests.js
**/

// window.server_url

//// import dependencies (when es6 is standard)
//import $ from 'jquery'
//import io from 'socket.io-client'
//import { ingestString, flexibleDialog } from 'lab'
//import { patchingSession } from 'requests'
//import { signOut } from 'views'

function updateRooms(room_action, room_id) {

// validate room in window
    if (!('socket_rooms' in window)){
        window.socket_rooms = []
    }
    room_action = ingestString(room_action)
    room_id = ingestString(room_id)
    
// retrieve rooms from window
    var room_array = window.socket_rooms

// update data in rooms array
    if (room_action == 'join') {
        var room_index = room_array.indexOf(room_id)
        if (room_index == -1) {
            room_array.push(room_id)
        }
    } else if (room_action == 'leave') {
        var room_index = room_array.indexOf(room_id)
        if (room_index > -1) {
            room_array.splice(room_index, 1)
        }
    } else if (room_action == 'clear') {
        window.socket_rooms = []
        room_array = []
    }

    return room_array

}

function joiningRoom(socket_client, room_id) {

// construct new promise
    var deferred = new $.Deferred()
    
// send join request
    socket_client.emit('join', { 'room_id': room_id }, function(rec_data){
        if (ingestString(rec_data.room_id)){
            updateRooms('join', rec_data.room_id)
            deferred.resolve(rec_data.room_id)
        } else {
            deferred.reject(rec_data)
        }
    })
    
    deferred.promise()

}

function leavingRoom(socket_client, room_id) {

// construct new promise
    var deferred = new $.Deferred()
    
// send join request
    socket_client.emit('leave', { 'room_id': room_id }, function(rec_data){
        if (ingestString(rec_data.room_id)){
            updateRooms('leave', rec_data.room_id)
            deferred.resolve(rec_data.room_id)
        } else {
            deferred.reject(rec_data)
        }
    })
    
    deferred.promise()

}

function handleEvents(socket_client, server_url, status_id, latency_id) {

// add connect error handler
    socket_client.on('reconnect_error', function(){
        var reconnect_request = connectingClient(server_url)
        reconnect_error.fail(function(error_message){
            if (window.device_online){
                disconnectClient()
            }
        })
    })
    
// add connect handler
    socket_client.on('connect', function( response ) {
        $(status_id).text('Connected')
        console.log('Socket Connected')
        window.device_online = true
    });

// add disconnect handler
    socket_client.on('disconnect', function( response ) {
        $(status_id).text('Disconnected')
        console.log('Socket Disconnected')
        window.device_online = false
    });

// construct latency checker
    if (ingestString(latency_id)){
        var latency_array = []
        window.ping_pong = setInterval(function(){
            var start_time = (new Date).getTime()
            socket_client.emit('ping_pong', {'time': start_time },
            // callback function
                function(rec_data) {
                    var latency = (new Date).getTime() - rec_data.time;
                    latency_array.push(latency);
                    if (latency_array.length > 30) {
                        latency_array = latency_array.slice(-30); // keep last 30 samples
                    }
                    var sum = 0;
                    for (var i = 0; i < latency_array.length; i++)
                        sum += latency_array[i];
                    var latency_value = Math.round(10 * sum / latency_array.length) / 10
                    $(latency_id).text(latency_value);
                }
            )
        }, 1000)
    }

// add callable handler
    socket_client.on('callable', function( server_data ){
        var global_func = ingestString(server_data.func)
        var func_args = ingestArray(server_data.args)
        if (!(global_func in window)){
            logConsole('Error: ' + global_func + ' is not in window.' )
        } else {
            if (func_args.length){
                global_func(...func_args)
            } else {
                global_func()
            }
        }
    })  
       
}

function connectingClient(server_url) {

// construct new promise
    var deferred = new $.Deferred()

// define device offline function
    function _device_offline(){
        logConsole('Cannot connect to websocket at ' + server_url + '. Device offline.')
        deferred.reject(null)
    }

// retrieve new session token
    var session_renewal = patchingSession()
    
    session_renewal.done(function(session_token){

    // construct socket client and connect to socketIO server
        window.socket_client = io.connect(server_url, {
            query: {
                'session_token': session_token 
            }
        })
        if (!('socket_channels' in window)){
            window.socket_channels = []
        }
        deferred.resolve(window.socket_client)

    })

    session_renewal.fail(function(error_message){
        
    // handle errors
        handlingSession(error_message).fail(function(msg){
        
    // repeat request after renewal of session
            if (msg == 'acquired'){
                if ('authentication_view' in window){
                    deferred.reject()
                    window.authentication_view()
                } else {
                    deferred.reject()
                    openAuthentication()
                }
            } else if (msg == 'renewal') {
                var repeat_request = connectingClient(server_url)
                repeat_request.done(function(socket_client){ deferred.resolve(socket_client)})
                repeat_request.fail(function(msg){
                    if (!window.device_online){
                        _device_offline()
                    } else {
                        deferred.reject(msg)
                    } 
                })
            } else if (!window.device_online) {
                _device_offline()
            } else {
                deferred.reject(error_message)
            }
        })
        
    })
    
    return deferred.promise()

}

function disconnectClient() {

    try {
    
    // clear latency tests
        if ('ping_pong' in window){
            clearInterval(window.ping_pong)
        }
    
    // clear socket
        if ('socket_client' in window){
            window.socket_client.disconnect()
            delete window.socket_client
        }
    
    // clear channels
        window.socket_channels = []
    
    // clear rooms
        updateRooms('clear')
    
    } catch (e) {}

}

function handlingSocket(server_url, callable=null, args=null){

    /* a method for handling opening up a socket connection */
    
// construct new promise
    var deferred = new $.Deferred()
    
// define callable function
    function _success_function(callable, args, socket_client){
        if (callable){
            var callable_args = [ socket_client ]
            if (ingestArray(args).length){
                callable_args.push(...args)
            }
            callable(...callable_args)
        }
        deferred.resolve(socket_client)
    }
    
// open socket connection
    if ('socket_client' in window){
        _success_function(callable, args, window.socket_client)    
    } else {
        var connection_request = connectingClient(server_url)
        connection_request.done(function(socket_client){
            handleEvents(socket_client, server_url)
            _success_function(callable, args, socket_client)
        })
        connection_request.fail(function(error_message){
            deferred.reject(error_message)
        })
    
    // TODO connection failure handling
//        connect_request.fail(function(error_message){
//        
//        // show error message
//            var error_prefix = 'conversation_connection_error'
//            var error_message_html = sprintf('\
//                <div id="%s_box" class="text-center">\
//                    <div id="%s_main" class="col-xs-12 margin-vertical-10">\
//                        <div id="%s_text" class="form-text auto-height text-wrap">%s</div>\
//                    </div>\
//                </div>',
//                error_prefix, error_prefix, error_prefix, error_message)
//            var dialog_options = {
//                title: 'Socket Connectivity Error',
//                body: error_message_html 
//            }
//            flexibleDialog(dialog_options)
//        
//        // attempt to connect
//            if (!window.device_online){
//                window.socket_connecting = setInterval(function(){
//                    var connect_request = connectingClient(window.server_url)
//                     connect_request.done(function(socket_client){
//                        handleEvents(socket_client, window.server_url)
//                        conversationView(socket_client, channel_types)
//                        clearInterval(window.socket_connecting)
//                    })
//                }, 10000)
//            }
//        })
        
        
    }

    return deferred.promise()
    
}

function toggleConnection(connect_id, status_id, latency_id) {
  
// validate server_url in window
    if (!('server_url' in window)){
        window.server_url = '/'
    }
    
// define method variables
    var connect_selector = $(connect_id)

    if ('socket_client' in window){

// stop socket controller
        disconnectClient()

// activate connect button
        connect_selector.text('Connect')
        connect_selector.off()
        connect_selector.on('click', function(){ toggleConnection(connect_id, status_id, latency_id) } )
        
    } else {

// start socket client
        var connect_request = connectingClient(window.server_url)

    // add events handlers to socket client
        connect_request.done(function(socket_client){
            handleEvents(socket_client, status_id, latency_id)
            
    // activate disconnect button
            connect_selector.text('Disconnect')
            connect_selector.off()
            connect_selector.on('click', function(){ toggleConnection(connect_id, status_id, latency_id) } )
            
        })
       
    }
    
}

/*
The MIT License (MIT)

Copyright (c) 2015 Daniel Roesler

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

// https://github.com/diafygi/webrtc-ips

function retrieveIPAddress(callback) {

/* a method to retrieve the ip addresses associated with a client connection */

    var ip_dups = {};

// compatibility for firefox and chrome
    var RTCPeerConnection = window.RTCPeerConnection
        || window.mozRTCPeerConnection
        || window.webkitRTCPeerConnection;
    var useWebKit = !!window.webkitRTCPeerConnection;

// bypass naive webrtc blocking using an iframe
    if(!RTCPeerConnection){

        $('<iframe/>', {
            id: 'lab_rtc_iframe',
            style: 'display: none;',
            sandbox: 'allow-same-origin'
        }
        ).appendTo($('body'))

        var win = $('#lab_rtc_iframe').contentWindow;
        RTCPeerConnection = win.RTCPeerConnection
            || win.mozRTCPeerConnection
            || win.webkitRTCPeerConnection;
        useWebKit = !!win.webkitRTCPeerConnection;

    }

//minimal requirements for data connection
    var mediaConstraints = {
        optional: [{RtpDataChannels: true}]
    };

    var servers = {iceServers: [{urls: "stun:stun.services.mozilla.com"}]};

//construct a new RTCPeerConnection
    var pc = new RTCPeerConnection(servers, mediaConstraints);

    function handleCandidate(candidate){

    //match just the IP address
        var ip_regex = /([0-9]{1,3}(\.[0-9]{1,3}){3}|[a-f0-9]{1,4}:(:[a-f0-9]{1,4}){6,7})/
        var ip_test = ip_regex.exec(candidate)
        if (ip_test){

            try {

            // return ip address
                var ip_addr = ip_regex.exec(candidate)[1];
                if(ip_dups[ip_addr] === undefined)
                    callback(ip_addr);
            // remove duplicates
                ip_dups[ip_addr] = true;

            } catch (e) { }

        }

    }

//listen for candidate events
    pc.onicecandidate = function(ice){

//skip non-candidate events
        if(ice.candidate)
            handleCandidate(ice.candidate.candidate);

    };

//create a bogus data channel
    pc.createDataChannel("");

//create an offer sdp
    pc.createOffer(function(result){

//trigger the stun server request
        pc.setLocalDescription(result, function(){}, function(){});

    }, function(){});

//wait for a while to let everything get done
    setTimeout(function(){

    //read candidate info from local description
        var lines = pc.localDescription.sdp.split('\n');

        lines.forEach(function(line){
            if(line.indexOf('a=candidate:') === 0)
                handleCandidate(line);
        });

    }, 500);

}


/**
* REQUESTS JAVASCRIPT EXTENSION
* @author rcj1492
* @license Â©2017-2018 Collective Acuity
* @email support@collectiveacuity.com
*
* requirements:
* jquery
* lab.js
* data.js
* fingerprints.js
* views.js
**/

//// import dependencies
//import $ from 'jquery'
//import { loadRecord, saveRecord, deleteRecord, saveItem, loadItem, listItems, deleteItem, startingPouchDB, stoppingPouch } from 'data'
//import { initializeFingerprint } from 'fingerprints'
//import { openAuthentication } from 'views'
//import { logConsole, mapSize, ingestMap, ingestString, ingestInteger, ingestNumber, ingestBoolean, ingestArray, sortArray, filterArray, unpackKwargs, callFunction, updateHistory } from 'lab'

// add device online value to window
window.device_online = true

function errorConstructor(response, exception) {

/* a method for handling an error in an ajax response */

// retrieve variables from response
    var response_code = response.status
    var response_body = {}
    try {
        response_body = JSON.parse(response.responseText)
    } catch(e) { }

// construct message from error codes
    var message_content = 'Errr! '
    if (response_code === 0) {
        message_content += 'No connection. Check network settings.'
        window.device_online = false
    } else if (response_code == 404) {
        message_content += 'Page not found. [404]'
    } else if (response_code == 500) {
        message_content += 'Internal Server Error [500].'
    } else if (exception === 'timeout') {
        message_content += 'Request timeout.'
    } else if (exception === 'abort') {
        message_content += 'Request aborted.'
    } else if (mapSize(ingestMap(response_body))) {
        if (ingestString(response_body.error)) {
            message_content += response_body.error
        }
    }

// report error to console log
    console.log(message_content);

// return message
    return message_content;

}

function requestingResource(request_kwargs) {

/* a promise method to send an ajax request to server for a resource */

    var deferred = new $.Deferred()
    
// define catchall request outcome functions
    function _success_function(response) {
        logConsole('Request Successful.')
        window.device_online = true
        deferred.resolve(response)
    };
    function _error_function(response, exception) {
        const error_message = errorConstructor(response, exception)
        deferred.reject(error_message)
    };
    function _wait_function(){
        console.log('Waiting...')
    };

// declare input schema
    var input_schema = {
        'schema': {
            'method': 'GET',
            'route': '/schema/lab-mission',
            'body': { },
            'params': { },
            'success': _success_function,
            'error': _error_function,
            'wait': _wait_function,
            'headers': { }
        },
        'components': {
            '.method': {
                'discrete_values': [ 'GET', 'POST', 'DELETE', 'PATCH', 'PUT' ]
            }
        }
    }

// ingest method arguments
    var request_dict = input_schema.schema
    unpackKwargs(request_kwargs, request_dict, 'requestingResource');

// add time to headers
    request_dict.headers['X-Timestamp'] = ($.now() / 1000)

// add session token to header
    var session_token = ingestString(loadRecord('session_token'))
    if (session_token){
        request_dict.headers['X-Sessiontoken'] = session_token
    }         
    
// construct resource url
    var resource_url = window.server_url + request_dict.route
    if (mapSize(request_dict.params)){
        resource_url += '?'
        resource_url += $.param(request_dict.params)
    }
    
// construct ajax request map 
    var ajax_map = {
        method: request_dict.method,
        timeout: 12000,
        crossDomain: true,
        headers: {},
        url: resource_url,
        contentType: 'application/json',
        success: request_dict.success,
        error: request_dict.error
    }

// add body to request
    if (Object.keys(request_dict.body).length && request_dict.method != 'GET') {
        ajax_map.data = JSON.stringify(request_dict.body)
    }

// add headers to map
    for (var key in request_dict.headers){
        ajax_map.headers[key] = request_dict.headers[key]
    };

// send ajax request
    $.ajax(ajax_map);

// initialize wait function
    request_dict.wait();

    return deferred.promise()
}

function methodConstructor(response) {

/* a method for parsing function calls from a response body */

// declare the input schema
    var input_schema = {
        'schema':  {
            'dt': 0,
            'id': '',
            'code': 0,
            'error': '',
            'methods': []
        }
    }

// unpack variables in response
    var response_dict = input_schema.schema
    unpackKwargs(response, response_dict, 'methodConstructor')

// call each method inside details
    if (response_dict['methods']) {
        if (ingestArray(response_dict['methods']).length){
            for (var i = 0; i < response_dict['methods'].length; i++) {
                try {
                    var _func_name = ingestString(response_dict['methods'][i]['function'])
                    var _func_args = ingestArray(response_dict['methods'][i]['args'])
                    callFunction(_func_name, _func_args)
                } catch(e) {
                    var console_message = 'Errr! Error constructing method ' + _func_name + '.'
                    console.log(console_message)
                    throw e
                }
            }
        }
    }

}

function stringRequest(request_string) {

/* a method to request views from server using a text string */

// add request string to context history
    updateHistory('stringRequest', [request_string])

// construct request_kwargs
    var request_kwargs = {
        method: 'POST',
        route: '/web',
        body: {
            content: request_string,
            mode: 'text',
            fingerprint: {},
            history: window.client_history
        }
    }

// add fingerprint to request
    if (mapSize(ingestMap(window.client_fingerprint))){
        request_kwargs.body.fingerprint = window.client_fingerprint
        requestingResource(request_kwargs).then(methodConstructor)
    } else {
        initializeFingerprint().then(function(){
            request_kwargs.body.fingerprint = window.client_fingerprint
            requestingResource(request_kwargs).then(methodConstructor)
        })
    }

}

function methodRequest(method_name, request_kwargs) {

/* a method to run a method with data returned from server */

// define success function
    function _success(response){
        var _func_kwargs = ingestMap(response.details)
        var _func_args = []
        if (mapSize(_func_kwargs)){
            _func_args = [_func_kwargs]
        }
        callFunction(method_name, _func_args)
    }

// send ajax request
    requestingResource(request_kwargs).done(_success)

}

function gettingResource(resource_route) {

/* a promise method for retrieving a resource from server */

// construct new promise object
    var deferred = new $.Deferred()
    
// construct ajax request map
    var resource_route = window.server_url + resource_route
    var ajax_map = {
        method: 'GET',
        timeout: 12000,
        crossDomain: true,
        headers: {},
        url: resource_route,
        contentType: 'application/json',
        success: function(response){
            window.device_online = true
            deferred.resolve(response.details)
        },
        error: function(response, exception){
            var error_message = errorConstructor(response, exception)
            deferred.reject(error_message)
        }
    }

// add time to headers
    ajax_map.headers['X-Timestamp'] = ($.now() / 1000)
    
// add session token to header
    var session_token = ingestString(loadRecord('session_token'))
    if (session_token){
        ajax_map.headers['X-Sessiontoken'] = session_token
    }         

// send ajax request
    $.ajax(ajax_map)
    
// return promise
    return deferred.promise()
    
}

function postingResource(resource_route, resource_details) {

/* a promise method for updating a resource on the server */

// construct new promise object
    var deferred = new $.Deferred()
    
// construct ajax request map
    var resource_route = window.server_url + resource_route
    var ajax_map = {
        method: 'POST',
        timeout: 12000,
        crossDomain: true,
        headers: {},
        data: JSON.stringify(resource_details),
        url: resource_route,
        contentType: 'application/json',
        success: function(response){
            window.device_online = true
            deferred.resolve(response.details)
        },
        error: function(response, exception){
            var error_message = errorConstructor(response, exception)
            deferred.reject(error_message)
        }
    }

// add time to headers
    ajax_map.headers['X-Timestamp'] = ($.now() / 1000)
    
// add session token to header
    var session_token = ingestString(loadRecord('session_token'))
    if (session_token){
        ajax_map.headers['X-Sessiontoken'] = session_token
    }         

// send ajax request
    $.ajax(ajax_map)
    
// return promise
    return deferred.promise()

}

function deletingResource(resource_route) {

/* a promise method for deleting a resource on the server */

// construct new promise object
    var deferred = new $.Deferred()
    
// construct ajax request map
    var resource_route = window.server_url + resource_route
    var ajax_map = {
        method: 'DELETE',
        timeout: 12000,
        crossDomain: true,
        headers: {},
        url: resource_route,
        contentType: 'application/json',
        success: function(response){
            window.device_online = true
            deferred.resolve(response.details)
        },
        error: function(response, exception){
            var error_message = errorConstructor(response, exception)
            deferred.reject(error_message)
        }
    }

// add time to headers
    ajax_map.headers['X-Timestamp'] = ($.now() / 1000)
    
// add session token to header
    var session_token = ingestString(loadRecord('session_token'))
    if (session_token){
        ajax_map.headers['X-Sessiontoken'] = session_token
    }         

// send ajax request
    $.ajax(ajax_map)
    
// return promise
    return deferred.promise()

}

function gettingSession() {

/* a promise method to request (and save) a session token from the server */

// construct new promise object
    var deferred = new $.Deferred()
    
// construct ajax request
    var session_route = window.server_url + '/session'
    var ajax_map = {
        method: 'GET',
        timeout: 12000,
        crossDomain: true,
        headers: {},
        url: session_route,
        contentType: 'application/json',
        success: function( response ) {
            window.device_online = true
            var session_token = response.details.session_token
            saveRecord('session_token', session_token)
            console.log('Session token acquired.')
            deferred.resolve(session_token)
        },
        error: function( response, exception ) {
            var error_message = errorConstructor(response, exception)
            deferred.reject(error_message)
        }
    }

// send ajax request
    $.ajax(ajax_map)
    console.log('Retrieving new session token.')
    
    return deferred.promise()

}

function puttingSession(account_email) {

/* a promise method to retrieve a partially authenticated session token */
    
// construct new promise object
    var deferred = new $.Deferred()
    
// construct ajax request
    var session_route = window.server_url + '/session'
    var ajax_map = {
        method: 'PUT',
        timeout: 12000,
        crossDomain: true,
        headers: {},
        url: session_route,
        contentType: 'application/json',
        success: function( response ) {
            window.device_online = true
            var session_token = response.details.session_token
            var confirm_status = response.details.confirm
            saveRecord('session_token', session_token)
            console.log('Session token updated.')
            deferred.resolve(session_token, account_email, confirm_status)
        },
        error: function( response, exception ) {
            var error_message = errorConstructor(response, exception)
            deferred.reject(error_message)
        }
    }

// add time to headers
    ajax_map.headers['X-Timestamp'] = ($.now() / 1000)

// add session token to header
    var session_token = ingestString(loadRecord('session_token'))
    if (session_token) {
        ajax_map.headers['X-Sessiontoken'] = session_token
    }

// construct body
    var ajax_body = {
        'account_email': account_email
    }
    
// retrieve fingerprint and send ajax request (TODO pipe client addresses into request)
    if (mapSize(ingestMap(window.client_fingerprint))){
        ajax_body['client_fingerprint'] = window.client_fingerprint
        ajax_map.data = JSON.stringify(ajax_body)
        $.ajax(ajax_map)
    } else {
        initializeFingerprint().then(function(client_fingerprint){
            ajax_body['client_fingerprint'] = client_fingerprint
            ajax_map.data = JSON.stringify(ajax_body)
            $.ajax(ajax_map)
        })
    }
    
    return deferred.promise()

}

function postingSession(account_password) {

/* a promise method to retrieve an authenticated session token */
    
// construct new promise object
    var deferred = new $.Deferred()
    
// construct ajax request
    var session_route = window.server_url + '/session'
    var ajax_map = {
        method: 'POST',
        timeout: 12000,
        crossDomain: true,
        headers: {},
        url: session_route,
        contentType: 'application/json',
        success: function( response ) {
        
        // update device status and save session token
            window.device_online = true
            var account_active = false
            var session_token = response.details.session_token
            saveRecord('session_token', session_token)
            
        // activate pouchdb with account credentials
            var gateway_auth = ingestMap(response.details.gateway_auth)
            if (mapSize(gateway_auth)){
                saveRecord('gateway_auth', gateway_auth)
                account_active = true
                startingPouchDB().then(function(){
                    deferred.resolve(session_token, account_active)
                })
            }
        
        // log outcome and resolve promise
            console.log('Session token updated.')
            if (!account_active){
                deferred.resolve(session_token, account_active)
            }
            
        },
        error: function( response, exception ) {
            var error_message = errorConstructor(response, exception)
            deferred.reject(error_message)
        }
    }

// add time to headers
    ajax_map.headers['X-Timestamp'] = ($.now() / 1000)

// add session token to header
    var session_token = ingestString(loadRecord('session_token'))
    if (session_token) {
        ajax_map.headers['X-Sessiontoken'] = session_token
    }

// construct body
    var ajax_body = {
        'account_password': account_password
    }
    
// retrieve fingerprint and send ajax request (TODO pipe client addresses into request)
    if (mapSize(ingestMap(window.client_fingerprint))){
        ajax_body['client_fingerprint'] = window.client_fingerprint
        ajax_map.data = JSON.stringify(ajax_body)
        $.ajax(ajax_map)
    } else {
        initializeFingerprint().then(function(client_fingerprint){
            ajax_body['client_fingerprint'] = client_fingerprint
            ajax_map.data = JSON.stringify(ajax_body)
            $.ajax(ajax_map)
        })
    }
    
    return deferred.promise()

}

function patchingSession() {

/* a promise method for renewing a session token */

// construct new promise object
    var deferred = new $.Deferred()
    
// construct ajax request
    var session_route = window.server_url + '/session'
    var ajax_map = {
        method: 'PATCH',
        timeout: 12000,
        crossDomain: true,
        headers: {},
        url: session_route,
        contentType: 'application/json',
        success: function( response ) {
            window.device_online = true
            var session_token = response.details.session_token
            saveRecord('session_token', session_token)
            console.log('Session token updated.')
            deferred.resolve(session_token)
        },
        error: function( response, exception ) {
            var error_message = errorConstructor(response, exception)
            deferred.reject(error_message)
        }
    }

// add time to headers
    ajax_map.headers['X-Timestamp'] = ($.now() / 1000)

// add session token to header
    var session_token = ingestString(loadRecord('session_token'))
    if (session_token) {
        ajax_map.headers['X-Sessiontoken'] = session_token
    }

// construct body
    var ajax_body = {}
    
// retrieve fingerprint and send ajax request
    initializeFingerprint().then(function(client_fingerprint){
        ajax_body['client_fingerprint'] = client_fingerprint
        ajax_map.data = JSON.stringify(ajax_body)
//        if ('pouch_db' in window){
//            var canceling_remotes = []
//            for (var key in window.pouch_db){
//                if (key.match(/_handler$/)){
//                    if (window.pouch_db[key]){
//                        canceling_remotes.push(window.pouch_db[key].cancel())
//                    }
//                }
//            }
//            if (canceling_remotes.length){
//                $.when(canceling_remotes).then(function(){
//                    var closing_remotes = []
//                    for (var key in window.pouch_db){
//                        if (key.match(/_remote$/)){
//                            closing_remotes.push(window.pouch_db[key].close())
//                        }
//                    }
//                    $.when(closing_remotes).then(function(){
//                        $.ajax(ajax_map)
//                    })
//                })
//            } else {
//                $.ajax(ajax_map)
//            }   
//        } else {
//            $.ajax(ajax_map)
//        }
        $.ajax(ajax_map)
    })

// log request
    console.log('Renewing device signature.')
    
    return deferred.promise()

}

function gettingAccount() {

/* a promise method to retrieve the latest account settings */

// construct new promise object
    var deferred = new $.Deferred()
    
// construct request_kwargs
    var record_key = 'account_settings'
    var request_kwargs = {
        method: 'GET',
        route: '/account'
    }

// define device offline fallback
    function _device_offline(){
        loadRecord(record_key, function(details){
            console.log('Device offline. Using local device records.')
            deferred.resolve(details)
        })
    }    
    
// if offline, load record from local device
    if (!ingestBoolean(window.device_online)){
    
        _device_offline()

// if online, get record from remote server
    } else {
    
    // define success function
        function _success(response){
            var server_details = response.details
            var server_timestamp = ingestNumber(response.updated)
            saveRecord(record_key, server_details, server_timestamp)
            deferred.resolve(server_details)
        }
        
    // send request and wait for response
        var resource_request = requestingResource(request_kwargs)
        resource_request.done(_success)
        resource_request.fail(function(error_message){
        
        // handle errors
            handlingSession(error_message).fail(function(msg){
            
        // repeat request after renewal of session
                if (msg == 'acquired'){
                    if ('authentication_view' in window){
                        window.authentication_view()
                    } else {
                        openAuthentication()
                    }
                } else if (msg == 'renewal') {
                    var repeat_request = gettingAccount()
                    repeat_request.done(function(details){ deferred.resolve(details)})
                    repeat_request.fail(function(msg){
                        if (!window.device_online){
                            _device_offline()
                        } else {
                            deferred.reject(msg)
                        } 
                    })
                } else if (!window.device_online) {
                    _device_offline()
                } else {
                    deferred.reject(error_message)
                }
            })
            
        })

    } 

    return deferred.promise()
     
}

function puttingAccount(account_email, account_password) {

/* a promise method to create a new account */
    
// construct new promise object
    var deferred = new $.Deferred()
    
// construct ajax request
    var account_route = window.server_url + '/account'
    var ajax_map = {
        method: 'PUT',
        timeout: 12000,
        crossDomain: true,
        headers: {},
        url: account_route,
        contentType: 'application/json',
        success: function( response ) {
            window.device_online = true
            var session_token = response.details.session_token
            saveRecord('session_token', session_token)
            console.log('Account created.')
            deferred.resolve(session_token, account_email)
        },
        error: function( response, exception ) {
            var error_message = errorConstructor(response, exception)
            deferred.reject(error_message)
        }
    }

// add time to headers
    ajax_map.headers['X-Timestamp'] = ($.now() / 1000)

// add session token to header
    var session_token = ingestString(loadRecord('session_token'))
    if (session_token) {
        ajax_map.headers['X-Sessiontoken'] = session_token
    }

// construct body
    var ajax_body = {
        'account_email': account_email
    }
    if (ingestString(account_password)){
        ajax_body['account_password'] = account_password
    }
    
// retrieve fingerprint and send ajax request
    if (mapSize(ingestMap(window.client_fingerprint))){
        ajax_body['client_fingerprint'] = window.client_fingerprint
        ajax_map.data = JSON.stringify(ajax_body)
        $.ajax(ajax_map)
    } else {
        initializeFingerprint().then(function(client_fingerprint){
            ajax_body['client_fingerprint'] = client_fingerprint
            ajax_map.data = JSON.stringify(ajax_body)
            $.ajax(ajax_map)
        })
    }
    
    return deferred.promise()

}

function postingAccount(account_email, account_action) {

/* a promise method to request a password reset */
    
// construct new promise object
    var deferred = new $.Deferred()
    
// construct ajax request
    var account_route = window.server_url + '/account'
    var ajax_map = {
        method: 'POST',
        timeout: 12000,
        crossDomain: true,
        headers: {},
        url: account_route,
        contentType: 'application/json',
        success: function( response ) {
            window.device_online = true
            var session_token = response.details.session_token
            var confirm_status = response.details.confirm
            saveRecord('session_token', session_token)
            if (confirm_status){
                console.log('Confirmation resent.')
            } else {
                console.log('Reset sent.')
            }
            deferred.resolve(session_token, account_email)
        },
        error: function( response, exception ) {
            var error_message = errorConstructor(response, exception)
            deferred.reject(error_message)
        }
    }

// add time to headers
    ajax_map.headers['X-Timestamp'] = ($.now() / 1000)

// add session token to header
    var session_token = ingestString(loadRecord('session_token'))
    if (session_token) {
        ajax_map.headers['X-Sessiontoken'] = session_token
    }

// construct body
    var ajax_body = {
        'account_email': account_email,
        'account_action': account_action
    }
    
// retrieve fingerprint and send ajax request
    if (mapSize(ingestMap(window.client_fingerprint))){
        ajax_body['client_fingerprint'] = window.client_fingerprint
        ajax_map.data = JSON.stringify(ajax_body)
        $.ajax(ajax_map)
    } else {
        initializeFingerprint().then(function(client_fingerprint){
            ajax_body['client_fingerprint'] = client_fingerprint
            ajax_map.data = JSON.stringify(ajax_body)
            $.ajax(ajax_map)
        })
    }
    
    return deferred.promise()

}

function patchingAccount(new_password='', account_password='', account_token='', new_email='') {

/* a promise function to update account password */
    
// construct new promise object
    var deferred = new $.Deferred()
    
// construct ajax request
    var account_route = window.server_url + '/account'
    var ajax_map = {
        method: 'PATCH',
        timeout: 12000,
        crossDomain: true,
        headers: {},
        url: account_route,
        contentType: 'application/json',
        success: function( response ) {
            window.device_online = true
            var session_token = response.details.session_token
            saveRecord('session_token', session_token)
        // if account is new, startup pouchdb
            var gateway_auth = ingestMap(response.details.gateway_auth)
            var promise_fulfilled = false
            if (mapSize(gateway_auth)){
                saveRecord('gateway_auth', gateway_auth)
                promise_fulfilled = true
                startingPouchDB().then(function(){
                    console.log('Account confirmed.')
                    deferred.resolve(session_token)
                })
            }
        // else just update session token
            if (!promise_fulfilled){
                console.log('Password updated.')
                deferred.resolve(session_token)
            }
        },
        error: function( response, exception ) {
            var error_message = errorConstructor(response, exception)
            deferred.reject(error_message)
        }
    }

// add time to headers
    ajax_map.headers['X-Timestamp'] = ($.now() / 1000)

// add session token to header
    var session_token = ingestString(loadRecord('session_token'))
    if (session_token) {
        ajax_map.headers['X-Sessiontoken'] = session_token
    }

// construct body
    var ajax_body = {}
    if (new_password){ ajax_body['new_password'] = new_password }
    if (account_password){ ajax_body['account_password'] = account_password }
    if (account_token){ ajax_body['account_token'] = account_token }
    if (new_email){ ajax_body['new_email'] = new_email }
    
// retrieve fingerprint and send ajax request
    if (mapSize(ingestMap(window.client_fingerprint))){
        ajax_body['client_fingerprint'] = window.client_fingerprint
        ajax_map.data = JSON.stringify(ajax_body)
        $.ajax(ajax_map)
    } else {
        initializeFingerprint().then(function(client_fingerprint){
            ajax_body['client_fingerprint'] = client_fingerprint
            ajax_map.data = JSON.stringify(ajax_body)
            $.ajax(ajax_map)
        })
    }
    
    return deferred.promise()
    
}

function deletingAccount(status_action, account_password) {

/* a promise function to update account password */
    
// construct new promise object
    var deferred = new $.Deferred()
    
// construct ajax request
    var account_route = window.server_url + '/account'
    var ajax_map = {
        method: 'DELETE',
        timeout: 12000,
        crossDomain: true,
        headers: {},
        url: account_route,
        contentType: 'application/json',
        success: function( response ) {
            window.device_online = true
            var session_token = response.details.session_token
            saveRecord('session_token', session_token)
        // reactivate pouchdb with new account credentials
            var gateway_auth = ingestMap(response.details.gateway_auth)
            var promise_fulfilled = false
            if (mapSize(gateway_auth)){
                saveRecord('gateway_auth', gateway_auth)
                promise_fulfilled = true
                startingPouchDB().then(function(){
                    deferred.resolve(session_token)
                })
            } 
        // deactivate pouchdb
            else {
                stoppingPouch(window.pouch_db)
                deleteRecord('gateway_auth')
            }
        // log result
            console.log('Account ' + status_action + 'd.')
            if (!promise_fulfilled){
                deferred.resolve(session_token)
            }
        },
        error: function( response, exception ) {
            var error_message = errorConstructor(response, exception)
            deferred.reject(error_message)
        }
    }

// add time to headers
    ajax_map.headers['X-Timestamp'] = ($.now() / 1000)

// add session token to header
    var session_token = ingestString(loadRecord('session_token'))
    if (session_token) {
        ajax_map.headers['X-Sessiontoken'] = session_token
    }

// construct body
    var ajax_body = {
        'status_action': status_action,
        'account_password': account_password
    }
    
// retrieve fingerprint and send ajax request
    if (mapSize(ingestMap(window.client_fingerprint))){
        ajax_body['client_fingerprint'] = window.client_fingerprint
        ajax_map.data = JSON.stringify(ajax_body)
        $.ajax(ajax_map)
    } else {
        initializeFingerprint().then(function(client_fingerprint){
            ajax_body['client_fingerprint'] = client_fingerprint
            ajax_map.data = JSON.stringify(ajax_body)
            $.ajax(ajax_map)
        })
    }
    
    return deferred.promise()
    
}

function handlingSession(error_message) {

/* a promise method to handle session errors */

// construct new promise object
    var deferred = new $.Deferred()

// construct regex map
    error_patterns = {
        expired: new RegExp(/Session\stoken\shas\sexpired/g),
        decoding: new RegExp(/Session\stoken\sdecoding\serror/g),
        renewal: new RegExp(/Device\ssignature\shas\sexpired/g),
        confirm: new RegExp(/Account\shas\snot\sbeen\sconfirmed/g),
        anonymous: new RegExp(/Account\sis\snot\sauthenticated/g),
        missing: new RegExp(/Account\sdoes\snot\sexist/g),
        password: new RegExp(/Password\sdoes\snot\smatch\spassword\son\srecord/g),
        deactivated: new RegExp(/Account\shas\sbeen\sdeactivated/g)
    }
    
// handle session token expiration
    if (window.error_patterns.expired.test(error_message) || window.error_patterns.decoding.test(error_message)){
        deleteRecord('session_token')
        gettingSession().then(function(session_token){
            deferred.reject('acquired')
        })
// handle device signature renewal
    } else if (window.error_patterns.renewal.test(error_message)){
        patchingSession().then(function(session_token){
            deferred.reject('renewal')
        })
// handle not authenticated
    } else if (window.error_patterns.anonymous.test(error_message)){
        deferred.reject('authentication')
        if ('authentication_view' in window){
            window.authentication_view()
        } else {
            openAuthentication()
        }
// handle account deactivated
    } else if (window.error_patterns.deactivated.test(error_message)){
        deferred.reject('deactivated')
        openAccount()
// or pass through message
    } else {
        deferred.reject(error_message)
    }
    
    return deferred.promise()
}

function requestingOAuthToken(service_name, service_scopes, callback=null) {

/* a promise method to get an access token from an oauth2 service */

// construct new promise
    var deferred = new $.Deferred()
    
// define callback function
    function _callback(exit_msg){
        if (callback) {
            deferred.resolve()
            callFunction(callback, [exit_msg])
        } else {
            deferred.resolve(exit_msg)
        }
    }
    
// if offline, load record from local device
    if (!ingestBoolean(window.device_online)){
    
        deferred.reject('Device offline.')
    
    } else {
    
// define success function
        function _success(response) {
    
    // toggle device online
            window.device_online = true
            
    // open oauth window
            var auth_url = response.details.auth_url
            var win_popup = window.open(auth_url, '_blank')
            
    // set timer to close window
            var waiter_count = 0
            var win_waiter = setInterval(function(){
                try {
                    var win_url = ingestString(win_popup.document.URL)
                    if (win_url.indexOf(window.server_url) > -1 && win_url.indexOf('authorize') == -1) {
                        var win_meta = $(win_popup.document).contents().find('[name=oauth2_service_callback]')
                        if (win_meta.length) {
                            setTimeout(function(){    
                                try { win_popup.close() } catch(e) {}
                            }, 10000)
                            _callback('success')
                        } else {
                            try { win_popup.close() } catch(e) {}
                            deferred.reject('Permission denied.')
                        }
                        window.clearInterval(win_waiter)
                    }
                    waiter_count += 1
                } catch(e) {
                    try {
                        if (win_popup.closed){
                            window.clearInterval(win_waiter)
                            deferred.reject('Authorization closed.')
                        } else {
                            waiter_count += 1
                        }
                    } catch(e) {
                        waiter_count += 1
                    }
                }
                if (waiter_count > 300 ) {
                    try { win_popup.close() } catch(e) {}
                    window.clearInterval(win_waiter)
                    deferred.reject('Authorization timeout.')
                }
            }, 500)
           
        }
        
// determine request route
        var resource_route = window.server_url + '/urls/oauth2/' + service_name.replace(/_/g, '-')
        var param_fields = { scope: service_scopes.join(' ') }
        resource_route = resource_route + '?' + $.param(param_fields)
        
// construct ajax fields with sync request
        var ajax_map = {
            method: 'GET',
            timeout: 12000,
            crossDomain: true,
            headers: { 'X-Timestamp': ($.now() / 1000) },
            url: resource_route,
            contentType: 'application/json',
            success: _success,
            error: function(response, exception){
                const error_message = errorConstructor(response, exception)
                handlingSession(error_message).always(function(msg){
                // repeat request if session expiration was renewed
                    if (msg == 'renewal') {
                        var exit_msg = 'Expired device signature was renewed. Try again.'
                        deferred.reject(exit_msg)
                    } else {
                        deferred.reject(msg)
                    }
                })
            },
            async: false
        }
        
// add session token to header
        var session_token = ingestString(loadRecord('session_token'))
        if (session_token){
            ajax_map.headers['X-Sessiontoken'] = session_token
        }         
                
// make request
        $.ajax(ajax_map)
        
    }
    
    return deferred.promise()

}

function renewingOAuthToken(service_name, callback=null) {

/* a promise to renew an existing access token */
    
    logConsole('renewing')
    
// construct a new promise
    var deferred = new $.Deferred()

// define callback function
    function _callback(token_details){
        if (callback) {
            deferred.resolve()
            callFunction(callback, [token_details])
        } else {
            deferred.resolve(token_details)
        }
    }
    
// if offline, load record from local device
    if (!ingestBoolean(window.device_online)){
    
        deferred.reject('Device offline.')
    
    } else {
            
// determine request route
        var resource_route = window.server_url + '/authorize/' + service_name.replace(/_/g, '-')
        
// construct ajax fields with sync request
        var ajax_map = {
            method: 'PATCH',
            timeout: 12000,
            crossDomain: true,
            headers: { 'X-Timestamp': ($.now() / 1000) },
            url: resource_route,
            contentType: 'application/json',
            success: function(response){
                logConsole(resource_route)
                logConsole(['success', response.status])
                window.device_online = true
                _callback(response.details.token)
            },
            error: function(response, exception){
                logConsole(resource_route)
                logConsole(['error', response.status])
                const error_message = errorConstructor(response, exception)
                handlingSession(error_message).always(function(msg){
                // repeat request if session expiration was renewed
                    if (msg == 'renewal') {
                        var repeat_request = renewingOAuthToken(service_name, callback)
                        repeat_request.done(function(details){ deferred.resolve(details) })
                        repeat_request.fail(function(_msg){
                            deferred.reject(_msg)
                        })
                    } else {
                        deferred.reject(msg)
                    }
                })
            }
            // async: false
        }
        
// add session token to header
        var session_token = ingestString(loadRecord('session_token'))
        if (session_token){
            ajax_map.headers['X-Sessiontoken'] = session_token
        }         
                
// make request
        $.ajax(ajax_map)
        
    }
    
    return deferred.promise()
    
}

// custom-made localstorage db synchronization classes
function loadingItem(table_key, item_key, rest_endpoint, callback=null) {

    /* a promise method to get an item from the server and synchronize it with the client */

// construct new promise object
    var deferred = new $.Deferred()
    
    
// construct request_kwargs
    var item_endpoint = rest_endpoint + '/' + item_key
    var request_kwargs = {
        method: 'GET',
        route: item_endpoint
    }

// define callback function
    function _callback(item_details){
        if (callback) {
            deferred.resolve()
            callFunction(callback, [item_details])
        } else {
            deferred.resolve(item_details)
        }
    }

// define device offline fallback
    function _device_offline(){
        loadItem(table_key, item_key, function(meta_details){
            console.log('Device offline. Loading item from local device.')
            var item_details = null
            if (meta_details){
                item_details = meta_details.item
            }
            _callback(item_details)
        })
    }

// if offline, load record from local device
    if (!ingestBoolean(window.device_online)){
    
        _device_offline()

// if online, get record from remote server
    } else {
    
    // define success function
        function _success(response){
        
        // ingest server response and retrieve local version of item
            var server_item = ingestMap(response.details)
            var server_timestamp = ingestNumber(response.updated)
            var client_item = loadItem(table_key, item_key)
        
        // synchronize records
            if (client_item.dt <= server_timestamp){
                saveItem(table_key, item_key, server_item, server_timestamp, overwrite=false)
                _callback(server_item)
            } else {
                var update_request = savingItem(table_key, item_key, client_item.item, client_item.dt, rest_endpoint)
                update_request.done(_callback)
                update_request.fail(function(error_message){ deferred.reject(error_message)})
            }
        
        }
        
    // send request and wait for response
        var resource_request = requestingResource(request_kwargs)
        resource_request.done(_success)
        resource_request.fail(function(error_message){
        
        // handle errors
            handlingSession(error_message).fail(function(msg){
            
        // repeat request after renewal of session
                if (msg == 'acquired'){
                    if ('authentication_view' in window){
                        window.authentication_view()
                    } else {
                        openAuthentication()
                    }
                } if (msg == 'renewal') {
                    var repeat_request = gettingItem(table_key, item_key, rest_endpoint, callback)
                    repeat_request.done(function(record_array){ deferred.resolve(record_array)})
                    repeat_request.fail(function(msg){
                        if (!window.device_online){
                            _device_offline()
                        } else {
                            deferred.reject(msg)
                        } 
                    })
                } else if (!window.device_online) {
                    _device_offline()
                } else {
                    deferred.reject(error_message)
                }
            })
            
        })   
         
    }

}

function listingItems(table_key, rest_endpoint, sort_criteria=null, filter_criteria=null, max_results=0, callback=null) {

    /* a promise method to get an array of synchronized item keys from the server */

// construct new promise object
    var deferred = new $.Deferred()
    
// construct request_kwargs
    var request_kwargs = {
        method: 'GET',
        route: rest_endpoint,
    }

// ingest arguments
    filter_criteria = ingestMap(filter_criteria)
    max_results = ingestNumber(max_results)
    if (maxSize(filter_criteria) || max_results){
        request_kwargs['params'] = {}
    }

// add optional params
    if (mapSize(filter_criteria)){
        var _filter_criteria = {}
        for (var key in filter_criteria){
            if (key.slice(0,1) != '.'){
                var dot_key = '.' + key
                _filter_criteria[dot_key] = filter_criteria[key]
            } else {
                _filter_criteria[key] = filter_criteria[key]
            }
        }
        request_kwargs['params']['query'] = JSON.stringify(_filter_criteria)
    }
    if (max_results){
        request_kwargs.params['results'] = max_results
    }

// define callback function
    function _callback(item_keys){
        if (callback) {
            deferred.resolve()
            callFunction(callback, [item_keys])
        } else {
            deferred.resolve(item_keys)
        }
    }

// define device offline fallback
    function _device_offline(){
        listItems(table_key, order_criteria, filter_criteria, max_results, function(item_keys){
            console.log('Device offline. Listing items on local device.')
            _callback(item_keys)
        })
    }    
    
// if offline, load record from local device
    if (!ingestBoolean(window.device_online)){
    
        _device_offline()

// if online, get record from remote server
    } else {
    
    // define success function
        function _success(response){
        
        // ingest response and load deletion markers
            var marker_key = table_key + '_deletion_markers'
            var deletion_markers = ingestMap(loadRecord(marker_key))
            var server_keys = ingestArray(response.details)
        
        // synchronize client and server
            var keys_to_report = []
            for (var i = 0; i < server_keys.length; i++){
                if (server_keys[i] in deletion_markers){
                    deletingItem(table_key, server_keys[i], rest_endpoint)
                } else {
                    keys_to_report.push(server_keys[i])
                }
            }
            _callback(keys_to_report)
        
        }
    
    // send request and wait for response
        var resource_request = requestingResource(request_kwargs)
        resource_request.done(_success)
        resource_request.fail(function(error_message){
        
        // handle errors
            handlingSession(error_message).fail(function(msg){
            
        // repeat request after renewal of session
                if (msg == 'acquired'){
                    if ('authentication_view' in window){
                        window.authentication_view()
                    } else {
                        openAuthentication()
                    }
                } if (msg == 'renewal') {
                    var repeat_request = listingItems(table_key, rest_endpoint, sort_criteria, filter_criteria, max_results, callback)
                    repeat_request.done(function(item_keys){ deferred.resolve(item_keys)})
                    repeat_request.fail(function(msg){
                        if (!window.device_online){
                            _device_offline()
                        } else {
                            deferred.reject(msg)
                        } 
                    })
                } else if (!window.device_online) {
                    _device_offline()
                } else {
                    deferred.reject(error_message)
                }
            })
            
        })   
       
    }
    
}

function savingItem(table_key, item_key, item_details, item_timestamp=0.0, rest_endpoint, overwrite=true,callback=null) {

    /* a promise method to put an item on the server and synchronize it with the client */

// construct new promise object
    var deferred = new $.Deferred()
    
    
// construct request_kwargs
    var item_endpoint = rest_endpoint + '/' + item_key
    var request_kwargs = {
        method: 'GET',
        route: item_endpoint
    }

// define callback function
    function _callback(item_details){
        if (callback) {
            deferred.resolve()
            callFunction(callback, [item_details])
        } else {
            deferred.resolve(item_details)
        }
    }



}

function deletingItem(table_key, item_key, rest_endpoint, callback=null) {

// TODO promise to delete item on client and server

}

/**
* TRANSCRIPTION JAVASCRIPT EXTENSION
* @author rcj1492
* @license Â©2017-2018 Collective Acuity
* @email support@collectiveacuity.com
*
* requirements:
* jquery
* jquery.isonscreen.min.js
* sprintf
* autosize
* sha256
* gapi
* lab.js
* data.js
* audio.js
* forms.js
* requests.js
* sockets.js
* views.js
**/

//// import dependencies
//import $ from 'jquery'
//import sprintf from 'sprintf'
//import autosize from 'autosize'
//import sha256 from 'sha256'
//import gapi from 'google.api'
//import { loadRecord, saveItem, loadItem } from 'data'
//import { startSpeechTranscription, stopSpeechTranscription } from 'audio'
//import { showMessage, inputHandler } from 'forms'
//import { renewingOAuthToken } from 'requests'
//import { retrievingOAuthToken, toggleChannels, loadingBucket, loadingServices, loadingLibrary, paginateView } from 'views'
//import { logConsole, ingestString, ingestArray, ingestBoolean, ingestMap, mapSize, ingestNumber,  deepCopy, updateHistory } from 'lab'

function markupTranscription(transcript_tokens, transcript_doc_id){
    
    /* a method to construct DOM elements from a map of transcribed words */
    
// define map output of function
    var output = {
        html: '',
        selectors: [],
        array: []
    }

// construct an array of words
    var transcript_array = []
    var token_keys = []
    for (var key in transcript_tokens){
        token_keys.push(key)
    }
    token_keys.sort()
    for (var i = 0; i < token_keys.length; i++){
        transcript_array.push({
            dt: parseFloat(token_keys[i]),
            text: transcript_tokens[token_keys[i]].t,
            fx: transcript_tokens[token_keys[i]].fx
        })
    }
    
// iterate over array of words
    for (var i = 0; i < transcript_array.length; i++){
    
    // ingest fields
        const word_value = transcript_array[i].text
        const word_dt = transcript_array[i].dt
        const word_effects = ingestArray(transcript_array[i].fx)
        const word_date = word_dt.toString().replace(/\./g, '_')
        const word_id = sprintf('%s_%s', transcript_doc_id, word_date)
        const word_text_id = word_id + '_t'
        const word_space_id = word_id + '_s'
    
    // construct html
        const word_text_html = sprintf('<span id="%s">%s</span>', word_text_id, word_value)
        const word_space_html = sprintf('<span id="%s"> </span>', word_space_id)
    
    // add spaces to markup
        output.html += word_space_html
        output.selectors.push({id: '#' + word_space_id, effects: word_effects})
        output.array.push(word_space_html)
    
    // add words to markup
        output.html += word_text_html
        output.selectors.push({id: '#' + word_text_id, date: word_date, dt: word_dt, effects: word_effects})
        output.array.push(word_text_html)
        
    }
    
    return output
    
}

function transcriptListeners(selector_array, media_array, prior_token=null){

    /* a method to add listeners to the words in a transcript */

// define method variables
    var media_db = window.pouch_db.source_media
    var media_remote = window.pouch_db.source_media_remote
    
// determine prior values
    var prior_word = {
        slide: '',
        color: 'font-gray'
    }
    if (prior_token){
        var prior_data = ingestMap(prior_token.data())
        var prior_class = ingestString(prior_token.attr('class'))
        prior_word.slide = ingestString(prior_data['fxShowSlide'])
        if (prior_class.indexOf('font-purple') > -1){
            prior_word.color = 'font-purple'
        } else if (prior_class.indexOf('font-text') > -1){
            prior_word.color = 'font-text'
        }
    }
    
// iterate over the elements in the selector array
    for (var i = 0; i < selector_array.length; i++){
    
    // add word metadata to element data
        var word_fields = selector_array[i]
        const word_id = ingestString(word_fields.id)
        const word_dt = ingestNumber(word_fields.dt)
        const word_effects = ingestArray(word_fields.effects)
        if (word_dt){
            $(word_id).attr('data-dt', word_dt.toString())
        }
    
    // determine default word effect properties
        if (!word_effects.length){
            prior_word = {
                slide: '',
                color: 'font-gray'
            }
        }
    
    // change word effect properties and inject word effect data into DOM
        for (var j = 0; j < word_effects.length; j++){
            var effect_fields = word_effects[j]
            const effect_serv = ingestString(effect_fields.serv)
            const effect_func = ingestString(effect_fields.func)
            const effect_args = ingestArray(effect_fields.args)
            if (effect_func == 'showSlide'){
                var word_slide = ''
                if (effect_args.length == 1){
                    word_slide = effect_args[0]
                } else if (effect_args.length > 1){
                    word_slide = effect_args.join()
                }
                $(word_id).attr('data-fx-show-slide', word_slide)
                if (prior_word.slide){
                    if (prior_word.slide == word_slide){
                       // keep same color
                    } else if (prior_word.color == 'font-text') {
                        prior_word.color = 'font-purple'
                    } else {
                        prior_word.color = 'font-text'
                    }
                } else {
                    prior_word.color = 'font-text'
                }
                prior_word.slide = word_slide
            }
        }
    
    // add font color
        $(word_id).addClass(prior_word.color)
    
    // add hover effect to element
        $(word_id).mouseenter(function(){
            
            const session_token = ingestString(loadRecord('session_token'))
            const slide_image = ingestString($(word_id).attr('data-fx-show-slide')).split(',')
            if (slide_image.length){
                
                const word_dt = parseFloat($(word_id).attr('data-dt'))
                
            // define thumbnail generator    
                function _generate_thumbnail(slide_url){
                    var message_kwargs = {
                        anchor_selector: word_id,
                        // message_text: word_dt + ' ' + image_effect,
                        message_status: 'normal',
                        message_location: 'top',
                        message_html: sprintf('<img src="%s" class="icon-thumb float-top">', slide_url)
                    }
                    showMessage(message_kwargs)
                }
            
            // determine url of slide to show
                var slide_url = ''
                if (slide_image.length < 3){
                    if (slide_image[0].indexOf('http') == 0){
                        slide_url = slide_image[0]
                    } else {
                        slide_url = slide_image[0] + '?token=' + session_token
                    }
                } else {
                    const slide_hash = sha256(slide_image[0] + slide_image[1] + slide_image[2])
                    var transcript_media_array = []
                    for (var j = 0; j < media_array.length; j++){
                        if (media_array[j].indexOf(slide_hash) == 0){
                            transcript_media_array.push(media_array[j])
                        }
                    }
                    transcript_media_array.sort(function(a,b){ return b - a; })
                    for (var j = 0; j < transcript_media_array.length; j++){
                        if (slide_hash + '.' + word_dt + '.png' >= transcript_media_array[j]){
                            slide_url = '/media/' + transcript_media_array[j] + '?token=' + session_token
                            break
                        }
                    }
                }
                if (slide_url){
                    _generate_thumbnail(slide_url)
                }
                
            }
              
        })
        
        $(word_id).mouseleave(function(){
            var message_selector = '#dialog_status_message_' + word_id.replace('#','').toLowerCase()
            $(message_selector).remove()
        })
        
    }
        
}

function toggleTranscription(socket_client, transcript_text_id, transcript_doc_id, button_selectors=null) {

    /* a method to enable/disable speech transcription and manage sockets with server */

// construct tokens db
    var transcripts_db = window.pouch_db.audio_transcripts
    var transcripts_remote = window.pouch_db.audio_transcripts_remote
    
// determine action to perform
    var transcript_index = window.socket_channels.indexOf('transcription')
    var transcript_action = 'disable'
    if (transcript_index == -1 && ingestString(transcript_text_id)){
        transcript_action = 'enable'
    } else if (transcript_index > -1 && ingestString(transcript_text_id)){
        transcript_action = 'switch'
    }

//// determine speech state to update
//    var speech_action = ''
//    if (transcript_action == 'disable'){
//        speech_action = 'enable'
//    } else if (transcript_action == 'enable'){
//        speech_action = 'disable'
//    }
    
// disable speech while transcription is active
    var speech_action = ''
    var speech_index = window.socket_channels.indexOf('speech')
    if (speech_index > -1 && transcript_action == 'enable'){
        window.socket_channels_speech_memory = true
        toggleChannels(socket_client, 'speech', emit_update=false)
        speech_action = 'disable'
    } else if ('socket_channels_speech_memory' in window && transcript_action == 'disable') {
        toggleChannels(socket_client, 'speech', emit_update=false)
        delete window.socket_channels_speech_memory
        speech_action = 'renable'
    }

// define speech enable listener
    function _enable_speech(channel_selector, title_text){
        $(channel_selector).click(function(){
            toggleChannels(socket_client, 'speech')
        })
        $(channel_selector).attr('title', title_text)
        $(channel_selector).removeClass('hidden-link font-faded') 
    }

// define speech disable listener
    function _disable_speech(channel_selector){
        $(channel_selector).off()
        $(channel_selector).attr('title', 'Disabled While Transcription Active')
        $(channel_selector).addClass('hidden-link font-faded')
    }
    
// toggle speech link
    const channel_footer_id = '#footer_navigation_speech_link'
    const channel_header_id = '#header_navigation_speech_link'
    if ($(channel_footer_id).length){
        if (speech_action == 'disable'){
            _disable_speech(channel_footer_id)
            _disable_speech(channel_header_id)
        } else if (speech_action == 'renable'){
            _enable_speech(channel_footer_id, 'Deactivate Speech')
            _enable_speech(channel_header_id, 'Deactivate Speech')
        }
    }

// define scroll to end function
    function _scroll_bottom(transcript_text_id){
        var bottom_element = $(transcript_text_id).parent().find('.scroll-bottom')
        if (typeof(bottom_element) != 'undefined'){
            var header_height = $('#header_container').css('height')
            var header_value = parseInt(header_height.slice(0, -2))
            var window_height = $(window).height()
            var scroll_height = $(bottom_element).offset().top - window_height + header_value
            $('html, body').animate({ scrollTop: scroll_height }, 1)
        }
    }
    
// define transcript updating variables
    var previous_interim = ''
    var transcription_text = ''

// define interim transcription update function
    function _update_interim(interim_text){
    
    // determine previous transcription
        transcription_text = $(transcript_text_id).html()
        if (previous_interim){
            var previous_index = transcription_text.length - previous_interim.length
            transcription_text = transcription_text.slice(0, previous_index)
        }
        
    // construct interim text to add
        var interim_trimmed_text = ''
        if (previous_interim){
            interim_trimmed_text = ' '
        }
        if ($.isArray(interim_text)){
            for (var i = 0; i < interim_text.length; i++){
                if (i){ interim_trimmed_text += ' ' }
                interim_trimmed_text += interim_text[i].t
            }
        } else {
            interim_trimmed_text += interim_text
        }
    
    // replace transcription in DOM
        $(transcript_text_id).contents().filter(function(){
            return (this.nodeType == 3);
        }).remove()
        $(transcript_text_id).append(interim_trimmed_text)
        autosize.update($(transcript_text_id))
        _scroll_bottom(transcript_text_id)
        
    // update state and send interim details to server
        previous_interim = deepCopy(interim_trimmed_text)
        socket_client.emit('transcription_interim', { _id: transcript_doc_id, tokens: interim_text })
        
    }

// define final transcription submit function
    function _submit_final(final_text){
    
    // send final transcription to server
        socket_client.emit('transcription_final', { _id: transcript_doc_id, tokens: final_text })
    
    }

// define transcription event handler
    function _update_transcript(server_data){
        
    // ingest server data
        const final_doc_id = ingestString(server_data._id)
        const final_updated = ingestNumber(server_data.dt)
        const final_tokens = ingestMap(server_data.tokens)
        const final_redraw = ingestBoolean(server_data.redraw)
        const final_media = ingestArray(server_data.media)
        
    // determine previous transcription and reset interim value
        transcription_text = $(transcript_text_id).html()
        if (previous_interim){
            var previous_index = transcription_text.length - previous_interim.length
            transcription_text = transcription_text.slice(0, previous_index)
            previous_interim = ''
        }
    
    // save changes to transcript to local storage
        transcripts_db.get(transcript_doc_id).then(function(doc){
            for (var key in final_tokens){
                doc.tokens[key] = final_tokens[key]
                doc.dt = final_updated
            }
            if (!('media' in doc)){ doc['media'] = [] }
            for (var i = 0; i < final_media.length; i++){
                if (doc['media'].indexOf(final_media[i]) == -1){
                    doc['media'].push(final_media[i])
                }
            }
            transcripts_db.put(doc).then(function(){
                transcripts_db.replicate.to(transcripts_remote)
            })
            
        // define variables
            var final_markup = []
        
        // remove text from DOM and construct markup from final text
            if (final_redraw){
                final_markup = markupTranscription(doc.tokens, final_doc_id) 
                $(transcript_text_id).empty()
            } else {
                final_markup = markupTranscription(final_tokens, final_doc_id) 
                $(transcript_text_id).contents().filter(function(){
                    return (this.nodeType == 3);
                }).remove()
            }
            
        // add new words to DOM, update transcript dt and attach meta data
            var prior_token = null
            for (var i = 0; i < final_markup.array.length; i++){
                if (transcription_text || i){
                    $(final_markup.array[i]).appendTo($(transcript_text_id))
                }
                if (transcription_text && i == 0){
                    prior_token = $('<div>' + transcription_text + '</div>').find('> span:last')
                }
            }
            $(transcript_text_id).attr('data-updated', final_updated.toString())
            transcriptListeners(final_markup.selectors, doc['media'], prior_token)
            autosize.update($(transcript_text_id))
            _scroll_bottom(transcript_text_id)
                
        })
        
//        var primary_key = 'created_dt'
//        var query_criteria = { 'created_dt': { equal_to: final_created } }
//        var order_criteria = [{'created_dt': 'descend'}]
//        var max_results = 1
//        var transcript_record = {
//            created_dt: final_created,
//            dt: final_updated,
//            tokens: final_tokens
//        }
//        if (final_redraw){
//            var timestamp_details = {}
//            timestamp_details[final_created] = final_updated
//            saveItems(record_key, primary_key, [transcript_record], timestamp_details, overwrite=false)
//        } else {
//            loadItems(record_key, [final_created], function(storage_records){
//                var storage_tokens = []
//                if (storage_records.length){
//                    storage_tokens = storage_records[0].tokens
//                }
//                storage_tokens.push(final_tokens)
//                transcript_record['tokens'] = storage_tokens
//                var timestamp_details = {}
//                timestamp_details[final_created] = final_updated
//                saveItems(record_key, primary_key, [transcript_record], timestamp_details, overwrite=false)
//            })
//        }
        
    }

// turn on transcription
    if (transcript_action == 'enable'){
    
        transcripts_db.replicate.to(transcripts_remote).then(function(){
        
            window.socket_channels.push('transcription')
            socket_client.emit('channels', { media: window.socket_channels })
            socket_client.emit('transcription_start', { '_id': transcript_doc_id }, function(status){
                
                if (status == 200){
                    socket_client.on('transcription', _update_transcript, 200)
                    startSpeechTranscription(_submit_final, _update_interim, 'timestamp', filter_callable=null, function(error_message){
                        if (error_message == 'not-allowed'){
                            $(button_selectors.mic_box_selector).removeClass('burst-effect')
                            $(button_selectors.mic_selector).removeClass('icon-attention')
                            $(button_selectors.text_selector).removeClass('transcript-active')
                            // $(button_selectors.time_selector).removeClass('elapsed-time')
                            if ('client_listeners' in window){
                                if (transcript_doc_id in window.client_listeners){
                                    clearInterval(window.client_listeners[transcript_doc_id])
                                    delete window.client_listeners[transcript_doc_id]
                                }
                            }
                            toggleTranscription(socket_client, '', transcript_doc_id, button_selectors)
                            alert('Audio Transcription requires Access to Microphone.')
                        }
                    })
                } else {
                    // handle error from transcript start process
                }
                
            })
        
        })
        
        
// switch transcription
    } else if (transcript_action == 'switch'){
    
        transcripts_db.replicate.to(transcripts_remote).then(function(){
            socket_client.emit('transcription_start', { '_id': transcript_doc_id }, function(status){
                if (status == 200){
                    window.speech_transcription_properties.final_callback = _submit_final
                    window.speech_transcription_properties.interim_callback = _update_interim
                    socket_client.removeAllListeners('transcription')
                    socket_client.on('transcription', _update_transcript, 200)
                } else {
                    // handle error from transcript start process
                }
            })
            
        })
        
// turn off transcription
    } else {
    
        stopSpeechTranscription()
        window.socket_channels.splice(transcript_index, 1)
        socket_client.emit('channels', { media: window.socket_channels })
        socket_client.removeAllListeners('transcription')
        transcripts_db.replicate.to(transcripts_remote)
    
    }
    
}

function updateTranscript(record_key, server_data) {

// TODO a method to handle user inline editing of the transcript

// import MediumEditor from 'medium-editor'

// TODO use custom extensions and button in medium editor to create a story editor interface

// https://github.com/yabwe/medium-editor/blob/master/src/js/extensions/README.md#extension
// https://github.com/yabwe/medium-editor/blob/master/src/js/extensions/README.md#handleclickevent-function

// ingest variables
    const main_body_selector = '#' + record_key + '_content_column_main_body'
    const transcript_created = ingestNumber(server_data.created_dt)
    const transcript_updated = ingestNumber(server_data.dt)
    const transcript_title = ingestString(server_data.title)
    const transcript_tokens = ingestString(server_data.tokens)
    const transcript_markup = markupTranscription(transcript_tokens, transcript_created)
    const transcript_media = ingestArray(server_data.media)

// find appropriate record
    $(main_body_selector).children().each(function(){
        var record_text_element = $(this).find('.form-input-contenteditable')
        var record_input_element = $(this).find('input')
        var record_date_created = parseFloat(record_text_element.attr('data-created'))
        var record_date_updated = parseFloat(record_text_element.attr('data-updated'))
        if (record_date_created == transcript_created){
    
    // update record dt
            record_text_element.attr('data-updated', transcript_updated)
    
    // 
            if (record_date_updated != transcript_updated){
                record_text_element.html(transcript_markup.html)
                transcriptListeners(transcript_markup.selectors, transcript_media)
                record_input_element.val(transcript_title)
            }
        }
    })

}

function transcriptionView(socket_client, transcript_list, service_map, token_map) {
    
    /* a method to construct a view for audio transcription */

// define variables
    var record_key = 'audio_transcripts'
    var container_selector = '#' + record_key + '_content_container'
    var index_selector = '#' + record_key + '_index_entries'
    var create_new_selector = '#' + record_key + '_index_create_button'
    var start_transcription_selector = '#' + record_key + '_index_start_button'
    var main_body_selector = '#' + record_key + '_content_column_main_body'
    var alert_box_selector = '#' + record_key + '_content_alert_box'
    var alert_list_selector = '#' + record_key + '_content_alert_list'
    var tokens_db = window.pouch_db.oauth2_tokens
    var tokens_remote = window.pouch_db.oauth2_tokens_remote
    var transcripts_db = window.pouch_db.audio_transcripts
    var transcripts_remote = window.pouch_db.audio_transcripts_remote
    var sources_db = window.pouch_db.source_materials
    var sources_remote = window.pouch_db.source_materials_remote
    var media_db = window.pouch_db.source_media
    var media_remote = window.pouch_db.source_media_remote
    var token_renewals = []
    var gateway_auth = loadRecord('gateway_auth')
    var user_id = gateway_auth.uid
    
// toggle transcriptions container
    var container_html = sprintf('<div id="%s_content_container" class="container content-container-scroll"></div>', record_key)
    toggleView(container_selector, container_html)
    
// define time html constructor
    function _construct_time(time_value) {
    
    // compute human time fields
        var time_remainder = Math.floor(time_value)
        const time_hours = Math.floor(time_remainder / 3600)
        time_remainder = time_value % 3600
        const time_minutes = Math.floor(time_remainder / 60)
        const time_seconds = Math.floor(time_remainder % 60)
    
    // construct time html
        var time_html = time_seconds.toString() + '<span class="font-faded">s</span>'
        if (time_seconds < 10){
            time_html = '0' + time_html
        }
        time_html = time_minutes.toString() + '<span class="font-faded">m</span>' + time_html
        if (time_minutes < 10 && time_hours){
            time_html = '0' + time_html
        }
        if (time_hours){
            time_html = time_hours.toString() + '<span class="font-faded">h</span>' + time_html
        }
    
        return time_html
        
    }

// define calculate time function
    function _update_time(transcript_doc_id, time_selector, view_selectors=null, update_record=true){
    
    // construct new promise
        var _deferred = new $.Deferred()
        
    // retrieve time from selector and calculate delta
        const time_start = parseFloat($(time_selector).attr('data-start'))
        const time_end = $.now() / 1000
        const time_delta = ($.now() / 1000) - time_start
    
    // add delta time to record and update record and DOM
        transcripts_db.get(transcript_doc_id).then(function(doc){
            const elapsed_time = ingestNumber(doc.elapsed_time) + time_delta
            doc.elapsed_time = elapsed_time
            if (update_record){
                transcripts_db.put(doc).then(function(){
                    _deferred.resolve()
                })
            } else {
                _deferred.resolve()
            }
            const elapsed_time_html = _construct_time(elapsed_time)
            $(time_selector).html(elapsed_time_html)
            if (ingestArray(view_selectors).length){
                for (var i = 0; i < view_selectors.length; i++){
                    $(view_selectors[i]).html(elapsed_time_html)
                }
            }
            
        })
        
        return _deferred.promise()
        
    }

// define transcription toggler
    function _toggle_transcription(text_selector, mic_box_selector, mic_selector, time_selector, transcript_doc_id){
    
        if (!('client_listeners' in window)){
            window.client_listeners = {}
        }
        var button_selectors = {
            mic_box_selector: mic_box_selector,
            mic_selector: mic_selector,
            text_selector: text_selector,
            time_selector: time_selector
        }
        var transcript_active = true
        var transcript_classes = $(text_selector).attr('class')
        if (transcript_classes.indexOf('transcript-active') == -1){
            transcript_active = false                                    
        }
        const mic_overlay_selector = '#dialog_live'
        const mic_overlay_box_selector = '#dialog_live_box'
        const mic_overlay_time_selector = '#dialog_live_box_time'
        
        if (transcript_active){
        
        // hide and deactivate mic visibility listener
            if ('transcript_mic_overlay' in window.client_listeners){
                clearInterval(window.client_listeners['transcript_mic_overlay'])
            }
            $(mic_overlay_selector).hide()
            $(mic_overlay_selector).empty()
            
        // remove animations and deactivate text
            $(mic_box_selector).removeClass('burst-effect')
            $(mic_selector).removeClass('icon-attention')
            $(text_selector).removeClass('transcript-active')
            // $(time_selector).removeClass('elapsed-time')
        
        // update time in records and clear counter
            _update_time(transcript_doc_id, time_selector).done(function(){
                clearInterval(window.client_listeners[transcript_doc_id])
                delete window.client_listeners[transcript_doc_id]
                
            // TODO enable record editing for transcripts
            
            // disable transcription
                toggleTranscription(socket_client, '', transcript_doc_id, button_selectors)
                
            })
            
        } 
    
        else {
        
        // close down any current transcription
            var old_text_selector = $(main_body_selector).find('.transcript-active')
            var old_mic_box_selector = $(main_body_selector).find('.burst-effect')
            var old_mic_selector = $(main_body_selector).find('.icon-attention')
            if (old_text_selector.length){
                var old_time_selector = old_text_selector.parent().parent().parent().find('.elapsed-time')
                // var old_time_selector = $(main_body_selector).find('.elapsed-time')
                var old_doc_id = old_text_selector.attr('data-doc-id')
                var old_text_created = old_text_selector.attr('data-created')
                old_text_selector.removeClass('transcript-active')
                old_mic_box_selector.removeClass('burst-effect')
                old_mic_selector.removeClass('icon-attention')
                // old_time_selector.removeClass('elapsed-time')
                _update_time(old_doc_id, old_time_selector)
                clearInterval(window.client_listeners[old_doc_id])
                delete window.client_listeners[old_doc_id]
            }
        
        // construct visibility listener html
            var visibility_html = sprintf('\
                <div class="row">\
                    <div class="col-sm-11 col-xs-10"></div>\
                    <div class="col-sm-1 col-xs-2">\
                        <div class="font-xl text-center line-height-1 padding-vertical-20">\
                            <div id="dialog_live_box" class="burst-effect">\
                                <a id="dialog_live_box_icon" class="icon-microphone icon-attention" title="Click to Deactivate Mic"></a>\
                            </div>\
                        </div>\
                    </div>\
                </div>'
            )
            visibility_html = sprintf('\
                <div class="row">\
                    <div class="col-lg-10 col-md-10 col-sm-8 col-xs-6"></div>\
                    <div class="col-lg-2 col-md-2 col-sm-4 col-xs-6">\
                        <div id="dialog_live_box" class="font-md text-right icon-attention padding-vertical-20">\
                            <div id="dialog_live_box_time" class="shadow-white"></div>\
                        </div>\
                    </div>\
                </div>'
            )
            $(mic_overlay_selector).html(visibility_html)
            
        // show and bind visibility listener
            window.client_listeners['transcript_mic_overlay'] = setInterval(function(){
                // https://github.com/moagrius/isOnScreen
                const _mic_visible = $(mic_selector).isOnScreen(function(deltas){ 
                    return deltas.top >= 10 && deltas.bottom >= 50;
                })
                if (_mic_visible){
                    $(mic_overlay_selector).fadeOut(600)
                } else {
                    $(mic_overlay_selector).fadeIn(600)
                }
            }, 500)
            $(mic_overlay_box_selector).off()
            $(mic_overlay_box_selector).on('click', function(){
            
                _toggle_transcription(text_selector, mic_box_selector, mic_selector, time_selector, transcript_doc_id)
                
            })
            
        // add animations and time recording to new transcription
            $(mic_box_selector).addClass('burst-effect')
            $(text_selector).addClass('transcript-active')
            $(mic_selector).addClass('icon-attention')
            // $(time_selector).addClass('elapsed-time')
            $(time_selector).attr('data-start', ($.now() / 1000).toString())
            window.client_listeners[transcript_doc_id] = setInterval(function(){
                _update_time(transcript_doc_id, time_selector, [mic_overlay_time_selector], update_record=false)
            }, 1000)
            
        // TODO disable record editing on transcript
        
        // enable transcription
            toggleTranscription(socket_client, text_selector, transcript_doc_id, button_selectors) 
            
        }
    }

// define alert updater function
    function _update_alerts(service_name, action='add'){
    
    // determine service variables
        const service_logo = service_map[service_name].service_logo
        const service_title = service_map[service_name].service_title
        const service_attr = '[data-service="' + service_name + '"]'
        var source_element = $(alert_list_selector).find(service_attr)

    // add alert
        if (action == 'add'){
        
        // make alert box visible
            if (!$(alert_box_selector).is(':visible')){
                $(alert_box_selector).show()
            }
            
        // determine if service already exists    
            if (!source_element.length){
        
            // construct service html
                var _service_html = sprintf('\
                    <div class="row">\
                        <div class="col-xs-10">\
                            <div class="row form-text margin-bottom-5 auto-height">\
                                <div class="col-lg-1 col-md-1 col-sm-2 col-xs-2" style="padding-left: 12px;">\
                                    <img src="%s" class="icon-sm float-top">\
                                </div>\
                                <div class="col-lg-11 col-md-11 col-sm-10 col-xs-10 padding-left-0">\
                                    <span id="%s_%s_alert_text" class="text-wrap">%s <sup class="bold">(expired)</sup></span>\
                                </div>\
                            </div>\
                        </div>\
                        <div class="col-xs-2 text-right">\
                            <span data-service="%s" class="icon-refresh icon-hyperlink form-text"></span>\
                        </div>\
                     </div>',
                     service_logo, record_key, service_name,
                     service_title, service_name
                )
            
            // inject service html into DOM
                $(_service_html).appendTo($(alert_list_selector))
            
            // add listener to service
                $(alert_list_selector).find(service_attr).click(function(){
                
                // define text selector
                    var _source_element = $(alert_list_selector).find(service_attr)
                    const _text_selector = sprintf('#%s_%s_alert_text', record_key, service_name)
                     
                // determine service scopes for service from experiment
                    var service_scopes = service_map[service_name].scopes
                    var service_permissions = service_map[service_name].description
//                    var service_scopes = []
//                    var service_permissions = []
//                    for (var i = 0; i < experiment_details.integrations.length; i++){
//                        if (experiment_details.integrations[i].name == service_name){
//                            service_scopes = experiment_details.integrations[i].scopes
//                            service_permissions.push(experiment_details.integrations[i].description)
//                        }
//                    }
                    
                // retrieve oauth2 token
                    var retrieving_token = retrievingOAuthToken(service_name, service_scopes, service_permissions, reprompt=true)
                    retrieving_token.done(function(token_details){
                
                    // remove alert
                        _update_alerts(service_name, action='remove')
                    
                    })
                    retrieving_token.fail(function(msg){
                    
                    // show error
                        const _error_kwargs = {
                            anchor_selector: _text_selector,
                            message_text: msg,
                            message_status: 'error',
                            timeout: 5000
                        }
                        showMessage(_error_kwargs)
                        
                    })
                
                })
                
            }
              
        }
        
    // remove alert
        else if (action == 'remove'){
        
        // determine if service already exists
            if (source_element.length){
                $(source_element).parent().parent().remove()
            }
        
        // hide permissions if alert list is empty
            if (!$.trim($(alert_list_selector).html())){
                $(alert_box_selector).hide()
            }
            
        }
        
    }

// define transcript source html constructor
    function _construct_transcript_source(source_details){
    
    // determine function variables
        const source_title = source_details.source_title
        const source_service = source_details.service_name
        const source_uri = source_details.source_uri
        const source_logo = service_map[source_service]['service_logo']
    
    // construct source html
        var source_html = sprintf('\
            <div class="row">\
                <div class="col-xs-10">\
                    <div class="row form-text margin-bottom-5 auto-height">\
                        <div class="col-lg-1 col-md-1 col-sm-2 col-xs-2" style="padding-left: 12px;">\
                            <img src="%s" class="icon-sm float-top">\
                        </div>\
                        <div class="col-lg-11 col-md-11 col-sm-10 col-xs-10 padding-left-0">\
                            <span class="text-wrap">%s</span>\
                        </div>\
                    </div>\
                </div>\
                <div class="col-xs-2 text-right">\
                    <span data-service="%s" data-uri="%s" class="icon-close icon-hyperlink form-text"></span>\
                </div>\
             </div>',
             source_logo, source_title, source_service, source_uri
        )
        
        return source_html
    
    }

// define transcript source delete function
    function _delete_transcript_source(source_selector, source_details, transcript_doc_id){
    
    // remove source from transcript
        transcripts_db.get(transcript_doc_id).then(function(doc){
            for (var i = 0; i < doc.sources.length; i++){
                const _source_uri = ingestString(doc.sources[i].source_uri)
                const _service_name = ingestString(doc.sources[i].service_name)
                if (_service_name == source_details.service_name && _source_uri == source_details.source_uri){
                    doc.sources.splice(i, 1)
                    transcripts_db.put(doc).then(function(){
                        transcripts_db.replicate.to(transcripts_remote)
                    })
                    break
                }
            }
        })
    
    // remove source from view
        $(source_selector).remove()
        
    }

// define function to update source materials in pouch db
    function _save_source_materials(source_fields, source_details){
    
    // construct new promise
        var _deferred = new $.Deferred()
        
    // search for source materials in pouch db
        sources_db.find({
            selector: {
                service_name: source_fields.service_name,
                source_uri: source_fields.source_uri
            },
            use_index: 'service_name_source_uri'
        }).then(function(results){
        
        // create new document in source materials
            if (!results.docs.length){
                    
                sources_db.post({
                    "service_name": source_fields.service_name,
                    "source_uri": source_fields.source_uri,
                    "source_title": source_fields.source_title,
                    "uid": user_id,
                    "dt": source_fields.dt,
                    "hash": source_fields.hash,
                    "details": source_details
                }).then(function(response){
                    sources_db.replicate.to(sources_remote).then(function(){
                        socket_client.emit('save_source', { _id: response.id })
                        _deferred.resolve('saved')
                    })
                })
        
        // update document in source materials if source has changed
            } else {
            
                var source_doc = results.docs[0]
                if (source_doc.hash != source_fields.hash){
                    source_doc.details = source_details
                    source_doc.hash = source_fields.hash
                    source_doc.dt = source_fields.dt
                    sources_db.put(source_doc).then(function(){
                        sources_db.replicate.to(sources_remote).then(function(){
                            socket_client.emit('save_source', { _id: source_doc._id })
                            _deferred.resolve('updated')
                        })
                    })
                } else {
                    _deferred.resolve('')
                }
            }
            
        })
        
        return _deferred.promise()
        
    }
    
// define function to update source media in pouch db
    function _save_source_media(media_fields, media_metadata, retrieval_function=null){
    
    // construct new promise
        var _deferred = new $.Deferred()
        
    // search for source materials in pouch db
        media_db.find({
            selector: {
                service_name: media_fields.service_name,
                source_uri: media_fields.source_uri,
                object_id: media_fields.object_id 
            },
            use_index: 'service_name_source_uri_object_id'
        }).then(function(results){
            
        // create new document in source materials
            if (!results.docs.length){
                
                if (retrieval_function){
                
                    retrieval_function().done(function(data){
                    
                        media_db.post({
                            "service_name": media_fields.service_name,
                            "source_uri": media_fields.source_uri,
                            "object_id": media_fields.object_id,
                            "dt": media_fields.dt,
                            "uid": user_id,
                            "hash": media_fields.hash,
                            "data": data
                        }).then(function(response){
                            media_db.replicate.to(media_remote).then(function(){
                                socket_client.emit('save_media', {
                                    _id: response.id,
                                    _rev: response.rev,
                                    bucket: 'source_media'
                                })
                                _deferred.resolve('saved')
                            }).catch(function(){
                                _deferred.reject()
                            })
                        })
                    
                    }).fail(function(){
                        _deferred.reject()
                    })
                    
                } else {
                
                    media_db.post({
                        "service_name": media_fields.service_name,
                        "source_uri": media_fields.source_uri,
                        "object_id": media_fields.object_id,
                        "dt": media_fields.dt,
                        "uid": user_id,
                        "hash": media_fields.hash,
                        "data": media_metadata
                    }).then(function(response){
                        media_db.replicate.to(media_remote).then(function(){
                            socket_client.emit('save_media', {
                                _id: response.id,
                                _rev: response.rev,
                                bucket: 'source_media'
                            })
                            _deferred.resolve('saved')
                        }).catch(function(){
                            _deferred.reject()
                        })
                    })
                        
                }
        
        // update document in source materials if source has changed
            } else {
            
                var media_doc = results.docs[0]
                if (media_doc.hash != media_fields.hash){
                    if (retrieval_function){
                        retrieval_function().done(function(data){
                            media_doc.data = data
                            media_doc.hash = media_fields.hash
                            media_doc.dt = media_fields.dt
                            media_db.put(media_doc).then(function(response){
                                media_db.replicate.to(media_remote).then(function(){
                                    socket_client.emit('save_media', {
                                        _id: response.id,
                                        _rev: response.rev,
                                        bucket: 'source_media'
                                    })
                                    _deferred.resolve('updated')
                                }).catch(function(){
                                    _deferred.reject()
                                })
                            })
                        }).fail(function(){
                            _deferred.reject()
                        })
                        
                    } else {
                        
                        media_doc.data = data
                        media_doc.hash = media_fields.hash
                        media_doc.dt = media_fields.dt
                        media_db.put(media_doc).then(function(response){
                            media_db.replicate.to(media_remote).then(function(){
                                socket_client.emit('save_media', {
                                    _id: response.id,
                                    _rev: response.rev,
                                    bucket: 'source_media'
                                })
                                _deferred.resolve('updated')
                            }).catch(function(){
                                _deferred.reject()
                            })
                        })
                        
                    }
                    
                } else {
                    _deferred.resolve('')
                }
                
            }
            
        })
        
        return _deferred.promise()
          
    }
    
// define function to save presentations from google slides
    function _save_google_slides(source_uri, source_fields, access_token){

    // construct new promise
        var deferred = new $.Deferred()
        
    // load google slides presentation 
        gapi.auth.setToken({ access_token: access_token })
        gapi.client.slides.presentations.get({
            presentationId: source_uri
        }).then(function(response) {
        
        // remove extraneous fields
            delete response.result.layouts
            delete response.result.masters
            delete response.result.notesMaster
            
        // construct source fields
            var source_fields_copy = deepCopy(source_fields)
            const source_string = JSON.stringify(response.result)
            const corrected_source = source_string.replace(/"https.*?googleusercontent.*?"/g, '""')
            source_fields_copy.hash = sha256(corrected_source)
            const _source_fields = deepCopy(source_fields_copy)
        
        // save presentation details to pouch db sources bucket
            _save_source_materials(_source_fields, response.result).done(function(msg){
                
                deferred.resolve()
                
            // save slides to pouch db media bucket
                if (msg == 'saved' || msg == 'updated'){
                    
                    logConsole(_source_fields.source_uri + ' ' + msg)
                    
                    const slide_list = response.result.slides
                    for (var i = 0; i < slide_list.length; i++){
                    
                    // construct media fields
                        var media_fields = deepCopy(source_fields)
                        media_fields.object_id = slide_list[i].objectId
                        const media_string = JSON.stringify(slide_list[i])
                        const corrected_media = media_string.replace(/"https.*?googleusercontent.*?"/g, '""')
                        media_fields.hash = sha256(corrected_media)
                        const _media_fields = deepCopy(media_fields)
                        
                    // define slide retrieval function
                        function _retrieve_slide(){
                            
                            var _deferred = new $.Deferred()
                            
                            gapi.auth.setToken({ access_token: access_token })
                            gapi.client.slides.presentations.pages.getThumbnail({
                                presentationId: source_uri,
                                pageObjectId: _media_fields.object_id,
                                thumbnailProperties: {
                                    mimeType: 'PNG',
                                    thumbnailSize: 'LARGE'
                                }
                            }).then(function(media_response){
                                const slide_url = media_response.result.contentUrl
                                getFile(slide_url).done(function(slide_data){
                                    _deferred.resolve(slide_data)
                                }).fail(function(){
                                    _deferred.reject()
                                })
                            }).catch(function(err){
                                logConsole(err)
                            })
                            
                            return _deferred.promise()
                            
                        }
                    
                    // save to source media (if changed)
                        _save_source_media(_media_fields, slide_list[i], _retrieve_slide).done(function(msg){
                            if (msg){
                                logConsole(_media_fields.object_id + ' ' + msg)
                            }
                        })
                        
                    }
                    
                }
                
            }).fail(function(err){
                deferred.reject(err)
            })
            
        }).catch(function(err){
            deferred.reject(err)
        })
        
        return deferred.promise()
                        
    }

// define function to save spreadsheets from google sheets
    function _save_google_sheets(source_uri, source_fields, access_token){
    
    // construct new promise
        var deferred = new $.Deferred()
        
    // load google sheets 
        gapi.auth.setToken({ access_token: service_token })
        gapi.client.sheets.spreadsheets.get({
            spreadsheetId: source_uri
        }).then(function(response) {
            
         // construct source fields
            var source_fields_copy = deepCopy(source_fields)
            const source_string = JSON.stringify(response.result)
            const corrected_source = source_string.replace(/"https.*?googleusercontent.*?"/g, '""')
            source_fields_copy.hash = sha256(corrected_source)
            const _source_fields = deepCopy(source_fields_copy)
         
         // save spreadsheet as document to pouch db
            _save_source_materials(_source_fields, response.result).done(function(msg){
                deferred.resolve()
                if (msg == 'saved' || msg == 'updated'){   
                    logConsole(_source_fields.source_uri + ' ' + msg)
                }
            }).fail(function(err){
                deferred.reject(err)
            })
            
        }).catch(function(err){
            deferred.reject(err)        
        })
        
        return deferred.promise()
    
    }
      
// define service source list constructor
    function _construct_service_sources(service_selector, sources_selector, access_token, service_name, transcript_doc_id){
    
    // define service source html constructor
        function _construct_service_source(service_logo, source_title, empty_result=false){
            
            var _font_faded = ''
            if (empty_result){ _font_faded=' class="font-placeholder"'}
            const _source_html = sprintf('\
                <li>\
                    <a title="%s"%s>\
                        <div class="container-fluid">\
                            <div class="row">\
                                <div class="col-xs-2">\
                                    <img src="%s" class="icon-sm float-top">\
                                </div>\
                                <div class="col-xs-10 padding-left-0">\
                                    <span class="text-wrap">%s</span>\
                                </div>\
                            </div>\
                        </div>\
                    </a>\
                </li>',
                source_title, _font_faded, service_logo, source_title
            )
            
            return _source_html
            
        }
    
    // define service source assignment function
        function _click_service_source(sources_selector, source_details){
        
        // check for duplication of existing sources
            const source_uri = source_details.source_uri
            var found_uri = false
            $(sources_selector).find('span[data-uri]').each(function(i, span){
                const _source_uri = $(span).attr('data-uri')
                const _service_name = $(span).attr('data-service')
                if (_service_name == service_name){
                    if (!_source_uri || _source_uri == source_uri){
                        found_uri = true
                    }  
                }               
            })
        
        //  if source does not exist, inject html into DOM and add listener
            if (!found_uri || !source_uri){
                const source_html = _construct_transcript_source(source_details)
                $(source_html).appendTo($(sources_selector))
                const source_element = $(sources_selector).find('> div').last()
                $(source_element).find('.icon-hyperlink').click(function(){
                    _delete_transcript_source(source_element, source_details, transcript_doc_id)
                })
                
            // define function to update transcript
                function _save_transcript_source(_source_fields){
                
                // add source to transcript in pouch db
                    transcripts_db.get(transcript_doc_id).then(function(doc){
                        if (!('sources' in doc)){
                            doc['sources'] = []
                        }
                        doc.sources.push(_source_fields)
                        
                    // remove previous source if all
                        if (!source_uri){
                            var new_source_list = []
                            for (var i = 0; i < doc.sources.length; i++){
                                if (!doc.sources[i].service_name == service_name || !doc.sources[i].source_uri){
                                    new_source_list.push(doc.sources[i])
                                }
                            }
                            doc.sources = new_source_list
                        }
                    
                    // update document
                        transcripts_db.put(doc).then(function(){
                            transcripts_db.replicate.to(transcripts_remote)
                        })
       
                    })
                
                }
             
            // retrieve source document
                tokens_db.find({
                    selector: { service_name: service_name },
                    use_index: 'service_name'
                }).then(function(results){
                
                // construct source variables
                    const service_token = results.docs[0].access_token
                    var source_details_copy = deepCopy(source_details)
                    source_details_copy.dt = $.now() / 1000
                    const source_fields = deepCopy(source_details_copy)
                    
                // retrieve source materials from google slides
                    if (service_name == 'google_slides'){
                        
                        loadingLibrary('google', 'slides').then(function(){
                            _save_google_slides(source_uri, source_fields, service_token).then(function(){
                                _save_transcript_source(source_fields)
                            })
                        })
                        
                // retrieve source materials from google sheets
                    } else if (service_name == 'google_sheets'){
                    
                        loadingLibrary('google', 'sheets').then(function(){
                            _save_google_slides(source_uri, source_fields, service_token).then(function(){
                                _save_transcript_source(source_fields)
                            })
                        })
                
                // retrieve source materials from other services
                    } else {
                    
                        _save_transcript_source(source_fields)
                        
                    }
                    
                })
       
            }
        
        // remove sources covered by the all option
            if (!source_uri){
                $(sources_selector).find('span[data-uri]').each(function(i, span){
                    const _source_uri = $(span).attr('data-uri')
                    const _service_name = $(span).attr('data-service')
                    if (_source_uri && _service_name == service_name){
                        $(span).parent().parent().remove() 
                    }
                })
            }
 
        }
    
    // determine service source element object
        var service_element = $(service_selector).parent()
        var sources_element = $(service_selector).parent().find('ul')
        var service_logo = service_map[service_name]['service_logo']
        var service_title = service_map[service_name]['service_title']
        var service_siblings = $(service_selector).parent().parent().find('li')
        const source_page_selector = '#' + service_name + '_source_paginator' 
    
    // define menu injection function
        function _inject_sources(source_list, retrieving_func=null, page_size=0){
        
        // make sure dropdown is open
            if (service_element.attr('class').indexOf('open') == -1){
                service_element.addClass('open')
            }
            
        // empty any previous lists
            service_siblings.each(function(i, li){
                var sibling_class = $(li).find('a').attr('data-service')
                if (sibling_class != service_name){
                    $(li).find('ul').empty().hide()
                } else {
                    $(li).find('ul').empty().show()
                }
            })
                
        // inject projects into DOM and add listener
            if (source_list.length){
                for (var i = 0; i < source_list.length; i++){
                    const source_details = source_list[i]
                    const source_html = _construct_service_source(service_logo, source_details.source_title)
                    $(source_html).appendTo(sources_element)
                    const source_element = sources_element.find('> li').last()
                    $(source_element).click(function(){
                        _click_service_source(sources_selector, source_details)
                    })
                // add divider for all sources in service option
                    if (!source_details.source_uri){
                        const divider_html = '<li class="divider"></li>'
                        $(divider_html).appendTo(sources_element)
                    }
                }
                const paginator_html = sprintf('<li id="%s_source_paginator" class="invisible">Paginator</li>', service_name)
                $(paginator_html).appendTo(sources_element)
                
        // handle no files 
            } else {
                const empty_title = '{ ' + service_title + ' empty }'
                const source_html = _contruct_service_source(service_logo, empty_title, empty_result=true)
                $(source_html).appendTo(sources_element)
            }
        
        // define pagination renderer
            function _render_sources(_source_list, end_page){
                
                var _deferred = new $.Deferred()
                
                $(source_page_selector).remove()
                for (var i = 0; i < _source_list.length; i++){
                    const _source_details = _source_list[i]
                    const _source_html = _construct_service_source(service_logo, _source_details.source_title)
                    $(_source_html).appendTo(sources_element)
                    const _source_element = sources_element.find('> li').last()
                    $(_source_element).click(function(){
                        _click_service_source(sources_selector, _source_details)
                    })
                }
                const paginator_html = sprintf('<li id="%s_source_paginator" class="invisible">Paginator</li>', service_name)
                $(paginator_html).appendTo(sources_element)
                _deferred.resolve()
                
                return _deferred.promise()
                
            }
                
        // add pagination listener
            if (retrieving_func){
                paginateView(source_page_selector, source_list, retrieving_func, _render_sources, page_size)
            }
               
        }
        
    // retrieve list of sources from service api and construct menu
        if (service_name == 'google_slides' || service_name == 'google_sheets'){
        
        // retrieve google drive token
            const drive_map = service_map['google_drive'] 
            var drive_promise = retrievingOAuthToken('google_drive', drive_map.scopes, drive_map.description)
            drive_promise.fail(function(msg){
                const _error_kwargs = {
                    anchor_selector: button_selector,
                    message_text: msg,
                    message_status: 'error',
                    timeout: 5000
                }
                showMessage(_error_kwargs)
            })
            drive_promise.done(function(token_details){
            
            // update alert icons
                _update_alerts(token_details.service_name, action='remove')
                
            // construct projects list
                const access_token = token_details.access_token
            
            // set token and determine list options
                gapi.auth.setToken({ access_token: access_token })
                var list_options = {
                    q: "mimeType='application/vnd.google-apps.presentation'",
                    orderBy: 'modifiedTime desc',
                    fields: 'nextPageToken, files(id, name)',
                    pageSize: 10
                }
                if (service_name == 'google_sheets'){
                    list_options['q'] = "mimeType='application/vnd.google-apps.spreadsheet'"   
                }
            
            // send request for files in google drive
                gapi.client.drive.files.list(list_options).then(function(response){
                    
                // ingest results
                    var file_list = ingestArray(response.result.files)
                    var source_list = []
//                // add an all slides/sheets option
//                    source_list.push({
//                        source_title: 'All ' + service_map[service_name].service_title,
//                        source_uri: '',
//                        service_name: service_name
//                    })
                    for (var i = 0; i < file_list.length; i++){
                        const file_details = file_list[i]
                        logConsole(file_details.name)
                        const source_details = {
                            source_title: file_details.name,
                            source_uri: file_details.id,
                            service_name: service_name,
                            page_token: ingestString(response.result.nextPageToken)
                        }
                        source_list.push(source_details)
                    }
                
                // define google pagination retriever
                    function _retrieve_google_sources(previous_record){
                    
                        var _deferred = new $.Deferred()
                        
                        var _page_token = previous_record.page_token
                        
                        if (!_page_token){
                            _deferred.resolve([])
                        } else {
                            var _list_options = {
                                pageToken: _page_token,
                                q: "mimeType='application/vnd.google-apps.presentation'",
                                fields: 'nextPageToken, files(id, name)',
                                pageSize: 10
                            }
                            if (service_name == 'google_sheets'){
                                _list_options['q'] = "mimeType='application/vnd.google-apps.spreadsheet'"   
                            }
                            gapi.auth.setToken({ access_token: access_token })
                            gapi.client.drive.files.list(_list_options).then(function(_response){
                                    
                            // ingest results
                                var _file_list = _response.result.files
                                var _source_list = []
                                for (var i = 0; i < _file_list.length; i++){
                                    const _file_details = _file_list[i]
                                    logConsole(file_details.name)
                                    const _source_details = {
                                        source_title: _file_details.name,
                                        source_uri: _file_details.id,
                                        service_name: service_name,
                                        page_token: _response.result.nextPageToken
                                    }
                                    _source_list.push(_source_details)
                                }
                                _deferred.resolve(_source_list)
                                
                            }).catch(function(err){
                                logConsole(err)
                                _deferred.resolve([])
                            })
                            
                        }
    
                        return _deferred.promise()
                        
                    }
                
                // inject sources   
                    _inject_sources(source_list, _retrieve_google_sources, 10)
                    
                }).catch(function(err){
                    logConsole(err)
                    _deferred.resolve([])
                })    
                
            })
        
        }
         
    // TODO retrieve list of sources from other services
        else {

            var source_list = []
            for (var i = 0; i < 3; i++){
                const source_details = {
                    service_name: service_name,
                    source_title: 'My ' + service_title + ' Project ' + i.toString(),
                    source_uri: 'My ' + service_title + ' Project ' + i.toString() + ' URI'
                }
                source_list.push(source_details)
            }
            _inject_sources(source_list)
        
        }
        
    }
         
// define service connector
    function _connect_service(service_selector, sources_selector, button_selector, transcript_doc_id){
        
    // determine service scopes for service from experiment
        var service_name = $(service_selector).attr('data-service')
        var service_scopes = service_map[service_name].scopes
        var service_permissions = service_map[service_name].description
//        var service_scopes = []
//        var service_permissions = []
//        for (var i = 0; i < experiment_details.integrations.length; i++){
//            if (experiment_details.integrations[i].name == service_name){
//                service_scopes = experiment_details.integrations[i].scopes
//                service_permissions.push(experiment_details.integrations[i].description)
//            }
//        }
        
    // retrieve oauth2 token
        var retrieving_token = retrievingOAuthToken(service_name, service_scopes, service_permissions)
        retrieving_token.done(function(token_details){
        
        // update alert icons
            _update_alerts(token_details.service_name, action='remove')
            
        // construct projects list
            const access_token = token_details.access_token
            _construct_service_sources(service_selector, sources_selector, access_token, service_name, transcript_doc_id)
            
        })
    
    // handle errors
        retrieving_token.fail(function(msg){
            const _error_kwargs = {
                anchor_selector: button_selector,
                message_text: msg,
                message_status: 'error',
                timeout: 5000
            }
            showMessage(_error_kwargs)
        })
        
    }
       
// define transcript constructor
    function _construct_transcript(transcript_fields, prepend=false){
        
    // determine record variables
        const transcript_doc_id = ingestString(transcript_fields._id)
        const transcript_created = ingestNumber(transcript_fields.created_dt)
        const transcript_updated = ingestNumber(transcript_fields.dt)
        const transcript_title = ingestString(transcript_fields.title)
        const transcript_time = ingestNumber(transcript_fields.elapsed_time)
        const transcript_tokens = ingestMap(transcript_fields.tokens)
        const transcript_media = ingestArray(transcript_fields.media)
        const transcript_sources = ingestArray(transcript_fields.sources)
    
    // determine local date string
        const transcript_date = renderEpoch(transcript_created)
        
    // determine DOM variables
        const transcript_prefix = record_key + '_' + transcript_doc_id
        const transcript_section_selector = '#' + transcript_prefix + '_section'
        const transcript_title_selector = '#' + transcript_prefix + '_title'
        const transcript_created_selector = '#' + transcript_prefix + '_created'
        const transcript_time_selector = '#' + transcript_prefix + '_time'
        const transcript_text_selector = '#' + transcript_prefix + '_text'
        const transcript_delete_selector = '#' + transcript_prefix + '_delete'
        const transcript_mic_selector = '#' + transcript_prefix + '_mic'
        const transcript_mic_box_selector = transcript_mic_selector + '_box'
        const transcript_index_prefix = record_key + '_index_' + transcript_doc_id
        const transcript_index_selector = '#' + transcript_index_prefix + '_link'
        const transcript_sources_selector = '#' + transcript_prefix + '_sources'
        const transcript_services_selector = '#' + transcript_prefix + '_source_services'
        const transcript_button_selector = '#' + transcript_prefix + '_source_button'
    
    // construct time html
        const time_html = _construct_time(transcript_time)
        
    //  construct transcript html
        var transcript_html = sprintf('\
            <div id="%s_section" class="section-responsive">\
                <div class="row form-line">\
                    <div class="col-lg-3 col-md-3 col-sm-3 hidden-xs">&nbsp;</div>\
                    <div class="col-lg-9 col-md-9 col-sm-9 col-xs-12">\
                        <div class="row">\
                            <div class="col-xs-2">\
                                <div class="float-left">\
                                    <div id="%s_mic_box">\
                                        <span id="%s_mic" class="icon-microphone form-text icon-hyperlink text-center"></span>\
                                    </div>\
                                </div>\
                            </div>\
                            <div class="col-xs-4">&nbsp;</div>\
                            <div class="col-xs-2 text-right">\
                                <span class="icon-drawer icon-hyperlink hidden-link font-placeholder form-text"></span>\
                            </div>\
                            <div class="col-xs-2 text-right">\
                                <span class="icon-share-alt icon-hyperlink hidden-link font-placeholder form-text"></span>\
                            </div>\
                            <div class="col-xs-2 text-right">\
                                <span id="%s_delete" class="icon-close icon-hyperlink form-text"></span>\
                            </div>\
                        </div>\
                    </div>\
                </div>\
                <div class="row form-line auto-height">\
                    <div class="col-lg-3 col-md-3 col-sm-3 hidden-xs">\
                        <div class="form-text auto-height">Sources:</div>\
                    </div>\
                    <div class="hidden-lg hidden-md hidden-sm col-xs-12">\
                        <div class="form-label bold">Sources:</div>\
                    </div>\
                    <div class="col-lg-9 col-md-9 col-sm-9 col-xs-12 auto-height">\
                        <div id="%s_sources" class="sources-div-class"></div>\
                        <div class="dropdown">\
                            <a id="%s_source_button" class="form-text dropdown-toggle" data-toggle="dropdown">\
                                <div class="row">\
                                    <div class="col-xs-10">\
                                        <div class="row form-text margin-bottom-5 auto-height">\
                                            <div class="col-lg-1 col-md-1 col-sm-2 col-xs-2">\
                                                <span class="icon-plus"></span>\
                                            </div>\
                                            <div class="col-lg-11 col-md-11 col-sm-10 col-xs-10 padding-left-0">\
                                                <span class="text-wrap">Add Source</span>\
                                            </div>\
                                        </div>\
                                    </div>\
                                    <div class="col-xs-2 text-right">\
                                    </div>\
                                 </div>\
                            </a>\
                            <ul id="%s_source_services" class="dropdown-menu">\
                            </ul>\
                        </div>\
                    </div>\
                </div>\
                <div class="row form-line">\
                    <div class="col-lg-3 col-md-3 col-sm-3 hidden-xs">\
                        <div class="form-text auto-height">Created:</div>\
                    </div>\
                    <div class="hidden-lg hidden-md hidden-sm col-xs-12">\
                        <div class="form-label bold">Created:</div>\
                    </div>\
                    <div class="col-lg-9 col-md-9 col-sm-9 col-xs-12">\
                        <div id="%s_created" class="form-text">%s</div>\
                    </div>\
                </div>\
                <div class="row form-line">\
                    <div class="col-lg-3 col-md-3 col-sm-3 hidden-xs">\
                        <div class="form-text auto-height">Elapsed Time:</div>\
                    </div>\
                    <div class="hidden-lg hidden-md hidden-sm col-xs-12">\
                        <div class="form-label bold">Elapsed Time:</div>\
                    </div>\
                    <div class="col-lg-9 col-md-9 col-sm-9 col-xs-12">\
                        <div id="%s_time" class="form-text elapsed-time">%s</div>\
                    </div>\
                </div>\
                <div class="row form-line auto-height">\
                    <div class="col-lg-3 col-md-3 col-sm-3 hidden-xs">\
                        <div class="form-text auto-height">Text:</div>\
                    </div>\
                    <div class="hidden-lg hidden-md hidden-sm col-xs-12">\
                        <div class="form-label bold">Text:</div>\
                    </div>\
                    <div class="col-lg-9 col-md-9 col-sm-9 col-xs-12 auto-height">\
                        <div id="%s_text" data-created="%s" data-updated="%s" data-doc-id="%s" class="form-input-contenteditable font-gray"></div>\
                        <div id="%s_bottom" class="scroll-bottom"></div>\
                    </div>\
                </div>\
            </div>',
            transcript_prefix, transcript_prefix,
            transcript_prefix, transcript_prefix,
            // transcript_prefix, transcript_title,
            transcript_prefix, transcript_prefix, transcript_prefix,
            transcript_prefix, transcript_date,
            transcript_prefix, time_html,
            transcript_prefix, transcript_created, transcript_updated, transcript_doc_id,
            transcript_prefix
        )
    
// Title HTML 
//                <div class="row form-line">\
//                    <div class="col-lg-3 col-md-3 col-sm-3 hidden-xs">\
//                        <div class="form-text auto-height">Title:</div>\
//                    </div>\
//                    <div class="hidden-lg hidden-md hidden-sm col-xs-12">\
//                        <div class="form-label bold">Title:</div>\
//                    </div>\
//                    <div class="col-lg-9 col-md-9 col-sm-9 col-xs-12">\
//                        <input id="%s_title" type="text" class="form-input" style="border: none;" placeholder="Add Title Here" value="%s">\
//                    </div>\
//                </div>\
   
    // construct transcript markup
        var transcript_markup = markupTranscription(transcript_tokens, transcript_doc_id)
        var textarea_html = transcript_markup.html
       
    // construct index html
        var index_html = sprintf('\
            <div id="%s" class="form-line">\
                <a href="#" id="%s_link" class="form-text no-wrap" title="Go to %s Transcript">%s</a>\
            </div>',
            transcript_index_prefix, transcript_index_prefix, transcript_date, transcript_date
        )
        
    // define clear empty record function
        function _clear_blank(){
            var top_transcript_element = $(main_body_selector).children(':first')
            var top_index_element = $(index_selector).children(':first')
            var top_transcript_text = top_transcript_element.find('.form-input-contenteditable')
            if (top_index_element.html()){
                var top_transcript_text = top_transcript_element.find('.form-input-contenteditable')
                var top_transcript_sources = top_transcript_element.find('.sources-div-class')
                if (!top_transcript_text.html() && !top_transcript_sources.html()){
                    var top_transcript_doc_id = top_transcript_text.attr('data-doc-id')
                    transcripts_db.get(top_transcript_doc_id).then(function(doc){
                        transcripts_db.remove(doc).then(function(){
                            transcripts_db.replicate.to(transcripts_remote)
                        })
                    })
                    top_transcript_element.remove()
                    top_index_element.remove()
                }
            } 
        }
        
    // inject transcript html into DOM and apply autosize listener
        if (prepend){
            _clear_blank()
            $(main_body_selector).prepend(transcript_html)
            if (textarea_html){
                $(transcript_text_selector).html(textarea_html)
                transcriptListeners(transcript_markup.selectors, transcript_media)
            }
            $(index_selector).prepend(index_html)
        } else {
            $(transcript_html).appendTo($(main_body_selector))
            $(transcript_text_selector).html(textarea_html)
            transcriptListeners(transcript_markup.selectors, transcript_media)
            $(index_html).appendTo($(index_selector))
        }
        autosize($(transcript_text_selector))   
     
    // add sources to transcript
        for (var i = 0; i < transcript_sources.length; i++){
            const source_details = transcript_sources[i]
            const source_html = _construct_transcript_source(source_details)
            $(source_html).appendTo($(transcript_sources_selector))
            const source_element = $(transcript_sources_selector).find('> div').last()
            $(source_element).find('.icon-hyperlink').click(function(){
                _delete_transcript_source(source_element, source_details, transcript_doc_id)
            })
        }
    
    // construct service menu
        const service_list = [ 'google_slides', 'google_sheets', 'pinterest' ]
        for (var i = 0; i < service_list.length; i++){
            const service_name = service_list[i]
            const service_logo = service_map[service_name]['service_logo']
            const service_title = service_map[service_name]['service_title']
            const service_selector = '#' + transcript_prefix + '_' + service_name
            const service_html = sprintf('\
                <li class="dropdown">\
                    <a id="%s_%s" title="%s" class="dropdown-toggle" data-service="%s" data-toggle="dropdown">\
                        <div class="container-fluid">\
                            <div class="row">\
                                <div class="col-xs-2">\
                                    <img src="%s" class="icon-sm float-top">\
                                </div>\
                                <div class="col-xs-10 padding-left-0">\
                                    <span class="text-wrap">%s</span>\
                                </div>\
                            </div>\
                        </div>\
                    </a>\
                    <ul class="dropdown-menu scrollable-menu margin-top-10 margin-left-10" style="display: none;">\
                    </ul>\
                </li>',
                transcript_prefix, service_name, service_title, service_name,
                service_logo, service_title
            )
            $(service_html).appendTo($(transcript_services_selector))
            $(service_selector).click(function(){
                _connect_service(service_selector, transcript_sources_selector, transcript_button_selector, transcript_doc_id)
            })  
        }    
    
    // enable nested dropdown menus
        $('ul.dropdown-menu [data-toggle=dropdown]').on('click', function(event) {
            event.preventDefault()
            event.stopPropagation()
            $(this).parent().addClass('open')
            $(this).parent().find("ul").parent().find("li.dropdown").addClass('open')
        });
        
    // add index link listener
        $(transcript_index_selector).click(function(){
            scrollDiv(transcript_section_selector)
        })
    
    // define button selectors
        var button_selectors = {
            mic_selector: transcript_mic_selector,
            mic_box_selector: transcript_mic_box_selector,
            text_selector: transcript_text_selector,
            time_selector: transcript_time_selector
        }
        
    // add delete link listener
        $(transcript_delete_selector).click(function(){
        
            transcripts_db.get(transcript_doc_id).then(function(doc){
                transcripts_db.remove(doc).then(function(){
                    transcripts_db.replicate.to(transcripts_remote)
                })
            })
            var transcript_text_classes = $(transcript_text_selector).attr('class')
            if (transcript_text_classes.indexOf('transcript-active') > -1){
                toggleTranscription(socket_client, '', transcript_doc_id, button_selectors)
            }
            $(transcript_section_selector).remove()
            $('#' + transcript_index_prefix).remove()
            
        })

    // add title updating listener
//        function _update_title(title_value){
//            var updated_dt = $.now() / 1000
//            transcripts_db.get(transcript_doc_id).then(function(doc){
//                doc['title'] = title_value
//                doc['dt'] = updated_dt
//                transcripts_db.put(doc)
//            })
//            $(transcript_text_selector).attr('data-updated', updated_dt.toString())
//        }
//        inputHandler(transcript_title_selector, 'Transcript Title', {}, _update_title, enter_submit=true, auto_save=true)
        
    // toggle mic listeners
        $(transcript_mic_selector).click(function(){
            _toggle_transcription(transcript_text_selector, transcript_mic_box_selector, transcript_mic_selector, transcript_time_selector, transcript_doc_id)
        })
        
    }

// define renewal list constructor
    function _construct_renewals(_transcript_list, _token_map){
    
        var _renewal_list = []
        
        for (var i = 0; i < _transcript_list.length; i++){
            const transcript_fields = _transcript_list[i]
            const transcript_sources = ingestArray(transcript_fields.sources)
            for (var j = 0; j < transcript_sources.length; j++){
                const service_name = transcript_sources[j].service_name
                if (_renewal_list.indexOf(service_name) == -1){
                    if (!(service_name in _token_map)){
                        _renewal_list.push(service_name)
                    } else if (_token_map[service_name].expires_at && _token_map[service_name].expires_at < ($.now() / 1000 + 600)){
                        _renewal_list.push(service_name)
                    }
                }
            }
        
        // add google drive to renewal list as dependency for google sheets and slides
            if (_renewal_list.indexOf('google_slides') || _renewal_list.indexOf('google_sheets')){
                if (_renewal_list.indexOf('google_drive') == -1){
                    if (!('google_drive' in _token_map)){
                        _renewal_list.push('google_drive')
                    } else if (_token_map['google_drive'].expires_at && _token_map['google_drive'].expires_at < ($.now() / 1000 + 600)){
                        _renewal_list.push('google_drive')
                    }
                }
            }
            
        }
        
        return _renewal_list
        
    }
        
// define token renewal generator (to catch any tokens that will have expired in 10min)
    function _determine_renewals(){
    
    // create new promise
        var _deferred = new $.Deferred()
        
    // retrieve current tokens
        tokens_db.find({
            selector: { service_name: { $gt: null } },
            use_index: 'service_name'
        }).then(function(response){
        
        // compile token map
            var _token_map = {}
            var _token_list = ingestArray(response.docs)
            for (var i = 0; i < _token_list.length; i++){
                const _service_name = _token_list[i].service_name
                _token_map[_service_name] = _token_list[i]
            }
        
        // define promise arrays
            var _promise_array = []
            var _transcript_list = []
            
        // retrieve transcript records
            var _key_list = []
            $(main_body_selector).find('.form-input-contenteditable').each(function(i, text){
                _key_list.push($(text).attr('data-doc-id'))
            })
            transcripts_db.allDocs({ 
                keys: _key_list,
                include_docs: true 
            }).then(function(result){
                
            // determine renewal list
                for (var i = 0; i < result.rows.length; i++){
                    _transcript_list.push(result.rows[i].doc)
                }
                var _renewal_list = _construct_renewals(_transcript_list, _token_map)
      
                _deferred.resolve(_renewal_list)
                
            })
                
        })
    
        return _deferred.promise()
            
    }

// define token renewal processor
    function _renew_token(service_name){
        
    // construct new promise
        var _deferred = new $.Deferred()
         
    // renew token 
        var _renewing_token = renewingOAuthToken(service_name)
        _renewing_token.done(function(token_details){
            _update_alerts(service_name, action='remove')
            _deferred.resolve()
        })
        _renewing_token.fail(function(msg){
            _update_alerts(service_name, action='add')
            _deferred.resolve()
        })
    
        return _deferred.promise()
    
    }
        
// define create new transcript function
    function _create_transcript(){
    
    // create new transcript
        var transcript_time = ($.now() / 1000)
        var transcript_fields = {
            uid: user_id,
            created_dt: transcript_time,
            title: '',
            services: {},
            sources: [],
            elapsed_time: 0.0,
            tokens: {},
            feedback: {},
            edit: [],
            view: [],
            media: [],
            dt: transcript_time
        }
    // save transcript
        transcripts_db.post(transcript_fields).then(function(response){
        
        // construct transcript
            transcript_fields['_id'] = response.id
            const new_doc_id = response.id 
            _construct_transcript(transcript_fields, prepend=true)
        
        // replicate to remote
            transcripts_db.replicate.to(transcripts_remote).then(function(){
                logConsole('new transcript created')
            })
        
        // automatically start transcription on new transcript
//            const text_created = transcript_fields.created_dt
//            const transcript_prefix_new = record_key + '_' + new_doc_id
//            const text_selector = '#' + transcript_prefix_new + '_text'
//            const time_selector = '#' + transcript_prefix_new + '_time'
//            const mic_selector = '#' + transcript_prefix_new + '_mic'
//            const mic_box_selector = mic_selector + '_box'
//            _toggle_transcription(text_selector, mic_box_selector, mic_selector, time_selector, new_doc_id)
            
        })
        
    }

// define pagination retrieval function
    function _retrieve_transcripts(previous_record){
    
        var _deferred = new $.Deferred()
        
        transcripts_db.find({ 
            selector: { 
                // uid: user_id,
                created_dt: { $lt: previous_record.created_dt } 
            },
            sort: [ { created_dt: 'desc' } ],
            limit: 5,
            use_index: 'created_dt'
        }).then(function(results){
            _deferred.resolve(ingestArray(results.docs))
        })
        
        return _deferred.promise()
        
    }

// define pagination rendering function
    function _render_transcripts(_transcript_list, end_page){
    
        var _deferred = new $.Deferred()
        
    // construct transcript
        for (var i = 0; i < _transcript_list.length; i++){
            const _transcript_fields = _transcript_list[i]
            _construct_transcript(_transcript_fields, prepend=false)
        }
    
    // determine if anything new needs to be renewed
        var _renewed_tokens = []
        var _renewal_promise = _determine_renewals()
        _renewal_promise.then(function(_renewal_list){
            for (var i = 0; i < _renewal_list.length; i ++){
                _renewed_tokens.push(_renew_token(_renewal_list[i]))
            }
        })
    
    // resolve promise
        if (_renewed_tokens.length){
            $.when(_renewed_tokens).then(function(){ _deferred.resolve() })
        } else {
            _deferred.resolve()
        }
        
        return _deferred.promise()
    }

// define view constructor
    function _bind_view(){

    // process initial renewals 
        logConsole(token_renewals)
        var initial_renewals = []
        for (var i = 0; i < token_renewals.length; i++){
            initial_renewals.push(_renew_token(token_renewals[i]))
        }
    
    // initiate renewal listener (to renew tokens every 5min)
        $.when(...initial_renewals).then(function(){
            try {
                clearInterval(window.client_listeners['transcript_token_renewal'])
            } catch(err) {}
            tokens_db.sync((tokens_remote))
            window.client_listeners['transcript_token_renewal'] = setInterval(function(){
                var _renewal_promise = _determine_renewals()
                _renewal_promise.then(function(_renewal_list){
                    var _renew_token_promises = []
                    logConsole(_renewal_list)
                    for (var i = 0; i < _renewal_list.length; i ++){
                        _renew_token_promises.push(_renew_token(_renewal_list[i]))
                    }
                    if (_renew_token_promises.length){
                        $.when(..._renew_token_promises).then(function(){
                            tokens_db.sync(tokens_remote).then(function(){
                                // logConsole(JSON.stringify(_renewal_list) + ' renewed')
                            })
                        })
                    }
                })
            }, 300000)
        })
        
    // add listener to button
        $(create_new_selector).on('click', function(event){
            _create_transcript()    
        })
    
    // update mobile button
        var action_kwargs = {
            name: 'Create',
            icon: 'icon-plus',
            label: 'Create New Transcript',
            onclick: 'callFunction',
            args: [ _create_transcript ]
        }
        updateAction(action_kwargs)
    
    // add pagination to DOM
        const transcript_paginator = '#' + record_key + '_content_paginator'
        paginateView(transcript_paginator, transcript_list, _retrieve_transcripts, _render_transcripts, 5)
        
    }
       
// if view does not exist
    if (!$.trim($(container_selector).html())) { 
    
    // inject transcriptions view frame into container 
        var frame_html = sprintf('\
            <div id="%s_content_row" class="row">\
                <div id="%s_content_alert_box" style="display: none;">\
                    <div class="col-sm-3 hidden-xs background-alert"></div>\
                    <div class="col-sm-9 col-xs-12 background-alert">\
                        <div class="section-responsive">\
                            <div class="row form-line">\
                                <div class="col-lg-3 col-md-3 col-sm-3 hidden-xs">\
                                    <div class="form-text auto-height">Permissions:</div>\
                                </div>\
                                <div class="hidden-lg hidden-md hidden-sm col-xs-12">\
                                    <div class="form-label bold">Permissions:</div>\
                                </div>\
                                <div id="%s_content_alert_list" class="col-lg-9 col-md-9 col-sm-9 col-xs-12">\
                                </div>\
                            </div>\
                        </div>\
                    </div>\
                </div>\
                <div id="%s_content_column_index" class="col-sm-3 hidden-xs">\
                    <div id="%s_index_section" class="section-last">\
                        <div id="%s_index_create" class="form-line">\
                            <a href="#" id="%s_index_create_button" class="form-text"><span class="icon-plus padding-right-5"></span>Create New</a>\
                        </div>\
                        <div id="%s_index_entries"></div>\
                    </div>\
                </div>\
                <div id="%s_content_column_main" class="col-sm-9 col-xs-12">\
                    <div id="%s_content_column_main_body">\
                    </div>\
                    <div id="%s_content_paginator" class="invisible">Paginator</div>\
                </div>\
            </div>', 
            record_key, record_key, record_key, record_key, record_key, record_key, record_key,
            record_key, record_key, record_key, record_key, record_key, record_key)
        $(container_selector).html(frame_html)
    
    // inject records into view
        for (var i = 0; i < transcript_list.length; i++){
            const transcript_fields = transcript_list[i]
            const transcript_sources = ingestArray(transcript_fields.sources)
            _construct_transcript(transcript_fields, prepend=false)  
        }
    
    // determine which services to renew
        token_renewals = _construct_renewals(transcript_list, token_map)
        
    // bind listeners in view
        _bind_view()
 
    } 
    
// if view already exists
    else {
    
    // construct list of transcripts in the view
        var transcript_key_list = []
        var existing_transcripts = {}
        $(main_body_selector).find('.form-input-contenteditable').each(function(i, text){
            const doc_id = $(text).attr('data-doc-id')
            transcript_key_list.push(doc_id)
            const existing_time = $(text).parent().parent().parent().find('.elapsed-time')
            existing_transcripts[doc_id] = {
                _id: doc_id,
                dt: parseFloat($(text).attr('data-updated')),
                text: text,
                time: existing_time
            }
        })
        
    // retrieve most recent records
        transcript_list = []
        transcripts_db.allDocs({ 
            keys: transcript_key_list,
            include_docs: true 
        }).then(function(result){
            for (var i = 0; i < result.rows.length; i++){
                const transcript_fields = result.rows[i].doc
                transcript_list.push(transcript_fields)
                const doc_id = transcript_fields._id
                const transcript_updated = ingestNumber(transcript_fields.dt)
                const transcript_time = ingestNumber(transcript_fields.elapsed_time)
                const transcript_sources = ingestArray(transcript_fields.sources)
                const transcript_media = ingestArray(transcript_fields.media)
                
            // if transcript has been updated remotely, update view
                if (transcript_updated != existing_transcripts[doc_id].dt){
                    const transcript_tokens = ingestMap(transcript_fields.tokens)
                    const transcript_markup = markupTranscription(transcript_tokens, doc_id)
                    $(existing_transcripts[doc_id].text).html(transcript_markup)
                    transcriptListeners(transcript_markup.selectors, transcript_media)
                    $(existing_transcripts[doc_id].text).attr('data-updated', transcript_updated)
                    const time_html = _construct_time(transcript_time)
                    $(existing_transcripts[doc_id].time).html(time_html)
                    autosize($(existing_transcripts[doc_id].text))
                }
            
            }
            
        // determine which source access tokens have expired
            token_renewals = _construct_renewals(transcript_list, token_map)
            
        // bind view
            _bind_view()
            
        })
        
    }

}

function openTranscription(div_id='') {

    /* a method to retrieve audio transcriptions and open transcription view */
    
// log console
    console.log('Opening transcription.')
    
// update history
    updateHistory(openTranscription, [div_id])

// ensure socket is open
    var socket_request = handlingSocket(window.server_url)

// define success function
    function _retrieve_transcripts(socket_client){
    
    // load transcript and token buckets
        var transcript_promise = loadingBucket('audio_transcripts')
        var token_promise = loadingBucket('oauth2_tokens')
        var sources_promise = loadingBucket('source_materials')
        var media_promise = loadingBucket('source_media')
    
    // callback after bucket load
        $.when(transcript_promise, token_promise, sources_promise, media_promise).then(function(transcripts_db, tokens_db, sources_db, media_db){
            
        // define callback for db retrieval
            function _open_transcription(socket_client, transcript_list, service_map, token_map){
                
            // replace title
                var title_kwargs = {
                    app_title: window.app_title,
                    app_subtitle: 'Mitchell Experiment',
                    page_title: 'Experiment: Mitchell',
                    page_label: 'Storytelling Assistant Interface'
                }
                updateTitle(title_kwargs)

            // show dashboard
                showDashboard()
                
            // construct view and adjust location
                transcriptionView(socket_client, transcript_list, service_map, token_map)
                scrollDiv(div_id)
            
            }
                
        // search records for transcripts 
            var find_transcripts = transcripts_db.find({ 
                selector: { 
                    // uid: user_id,
                    created_dt: { $gt: null } 
                },
                sort: [ { created_dt: 'desc' } ],
                limit: 5,
                use_index: 'created_dt'
            })
        // search records for tokens
            var find_tokens = tokens_db.find({
                selector: { service_name: { $gt: null } },
                use_index: 'service_name'
            })
        // load service map for experiment
            var load_services = loadingServices('mitchell')
                        
        // await response from record search
            var token_map = {}
            var service_map = {}
            var experiment_details = {}
            var transcript_list = []
            $.when(find_transcripts, find_tokens, load_services).then(function(transcripts, tokens, service_map){
            
            // ingest responses
                transcript_list = ingestArray(transcripts.docs)
                var token_list = ingestArray(tokens.docs)
                for (var i = 0; i < token_list.length; i++){
                    var service_name = token_list[i].service_name
                    token_map[service_name] = token_list[i]
                }
                
            // open view
                _open_transcription(socket_client, transcript_list, service_map, token_map)
                
            }).catch(function(err){
                logConsole(err)
                _open_transcription(socket_client, transcript_list, service_map, token_map) 
            })
            
        })
        
    }
    
// send request and wait for callback
    $.when(socket_request).then(_retrieve_transcripts)
    
}

/**
* LAB JAVASCRIPT EXTENSION
* @author rcj1492
* @license Â©2016-2018 Collective Acuity
* @email support@collectiveacuity.com
*
* requirements:
* jquery
**/

//// import dependencies (when es6 is standard)
//import $ from 'jquery'

function logConsole(obj) {

/* a method to report any data object to log during development */
    
    let verbose = false
    if ('system_environment' in window){
        if (window.system_environment == 'dev' || window.system_environment == 'tunnel'){
            verbose = true
        }
    }
    if (obj == null || typeof(obj) == 'string' || typeof(obj) == 'number' || typeof(obj) == 'boolean') {
        if (verbose){
            console.log(obj)
        }
    } else if ($.isArray(obj) || typeof(obj) == 'object'){
        if (verbose){
            console.log(JSON.stringify(obj))
        }
    } else if (verbose) {
        try {
            console.log(JSON.stringify(obj))
        } catch(err) {}
    }

}

function deepCopy(obj) {

/* a method for cloning an object */

// https://stackoverflow.com/questions/728360/how-do-i-correctly-clone-a-javascript-object

    if (obj == null || typeof(obj) != "object") {
        return obj
    } else {
        var deep_copy = obj.constructor()
        for (var attr in obj) {
            if (obj.hasOwnProperty(attr)) deep_copy[attr] = obj[attr]
        }
        return deep_copy
    }

}

function ingestString(string_value) {

/* a method to ensure output is a string value */

    var default_value = ''
    if (typeof(string_value) != 'string') {
        return default_value
    } else if (string_value === 'undefined') {
        return default_value
    }
    return string_value

}

function ingestMap(map_object) {

/* a method to ensure output is a map object */

    var empty_map = {}
    if (map_object == null || typeof(map_object) == 'undefined') {
        return empty_map
    } else if (typeof(map_object) != 'object') {
        return empty_map
    } else if ($.isArray(map_object)){
        return empty_map
    } else if (!(mapSize(map_object))) {
        return empty_map
    }
    
    return map_object
    
}

function ingestBoolean(boolean_value) {

/* a method to ensure output is a boolean value */
    
    var default_value = false
    if (boolean_value == null || typeof(boolean_value) == 'undefined') {
        return default_value
    } else if (typeof(boolean_value) != 'boolean') {
        return default_value
    }
    return boolean_value

}

function ingestInteger(integer_value) {

/* a method to ensure output is an integer value */
     
    var default_value = 0
    if (integer_value == null || typeof(integer_value) == 'undefined') {
        return default_value
    } else if (typeof(integer_value) != 'number' || !(Math.floor(integer_value) === integer_value)) {
        return default_value
    }
    return integer_value
    
}

function ingestNumber(numeric_value) {

/* a method to ensure that output is a numerical value */
    
// NOTE FLOATS CANNOT BE PARSED CORRECTLY DUE TO HOW JS TREATS NO REMAINDERS (AKA 1.0)
    
    var default_value = 0.0
    if (numeric_value == null || typeof(numeric_value) == 'undefined') {
        return default_value
    } else if (typeof(numeric_value) != 'number') {
        return default_value
    }
    return numeric_value

}

function ingestArray(array_object) {

/* a method to ensure output is an array */

    var empty_array = []
    if (array_object == null || typeof(array_object) == 'undefined') {
        return empty_array
    } else if (!($.isArray(array_object))) {
        return empty_array
    }
    return array_object

}

function isMap(obj) {
 
/* a method to determine if an object is a map */

    if (obj == null || typeof(obj) == 'undefined') {
        return false
    } else if (typeof(obj) != 'object') {
        return false
    } else if ($.isArray(obj)){
        return false
    }
    
    return true
    
}

function isFunction(obj) {

/* a method to determine if an object is a function */

    if (obj == null || typeof(obj) == 'undefined') {
        return false
    } else if ({}.toString.call(obj) != '[object Function]') {
        return false
    }
    
    return true

}

function mapSize(map_object) {
    
/* a method to calculate the number of keys in a map object */
    
    var count = 0
    $.each(map_object, function(i, elem) {
        count ++
    })
    
    return count

}

function deleteObject(obj) {

    /* a method for deleting all the properties of an object */
    
    for (var key in obj){
        if (obj.hasOwnProperty(key)){
            obj[key] = null
            delete obj[key]
        }
    }
    obj = null
    
}

function sortArray(array_object, sort_criteria) {

    /* a method to sort an array of maps by criteria */
    
    /** sort criteria should be a list of single key-value pair maps
    *   where the key matches a key in each map in the array object
    *
    *   if the value of a key in the sort criteria is empty, then
    *   the array will be sorted in ascending alphanumerical value
    *   otherwise, it will be reverse alphanumerical order
    *
    *   EG. [ { "dt": "" }, { "last_name": "descending" } ]
    * 
    **/
    
    var array = ingestArray(array_object)
    var criteria = ingestArray(sort_criteria)
    
    if (array.length){
        for (var i = 0; i < criteria.length; i++){
            var sample_record = ingestMap(array[0])
            for (var key in ingestMap(criteria[i])){
                 if (key in sample_record){
            
            // sort descending
                    if (ingestString(criteria[i][key])){
                        array.sort(function(a, b){
                            if (b[key] > a[key]){ return 1 }
                            else if (b[key] < a[key]){ return -1 }
                            else { return 0 }
                        })
            
            // sort ascending
                    } else {
                        array.sort(function(a, b){
                            if (a[key] > b[key]){ return 1 }
                            else if (a[key] < b[key]){ return -1 }
                            else { return 0 }
                        })
                    }
                    
                } else {
                    throw 'sort_criteria[' + i.toString() + '].' + key + ' is not a field in the objects of the array.'
                }
            }
        }
    }

    return array

}

function filterArray(array_object, filter_criteria, max_results=0){

    /* a method to filter an array of maps based upon criteria */
    
// ingest variables
    var filtered_array = []
    var record_array = ingestArray(array_object)
    filter_criteria = ingestMap(filter_criteria)

// iterate over records testing filter criteria    
    for (var i = 0; i < record_array.length; i++){
    
        var add_record = true
        var record = ingestMap(record_array[i])
        
        for (var key in filter_criteria){
        
    // catch non-existent keys
            if (!(key in record)){
                if ('value_exists' in filter_criteria[key]){
                    if (!filter_criteria[key]['value_exists']){
                        continue
                    }
                }
                add_record = false
                break
            }    
        
            for (var k in filter_criteria[key]){
    
    // filter based upon key existence
                if (k == 'value_exists'){
                    if (!filter_criteria[key][k]){
                        if (key in record){
                            add_record = false
                            break
                        }
                    }
                }
    
    // filter based upon equal to value
                if (k == 'equal_to'){
                    if (filter_criteria[key][k] != record_array[i][key]){
                        add_record = false
                        break
                    }
                }
    
    // TODO add more filter tests
    
            }
            if (!add_record){
                break
            }
            
        }
        


// add valid records and check for max
        if (add_record){
            filtered_array.push(record_array[i])
            if (ingestInteger(max_results)){
                if (filtered_array.length >= max_results){
                    break
                }
            }
        }
        
    }
    
    return filtered_array
    
}

function capitalizeString(string_value, pythonic=false) {

    /* a method to capitalize all the words in a string */

// clean up and split words
    var clean_string = ingestString(string_value)
    if (pythonic){
        clean_string = clean_string.replace(/_/g, ' ')
    }

// construct capitalized string
    var capitalized_string = clean_string.replace(/\b\w/g, function(x){ return x.toUpperCase() })
    
//// capitalize each word
//    var string_array = ingestString(clean_string).split(' ')
//    var capitalized_array = []
//    for (var i = 0; i < string_array.length; i++){
//        var capitalized_word = string_array[i].toUpperCase().slice(0,1) + string_array[i].slice(1)
//        capitalized_array.push(capitalized_word)
//    }
//
//// recombine words
//    var capitalized_string = ''
//    if (capitalized_array.length){
//        capitalized_string = capitalized_array.join(' ')
//    }
    
    return capitalized_string
    
}

function injectLinks(string_value, dns_prefetch=true) {

/* a method to substitute an <a> element for a url value in a text string */

// define substitution function
    function _replace_url(x){
        var _url_string = '<a href="' + x + '" target="_blank">' + x + '</a>'
        if (dns_prefetch){
            var _prefetch_html = '<link rel="dns-prefetch" href="' + x + '">'
            $('head').append(_prefetch_html)
        }
        return _url_string
    }
    
    var new_string = string_value.replace(/https?:\/\/.*?(\s|,|$)/g, _replace_url)

    return new_string
    
}

function unpackKwargs(kwargs_input, kwargs_model, method_name) {

/* a method for unpacking and validating keyword arguments */

// TODO corporaate recursion
    
    if (typeof(kwargs_input) === 'undefined'){
        kwargs_input = {}
    }

    for (var key in kwargs_model) {
        var console_message = 'error unpacking ' + method_name + ': '
        try {
            if (key in kwargs_input) {
                if (typeof(kwargs_input[key]) === typeof(kwargs_model[key])) {
                    kwargs_model[key] = kwargs_input[key]
                } else {
                    console_message += key + ' must be a ' + typeof(kwargs_model[key]) + '.'
                    logConsole(console_message)
                };
            };
        } catch(e) {
            console_message += key + ' failed to unpack.'
            logConsole(console_message);
        };

    };

}

function convertElement(element_selector, new_tag) {

/* a method to convert one type of element to another in the DOM */
    
// construct method variables
    var old_tag = $(element_selector)[0].tagName.toLowerCase()
    var new_element_tag = '<' + new_tag + '></' + new_tag + '>'

// construct a new element
    var new_element = $(new_element_tag)

// add each attribute to new element
    $(element_selector).each(function() {
        $.each(this.attributes, function() {
            if(this.specified) {
                new_element.attr(this.name, this.value)
            }
        })
    })

// add inner html contents to new element
    new_element.html($(element_selector)[0].innerHTML)

// add/remove href attributes to/from new element
    if (new_tag == 'a'){
        new_element.attr('href', '#')
    } else if (old_tag == 'a'){
        new_element.removeAttr('href')
    }

// update DOM with replaced element
    $(element_selector).replaceWith(new_element)

}

function toggleStyle(element_selector, style_property) {

/* a method for changing a specific style in a DOM element */

// construct style regex pattern from style property
    var _style_regex = new RegExp(style_property, 'i')
    var jquery_element = $(element_selector)
    
// style already exists, add the style
    if (typeof(jquery_element.attr("style")) === "undefined") {
        jquery_element.attr("style", style_property)
    } else if (!_style_regex.test(jquery_element.attr("style"))) {
        var _new_style = jquery_element.attr("style") + " " + style_property
        jquery_element.attr("style", _new_style);
// otherwise, remove the style
    } else {
        var _new_style = jquery_element.attr("style").replace(style_property, "")
        if (_new_style) {
            jquery_element.attr("style", _new_style)
        } else {
            jquery_element.removeAttr("style")
        };
    };

}

function retrieveParams() {

/* a method to parse the params in the url */

    var param_fields = {}

// parse params from query string
    var query_fields = window.location.search.substring(1)
    var params = query_fields.split("&")
    for (var i = 0; i < params.length; i++){
        var pair = params[i].split('=')
        param_fields[pair[0]] = decodeURIComponent(pair[1])
    }

// reset page
    if (param_fields){
        if (window.history.pushState){
            var page_url = ingestString(window.page_url)
            var app_title = ingestString(window.app_title)
            if (!page_url){
                page_url = '/'
            }
            if (!app_title){
                app_title = 'Landing Page'
            }
            window.history.pushState({state:'dummy state'}, app_title, page_url)
        }
    }

    return param_fields

}

function autofocusEnd(input_selector) {

/* a method to move cursor to end of focused selection */

    $(input_selector).focus(function(){
        if (this.setSelectionRange) {
            var len = $(this).val().length;
            this.setSelectionRange(len, len);
        }
        else {
            $(this).val($(this).val());
        }
    })
    
}

function bindFunction(element_selector, function_name, function_args, function_group='') {
    
/* a method to bind a function to a click event */

//// construct client triggers property in window
//    if (!('client_triggers' in window)) {
//        window.client_triggers = {}
//    }    

// bind functions to click triggers
    if ($(element_selector).length) {
        
//    // determine trigger history path
//        var trigger_map = window.client_triggers
//        if (function_group){
//            if (!(function_group in window.client_triggers)){
//                window.client_triggers[function_group] = {}
//            }
//            trigger_map = window.client_triggers[function_group]
//        }
    
    // construct function and add binding
        var global_function = window[function_name]
        function_args = ingestArray(function_args)
        if (typeof(global_function) == 'undefined') {
              
            logConsole(sprintf('Function %s is not in the scope.', function_name))
        
        } else {  
//            trigger_map[element_selector] = true
            if (function_args.length) {
                $(element_selector).click(function(){
                    global_function(...function_args)
                })
            } else {
                $(element_selector).click(function(){
                    global_function()
                })
            }  
                
        }    
    }

}

function unbindListener(element_selector, group=false) {

/* a method to unbind a function or group of functions from a listener */
    
    if ('client_triggers' in window){
        if (element_selector in window.client_triggers){
            if (group){
                for (key in window.client_triggers[element_selector]){
                    if($(key).length){ $(key).off() }
                }
            } else { 
                if ($(element_selector).length){ $(element_selector).off() }
            }
            delete window.client_triggers[element_selector]        
        } 
    }

}

function clearListeners() {
    
/* a method to unbind all listeners in client triggers */

    if ('client_triggers' in window){
        for (key in window.client_triggers){
            if (ingestBoolean(window.client_triggers[key])){
                if ($(key).length){ $(key).off() }
            } else {
                const trigger_group = ingestMap(window.client_triggers[key])
                for (k in trigger_group){
                    if ($(k).length){ $(k).off()}
                }
            }
        }
        window.client_triggers = {}
    }
    
}

function updateHistory(func, args=null) {

/* a method for logging the navigation history of the client */
    
// construct client history
    if (!('client_history') in window){
        window.client_history = []
    }

// remove oldest history
    if (window.client_history.length > 49) {
        window.client_history.shift()
    }

// add new item
    window.client_history.push({ 'func': func, 'args': args })

}

function callFunction(callable, args=null) {

/* a method to invoke functions in the global scope */

    args = ingestArray(args)
    
    if (typeof(callable) == 'string') {
        var global_function = window[callable]
        if (typeof(global_function) == 'undefined') {     
            logConsole('Function ' + callable + ' is not in the global scope.')
        } else if (args.length) {
            global_function(...args)
        } else {
            global_function() 
        }
    } else if (args.length){
        callable(...args)
    } else {
        callable()
    }
    
}

function getFile(url) {

    var deferred = new $.Deferred()
    
    var xhr = new XMLHttpRequest();
    xhr.onload = function(e){
        if (this.status == 200){
            var file_reader = new FileReader()
            file_reader.readAsDataURL(this.response)
            file_reader.onloadend = function() {
                deferred.resolve(file_reader.result)
            }
        } else {
            deferred.reject()
        }
    }
    xhr.open('GET', url)
    xhr.responseType = 'blob'
    xhr.send()
    
    return deferred.promise()
                                                
}

/**
* FINGERPRINTS JAVASCRIPT EXTENSION
* @description Functions for retrieving device information 
* @author rcj1492
* @license Â©2017-2018 Collective Acuity
* @email support@collectiveacuity.com
*
* requirements:
* jquery
* fingerprint2
* retrieve.ip.js
* detect.browser.js
*
* cordova plugins:
* cordova-plugin-device
**/

//// import dependencies
//import $ from 'jquery'
//import { Fingerprint2 } from 'fp2'
//import { retrieveIPAddress } from 'retrieve.ip'
//import { BrowserDetect } from 'detect.browser'
//import { ingestNumber, logConsole } from 'lab'

function defineDevice(callback) {

/* a method to add device information to client fingerprint */

// requires cordova-plugin-device plugin
// https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-device/index.html

// construct device details from cordova device plugin
    var device_details = {}
    try { device_details['cordova_version'] = device.cordova } catch(e) {}
    try { device_details['device_model'] = device.model } catch(e) {}
    try { device_details['device_platform'] = device.platform } catch(e) {}
    try { device_details['device_uuid'] = device.uuid } catch(e) {}
    try { device_details['device_version'] = device.version } catch(e) {}
    try { device_details['device_manufacturer'] = device.manufacturer } catch(e) {}
    try { device_details['device_virtualization'] = device.isVirtual } catch(e) {}

// return device details
    callback(device_details)

}

function fingerprintDevice(callback) {

/* a method to add device fingerprint details to client fingerprint */

// requires fingerprintjs2 module
// https://github.com/Valve/fingerprintjs2

// define parse function
    function _parse_fingerprints(result, components) {

        var fingerprint_details = {
            hash: result,
            js_fonts: [],
            hardware_concurrency: 0,
            cpu_class: '',
            resolution: [],
            color_depth: 0,
            ip_address: '',
            language: '',
            local_storage: 0,
            session_storage: 0,
            navigator_platform: '',
            timezone_offset: 0,
            touch_support: []
        }

    // add fingerprint components
        for (var i=0; i < components.length; i++){
            var component_details = components[i]
            var key_name = component_details.key
            if (key_name in fingerprint_details){
                if (typeof(component_details.value) == typeof(fingerprint_details[key_name])){
                    fingerprint_details[key_name] = component_details.value
                }
            }
        }
    
    // convert timezone offset to seconds
        timezone_offset = ingestNumber(fingerprint_details.timezone_offset)
        if (timezone_offset){
            fingerprint_details['timezone_offset'] = timezone_offset * 60
        }
        
        callback(fingerprint_details)

    }

// retrieve fingerprints
    try {
        new Fingerprint2().get(function(result, components){

            _parse_fingerprints(result, components)

        })
    } catch(e) {}

}

function initializeRetrieveIP() {

/* a method to initialize the retrieve ip methods */
// requires retrieve.ip.js script

// construct new promise object
    var deferred = new $.Deferred()

// run retrieve IP address
    try {
        retrieveIPAddress(function(ip){
            deferred.resolve(ip)
        });
    } catch(e) {
        deferred.reject('Unable to retrieve IP address.')
    }

    return deferred.promise()
}

function initializeFingerprint() {

/* a function to initialize the fingerprint methods */

// construct new promise object
    var deferred = new $.Deferred()
    
// construct fingerprint property in window
    if (!('client_fingerprint' in window)){
        window.client_fingerprint = {}
    }

// add device details to client fingerprint
    defineDevice(function(details){
        for (var key in details){
            window.client_fingerprint[key] = details[key]
        }
    })

// add browser details to client fingerprint
    BrowserDetect.init()
    window.client_fingerprint['browser_name'] = BrowserDetect.browser
    window.client_fingerprint['browser_version'] = BrowserDetect.version
    if (typeof(window.client_fingerprint['browser_version'] == 'number')) {
        window.client_fingerprint['browser_version'] = window.client_fingerprint['browser_version'].toString()
    }
    
// add device fingerprints to client fingerprint
    fingerprintDevice(function(details){
        for (var key in details){
            window.client_fingerprint[key] = details[key]
        }
        
    // add ip address retrieved from webrtc
        var retrieve_promise = initializeRetrieveIP()
        retrieve_promise.done(function(ip){
            window.client_fingerprint['ip_address'] = ip
        })
        retrieve_promise.fail(function(msg){ logConsole(msg) })
        retrieve_promise.always(function(){
            deferred.resolve(window.client_fingerprint)
        })
    });

    return deferred.promise()
}

function retrievePublicIP() {

/* a method to retrieve public IP reflection */

// NOTE: likely to be blocked by adBlock

// construct new promise
    var deferred = new $.Deferred()

// construct json request
    var json_map = {
        url: '//ipapi.co/json/',
        crossDomain: true,
        success: function(data) {
            logConsole(data.ip)
            deferred.resolve(data)
        },
        error: function(response, exception){
            deferred.reject('Unable to retrieve IP')
        }
    }
   
// send request and return promise
    $.getJSON(json_map)
    return deferred.promise()

}



/**
* VIEWS JAVASCRIPT EXTENSION
* @author rcj1492
* @license Â©2017-2018 Collective Acuity
* @email support@collectiveacuity.com
*
* requirements:
* jquery
* jquery.isonscreen.min.js
* sprintf
* autosize
* gapi
* lab.js
* data.js
* fingerprints.js
* forms.js
* requests.js
* sockets.js
**/

//// import dependencies
//import $ from 'jquery'
//import sprintf from 'sprintf'
//import autosize from 'autosize'
//import gapi from 'google.api'
//import { initializeFingerprint } from 'fingerprints'
//import { loadRecord, upsertValues, clearRecords, saveItem, loadItem, listItems, deleteItem, startingPouchDB, stoppingPouch } from 'data'
//import { connectingClient, disconnectClient, handleEvents } from 'sockets'
//import { startSpeechRecognition, playAudio, stopSpeechRecognition, startSpeechTranscription, stopSpeechTranscription } from 'audio'
//import { showMessage, inputHandler, statusButtonHandler, statusIconHandler } from 'forms'
//import { gettingSession, puttingSession, postingSession, puttingAccount, postingAccount, patchingAccount, requestingResource, requestingOAuthToken, renewingOAuthToken } from 'requests'
//import { logConsole, toggleStyle, unpackKwargs, ingestString, ingestArray, ingestBoolean, ingestMap, mapSize, ingestNumber, sortArray, filterArray, bindFunction, convertElement, deepCopy, injectLinks, updateHistory, capitalizeString } from 'lab'

function showLanding() {
    
/* a method to enable the landing view elements */

// test style attribute 
    var visible_ids = $('.landing-page')
    var style_property = 'display: none;'

// disable landing elements if visible
    visible_ids.each(function(){
        var display_regex = new RegExp(/display:\snone/g)
        if (display_regex.test($(this).attr("style"))){
            toggleStyle(this, style_property);
        }
        
    })
    
}

function hideLanding() {

/* a method to disable the landing view elements */

// test style attribute 
    var visible_ids = $('.landing-page')
    var style_property = 'display: none;'

// disable landing elements if visible
    visible_ids.each(function(){
        var display_regex = new RegExp(/display:\snone/g)
        if (!(display_regex.test($(this).attr("style")))){
            toggleStyle(this, style_property);
        }
        
    })
    
}

function showDashboard() {

/* a method to enable the visibility of the dashboard elements */

// define variables
    var visible_ids = $('.id-verified')
    var style_property = 'display: none;'
    
// enable verified elements if not visible
    visible_ids.each(function(){
        var display_regex = new RegExp(/display:\snone/g)
        if (display_regex.test($(this).attr("style"))){
            toggleStyle(this, style_property);
        }
        
    })
    
// enable dashboard header border
    var border_ids = $('.header-border')
    border_ids.each(function(){
        $(this).addClass('navbar-border');
    })

// enable title
    showTitle()

// remove action and option links
    $('#header_right_mobile').empty()
    $('#dialog_options_buttons').empty()
    
// enable header and footer navigation
    $('#header_right_dashboard').show()
    $('#footer_verified').show()
    
}

function hideDashboard() {

/* a method to disable the visibility of the dashboard elements */

// define variables
    var visible_ids = $('.id-verified')
    var style_property = 'display: none;'
    
// disable verified elements if not visible
    visible_ids.each(function(){
    
        var display_regex = new RegExp(/display:\snone/g)
        if (!(display_regex.test($(this).attr("style")))){
            toggleStyle(this, style_property);
        }
        
    })
    
// disable dashboard header border
    var border_ids = $('.header-border')
    border_ids.each(function(){
        $(this).removeClass('navbar-border');    
    })

// disable header and footer navigation
    $('#header_right_dashboard').hide()
    $('#footer_verified').hide()
 
}

function showTitle(center_desktop=false) {

/* a method to enable the visibility of the header title elements */

// test style attribute
    var visible_id = $('#header_middle_desktop')
    var display_regex = new RegExp(/display:\snone/g)
    var display_visible = !(display_regex.test(visible_id.attr("style")))
    
// enable header title elements if not visible
    if (!display_visible){
        toggleStyle('#header_middle_desktop,#header_middle_mobile', 'display: none;')
    }

// toggle header center
    if (center_desktop){
        visible_id.removeClass('navbar-start')
        visible_id.addClass('navbar-center')
    } else {
        visible_id.removeClass('navbar-center')
        visible_id.addClass('navbar-start')
    }

}

function hideTitle(center_desktop=false) {

/* a method to enable the visibility of the header title elements */

// test style attribute
    var visible_id = $('#header_middle_desktop')
    var display_regex = new RegExp(/display:\snone/g)
    var display_visible = !(display_regex.test(visible_id.attr("style")))
    
// enable header title elements if not visible
    if (display_visible){
        toggleStyle('#header_middle_desktop,#header_middle_mobile', 'display: none;')
    }

// toggle header center
    if (center_desktop){
        visible_id.removeClass('navbar-start')
        visible_id.addClass('navbar-center')
    } else {
        visible_id.removeClass('navbar-center')
        visible_id.addClass('navbar-start')
    }
    
}

function showConversation() {

// test style attribute
    var visible_id = $('#dialog_chat')
    var display_regex = new RegExp(/display:\snone/g)
    var display_visible = !(display_regex.test(visible_id.attr("style")))
    
// show dialog for chat if not visible
    if (!display_visible){
        toggleStyle('#dialog_chat', 'display: none;')
        var main_ids = $('.id-chat-responsive')
        main_ids.each(function(){
            $(this).addClass('chat-responsive')
        })
    }
    
}

function hideConversation() {

// test style attribute
    var visible_id = $('#dialog_chat')
    var display_regex = new RegExp(/display:\snone/g)
    var display_visible = !(display_regex.test(visible_id.attr("style")))
    
// show dialog for chat if not visible
    if (display_visible){
        toggleStyle('#dialog_chat', 'display: none;')
        var main_ids = $('.id-chat-responsive')
        main_ids.each(function(){
            $(this).removeClass('chat-responsive')
        })
    }
    
}
        
function toggleView(view_id, view_html) {

/* a method to toggle between different content containers */

// convert id into selector
    if (view_id.indexOf('#') != 0){
        view_id = '#' + view_id
    }
    
// hide existing views
    $('#content').children().each(function(){
        $(this).hide()
    });
    
// if view doesn't already exist, add it
    if (!$(view_id).length) {
        $('#content').append(view_html)
// if view exists already, show it
    } else {
        $(view_id).show()
    }

}

function scrollDiv(div_id) {

/* a method to scroll to a specific element id on the page */

// TODO find out why scrollTop fails in same view

    if (div_id){
        
        var div_selector = '#' + div_id
        if ($(div_selector).length){
    //        parent.location.hash = div_id
            var header_height = $('#header_container').css('height')
            var header_value = parseInt(header_height.slice(0, -2))
            var scroll_height = $(div_selector).offset().top - header_value
            $('html, body').animate({ scrollTop: scroll_height }, 1)
        }
        
    } else {
        $('html, body').animate({ scrollTop: 0 }, 1)
    }
    
}

function flexibleDialog(options=null) {

/* a method to display text in a responsive dialog panel */

// ingest variables
    var dialog_options = ingestMap(options)
    var title = ingestString(dialog_options.title)
    var body = ingestString(dialog_options.body)
    var keep_open = ingestBoolean(dialog_options.keep_open)

// construct dialog html
    var dialog_html = sprintf('\
        <div id="flexible_dialog_box" class="dialog-flexible">\
            <div class="container-fluid">\
                <div class="row navbar-accent navbar-border">\
                    <div class="col-lg-2 col-md-2 col-sm-2 col-xs-2"></div>\
                    <div class="col-lg-8 col-md-8 col-sm-8 col-xs-8">\
                        <div id="flexible_dialog_title" class="navbar-title-24 navbar-center">%s</div>\
                    </div>\
                    <div class="col-lg-2 col-md-2 col-sm-2 col-xs-2">\
                        <div class="navbar-title-24 navbar-end">\
                            <a id="flexible_dialog_close" title="Close Button" class="icon-close font-sm float-middle"></a>\
                        </div>\
                    </div>\
                </div>\
            </div>\
            <div id="flexible_dialog_body" class="container-fluid margin-vertical-10">%s</div>\
        </div>',
        title, body
    )

// define selectors
    var dialog_box_selector = '#flexible_dialog_box'
    var dialog_title_selector = '#flexible_dialog_title'
    var dialog_close_selector = '#flexible_dialog_close'
    var dialog_body_selector = '#flexible_dialog_body'
    var dialog_backdrop_selector = '#dialog_backdrop'

// remove previous dialogs
    if ($(dialog_box_selector).length){ $(dialog_box_selector).remove() }

// inject DOM with html content
    $(dialog_backdrop_selector).show();
    $('body').append(dialog_html);

// define close function
    function _close_dialog(){
        $(dialog_backdrop_selector).hide();
        $(dialog_box_selector).remove();
    }
    
// bind event handlers to close dialogs
    if (keep_open){
        $(dialog_close_selector).click(_close_dialog)
    } else {
        $(dialog_box_selector).find('a').each(function(i, a){
            $(a).click(_close_dialog)
        })
    }
    $(dialog_backdrop_selector).click(_close_dialog)
        
}

function blockquoteDialog(blockquote_kwargs) {

/* a method to display blockquote information in a responsive dialog */

// declare input schema
    var input_schema = {
        'schema': {
            'title': 'Mission',
            'description': 'Statement of purpose for the laboratory.',
            'effective_date': '2016.05.31.13.45.55',
            'details': 'To make accessible to each individual the resources of the world.',
            'author': 'Collective Acuity'
        },
        'metadata': {
            'example_statements': [ 'display the lab mission' ]
        }
    }

// unpack kwargs input
    var blockquote_dict = input_schema.schema
    unpackKwargs(blockquote_kwargs, blockquote_dict, 'blockquoteDialog')

// define string variables
    var title_text = blockquote_dict.title;
    var div_id = title_text.toLowerCase().replace(/\s/g, '_');
    var div_title = blockquote_dict.description;
    var content_text = blockquote_dict.details;
    var author_text = blockquote_dict.author;

// construct html content from variables
    var content_html = sprintf('\
        <div id="%s_details" class="font-sm text-left" title="%s">\
            <blockquote class="blockquote-reverse">\
                <p>%s</p>\
                <footer>%s</footer>\
            </blockquote>\
        </div>',
        div_id, div_title, content_text, author_text
    )

// open dialog window
    var dialog_options = {
        title: title_text,
        body: content_html
    }
    flexibleDialog(dialog_options)

}

function itemizedDialog(itemized_kwargs) {

/* a method to display itemized information in a responsive dialog */

// declare input schema
    var input_schema = {
        'schema': {
            'title': 'Lab Protocols',
            'description': 'How flask bot uses data.',
            'effective_date': 0.0,
            'sections': [ {
                'section_title': 'Zero Tracking',
                'section_description': '',
                'section_items': [ 'We do not place any weird cookies, use any trackers or allow third parties services to collect data about you from us.' ]
            } ]
        },
        'metadata': {
            'example_statements': [ 'display the lab protocols information' ]
        }
    }

// unpack kwargs input
    var itemized_dict = input_schema.schema
    unpackKwargs(itemized_kwargs, itemized_dict, 'itemizedDialog')

 // define content variables
    var title_text = itemized_dict.title
    var div_id = title_text.toLowerCase().replace(/\s/g, '_');
    var div_title = itemized_dict.description;
    var sections_list = itemized_dict.sections;

 // construct html content from variables
    var content_html = sprintf('<div id="%s_details" class="font-mini small text-left" title="%s">', div_id, div_title)
    for (var i = 0; i < sections_list.length; i++) {
        content_html += sprintf('<strong>%s</strong>', sections_list[i].section_title);
        content_html += '<ul class="list-padding">';
        var section_items = sections_list[i].section_items;
        for (var j = 0; j < section_items.length; j++) {
            content_html += sprintf('<li>%s</li>', section_items[j]);
        };
        content_html += '</ul>';
    }
    content_html += '</div>';

// open dialog window
    var dialog_options = {
        title: title_text,
        body: content_html
    }
    flexibleDialog(dialog_options)
}

function slideoutDialog(dialog_id, dialog_side) {

/* a method to animate a slideout dialog */
    
// define menu variables
    var backdrop_id = '#dialog_backdrop_slideout'
    var active_id = dialog_id
    var active_links = dialog_id + ' a'
    var out_class = 'slideout-' + dialog_side
    var back_class = 'slideback-' + dialog_side

// show menu dialog
    $(backdrop_id).show()
    $(active_id).show()
    $(active_id).addClass(out_class)

// define close function
    function _close_dialog(){
        $(backdrop_id).hide()
        $(backdrop_id).off()
        $(active_id).removeClass(out_class)
        $(active_id).addClass(back_class)
        setTimeout(function(){
            $(active_id).hide()
            $(active_id).removeClass(back_class)
        }, 150)
    }

// bind event handlers to close dialogs
    $(active_links).click(function(){
        _close_dialog()
    });
    $(backdrop_id).click(function(){
        _close_dialog()
    });

}

function inputDialog(input_kwargs) {

/* a method to construct a dialog with an input field */

// ingest variables
    var restore_selector = ingestString(input_kwargs.selector)
    var restore_repeat = ingestString(input_kwargs.repeat)
    var restore_value = ingestString(input_kwargs.value)
    var title = ingestString(input_kwargs.title)
    var prompt = ingestString(input_kwargs.prompt)
    var label = ingestString(input_kwargs.label)
    var type = ingestString(input_kwargs.type)
    var placeholder = ingestString(input_kwargs.placeholder)
    var callable = input_kwargs.callable
    var criteria = ingestMap(input_kwargs.criteria)
    var args = ingestArray(input_kwargs.args)
    const prefix = 'flexible_dialog_confirm_' + title.toLowerCase().replace(/\s/g, '_')
    
// construct dialog html
    const dialog_html = sprintf('\
        <div id="%s_box" class="form-line text-left">\
            <div class="col-xs-12 margin-bottom-10">\
                <div class="form-text auto-height text-wrap">%s</div>\
            </div>\
            <div class="col-xs-12">\
                <div class="form-label bold">%s:</div>\
            </div>\
            <div class="col-xs-12 margin-bottom-5">\
                <form title="%s">\
                    <div class="row">\
                        <div class="col-lg-11 col-md-11 col-sm-11 col-xs-10 padding-right-0">\
                            <label for="%s_input" class="sr-only">%s</label>\
                            <input id="%s_input" type="%s" placeholder="%s" autofocus class="form-input">\
                        </div>\
                        <div class="col-lg-1 col-md-1 col-sm-1 col-xs-2 text-right padding-left-0">\
                            <div class="form-input">\
                                <span id="%s_status_error" class="icon-ban icon-error icon-overlay" style="display: none;"></span>\
                                <span id="%s_status_submit" class="icon-arrow-right-circle icon-success"></span>\
                            </div>\
                        </div>\
                    </div>\
                </form>\
            </div>\
        </div>', 
        prefix, prompt, label, label, prefix, label, 
        prefix, type, placeholder, prefix, prefix
    )

// construct flexible dialog
    var dialog_options = {
        title: title,
        body: dialog_html
    }
    flexibleDialog(dialog_options)

// construct selectors
    const background_selector = '#dialog_backdrop'
    const input_selector = '#' + prefix + '_input'
    const submit_selector = '#' + prefix + '_status_submit'
    const error_selector = '#' + prefix + '_status_error'
    const link_selectors = '#flexible_dialog_box a'
        
// define submit function
    function _submit_confirm(input_value){
        var callable_args = [input_value]
        if (args){
            for (var i = 0; i < args.length; i++){
                callable_args.push(args[i])
            }
        }
        $(background_selector).click()
        callable(...callable_args)
    }
    
// add listeners
    hidden_title = ''
    if (type == 'password'){
        hidden_title = 'Password'
    }
    inputHandler(input_selector, label, criteria, _submit_confirm, enter_submit=true, auto_save=false, hidden_title=hidden_title)
    statusButtonHandler(input_selector, error_selector, submit_selector, label, criteria, _submit_confirm, hidden_title=hidden_title)

// add listeners for dialog cancel which restore old values in form
    function _restore_value(event){
        if ($(restore_selector).length){
            if ($(restore_selector).get(0).isContentEditable){
                $(restore_selector).text(restore_value)
            } else {
                $(restore_selector).val(restore_value)
            }
        }
        if ($(restore_repeat).length){
            if ($(restore_repeat).get(0).isContentEditable){
                $(restore_repeat).text(restore_value)
            } else {
                $(restore_repeat).val(restore_value)
            } 
        }
    }
    $(background_selector).click(_restore_value)
    $(link_selectors).click(_restore_value)

// focus on input
    $(input_selector).focus()

}

function oauth2Dialog(oauth2_kwargs) {

/* a method to construct an oauth2 permission dialog */

// ingest method variables
    const service_name = oauth2_kwargs.service_name
    const service_title = oauth2_kwargs.service_title
    const service_logo = oauth2_kwargs.service_logo
    const service_id = 'oauth2_dialog_' + service_name
    const service_scopes = oauth2_kwargs.service_scopes
    const service_permission = oauth2_kwargs.service_permission

// construct content html
    var content_html = sprintf('\
        <div class="col-xs-12 margin-vertical-5">\
            <div class="row">\
                <div class="col-xs-12 text-center">\
                    <a id="%s">\
                        <img src="%s" alt="%s" class="icon-mega margin-bottom-10">\
                        <span class="form-text margin-bottom-10">%s</span>\
                    </a>\
                </div>\
            </div>\
            <div class="row">\
                <div class="col-xs-12">\
                    <div class="form-label text-left text-wrap auto-height margin-vertical-5">%s</div>\
                </div>\
            </div>\
        </div>',
        service_id, service_logo, service_title, service_title, service_permission
    )

// construct responsive dialog
    var dialog_options = {
        title: 'Access Authorization',
        body: content_html
    }
    flexibleDialog(dialog_options)

// add listeners
    const oauth2_selector = '#' + service_id
    $(oauth2_selector).on('click', function(){
        var oauth2_request = requestingOAuthToken(service_name, service_scopes)
        oauth2_request.fail(oauth2_kwargs.error)
        oauth2_request.done(oauth2_kwargs.success)
    })

}

function errorDialog(error_message) {

/* a method to construct a dialog to report errors */

// define method variables
    var dialog_title = 'Request Error'
    var dialog_message = error_message
    
// construct dialog html
    const dialog_html = sprintf('\
        <div class="col-xs-12 margin-vertical-10">\
            <div class="form-text auto-height text-wrap">%s</div>\
        </div>',
        dialog_message
    )

// construct flexible dialog
    var dialog_options = {
        title: dialog_title,
        body: dialog_html
    }
    flexibleDialog(dialog_options)
    
}

function retrievingOAuthToken(service_name, service_scopes, service_permissions=null, reprompt=false, callback=null) {

/* a promise to retrieve an existing oauth2 token or request permission to obtain one */

// ingest arguments
    var scopes = ingestArray(service_scopes)
    if (typeof(service_scopes) == 'string'){
        scopes = [service_scopes]
    }
    var permissions = ingestArray(service_permissions)
    if (typeof(service_permissions) == 'string'){
        permissions = [service_permissions]
    }
    
// construct a new promise
    var deferred = new $.Deferred()
    
// define callback function
    function _callback(token_details){
        if (callback) {
            deferred.resolve()
            callFunction(callback, [token_details])
        } else {
            deferred.resolve(token_details)
        }
    }
    
// define tokens db and remote
    var tokens_db = window.pouch_db.oauth2_tokens
    var tokens_remote = window.pouch_db.oauth2_tokens_remote
    
// define token sync waiter
    function _await_token_sync(existing_token){
    
        logConsole(existing_token)
        
        var oauth2_sync_waiter = setTimeout(function(){
            
            tokens_db.replicate.from(tokens_remote).then(function(result){
                if (result.docs_written){
                    tokens_db.find({
                        selector: { service_name: service_name },
                        use_index: 'service_name'
                    }).then(function(response){
                        const _token_details = response.docs[0]
                        logConsole(_token_details.access_token)
                        _callback(_token_details)
                    })
                } else {
                    _await_token_sync(existing_token)
                }
            }).catch(function(err){
                logConsole(JSON.stringify(err))
                deferred.reject('sync fail')
            })
               
        }, 500)
    
    }

// search for service token, schema and scopes from pouch db
    var finding_token = tokens_db.find({
        selector: { service_name: service_name },
        use_index: 'service_name'
    })
    var finding_service = window.pouch_schemas.oauth2_schemas.find({
        selector: { name: service_name },
        use_index: 'name'
    })
    var finding_scope = window.pouch_schemas.record_schemas.find({
        selector: { name: 'lab_scopes' },
        use_index: 'name'
    })
    $.when(finding_token, finding_service, finding_scope).then(function(tokens, services, lab_scopes){
    
    // ingest records
        var token_details = {}
        if (tokens.docs.length){ token_details = tokens.docs[0] }
        const access_token = ingestString(token_details.access_token)
        const expires_at = ingestNumber(token_details.expires_at)
        const service_details = services.docs[0].details
        const scope_map = lab_scopes.docs[0].details
        
    // determine permission increase
        var existing_scopes = []
        var update_scopes = []
        if (!mapSize(token_details)){
            update_scopes.push(...scopes)
        } else {
            existing_scopes = token_details.service_scope.split(' ')
            for (var i = 0; i < scopes.length; i++){
                if (existing_scopes.indexOf(scopes[i]) == -1){
                    update_scopes.push(scopes[i])
                }
            }
            if (update_scopes.length){
                update_scopes.push(...existing_scopes)
            }
        }
    
    // construct permission html
        var permission_html = ''
        var permission_list = []
        if (!permissions.length){
            if (update_scopes){
               for (var i = 0; i < update_scopes.length; i++){
                    permission_list.push(scope_map[update_scopes[i]]['description'])
                } 
            } else {
                for (var i = 0; i < scopes.length; i++){
                    permission_list.push(scope_map[scopes[i]]['description'])
                }
            }
        } else {
            permission_list.push(...permissions)
        }
        if (permission_list.length == 1){
            permission_html = permission_list[0]
        } else if (permission_list.length > 1){
            permission_html += '<ul>'
            for (var i = 0; i < permission_list.length; i++){
                permission_html += '<li>' + permission_list[i] + '</li>'
            }
            permission_html += '</ul>'
        }

    // request permission increase
        if (update_scopes.length){
            
        // define oauth2 keywords
            var oauth2_kwargs = {
                success: function(){
                    _await_token_sync(access_token)
                },
                error: function(msg){
                    deferred.reject(msg)
                },
                service_scopes: update_scopes,
                service_permission: permission_html
            }
            for (var key in service_details){
                oauth2_kwargs[key] = service_details[key]
            }
    
        // open oauth2 dialog
            oauth2Dialog(oauth2_kwargs)
            
    // else if reprompt 
        } else if (reprompt){
            
        // define oauth2 keywords
            var oauth2_kwargs = {
                success: function(){
                    _await_token_sync(access_token)
                },
                error: function(msg){
                    deferred.reject(msg)
                },
                service_scopes: existing_scopes,
                service_permission: permission_html
            }
            for (var key in service_details){
                oauth2_kwargs[key] = service_details[key]
            }
    
        // open oauth2 dialog
            oauth2Dialog(oauth2_kwargs)
    
    // else attempt to renew expired token    
        } else if (expires_at && expires_at < $.now() / 1000){
            
            var renewing_token = renewingOAuthToken(service_name)
            renewing_token.done(function(token_details){
            
                tokens_db.replicate.from(tokens_remote).then(function(result){
                    _callback(token_details)
                }).catch(function(err){
                    logConsole(JSON.stringify(err))
                    _callback(token_details)
                })
                
            })
        
            renewing_token.fail(function(msg){
        
        // handle revoked authorization
                if (msg.indexOf('renewed') > -1 || msg.indexOf('exist') > -1){
                
            // define oauth2 keywords
                    var oauth2_kwargs = {
                        success: function(){
                            _await_token_sync(access_token)
                        },
                        error: function(msg){
                            deferred.reject(msg)
                        },
                        service_scopes: existing_scopes,
                        service_permission: permission_html
                    }
                    for (var key in service_details){
                        oauth2_kwargs[key] = service_details[key]
                    }
            
            // open oauth2 dialog
                    oauth2Dialog(oauth2_kwargs)
            
                } else {
                    deferred.reject(msg)
                }
            
            })
    
    // else current token is good
        } else {
            _callback(token_details)
        }
        
    })

    return deferred.promise()
    
}

function loadingSchema(schema_name, callback=null) {

// construct new promise
    var deferred = new $.Deferred()

// find schema
    window.pouch_schemas.record_schemas.find({
        selector: { name: schema_name },
        use_index: 'name'
    }).then(function(results){
// parse results
        var schema_details = results.docs[0].details
        deferred.resolve(schema_details)
        if (callback){
            callFunction(callback, [schema_details])
        }
    })
    
    return deferred.promise()
    
}

function loadingService(service_name) {

// construct new promise
    var deferred = new $.Deferred()

// search for oauth schema
    window.pouch_schemas.oauth2_schemas.find({
        selector: { name: service_name },
        use_index: 'name'
    }).then(function(results){
        var service_details = results.docs[0].details
        deferred.resolve(service_details)
    })
    
    return deferred.promise()
    
}

function loadingServices(experiment_name='') {

/* a method to retrieve a map of services available */

// construct new promise
    var deferred = new $.Deferred()

// define method variables
    var service_map = {}
    
// search for records in oauth2 schema
    window.pouch_schemas.oauth2_schemas.find({
        selector: { name: { $gt: null } },
        use_index: 'name'
    }).then(function(results){
        var service_list = ingestArray(results.docs)
    
    // if no experiment, return entire map
        if (!experiment_name){
           
            for (var i = 0; i < service_list.length; i++){
                const service_name = service_list[i].name
                service_map[service_name] = service_list[i].details
            }
            deferred.resolve(service_map)
    
    // else, return map of integrations in experiment
        } else {
            loadingSchema('lab_experiments').then(function(experiments){
            
            // retrieve experiment
                var experiment = experiments[experiment_name]
                
            // retrieve service details from experiment integrations
                var service_scopes = {}
                for (var i = 0; i < experiment.integrations.length; i++){
                    const service_name = experiment.integrations[i].name
                    service_scopes[service_name] = experiment.integrations[i]
                }
            
            // merge service details from experiment and oauth2 schemas
                for (var i = 0; i < service_list.length; i++){
                    var service_details = service_list[i].details
                    var service_name = service_details.service_name
                    if (service_name in service_scopes){
                        service_map[service_name] = service_details
                        for (var key in service_scopes[service_name]){
                            service_map[service_name][key] = service_scopes[service_name][key]
                        }
                    }
                }
                
                deferred.resolve(service_map)
            
            })
        }
        
    })

    return deferred.promise()
    
}

function loadingBucket(bucket_name, compact_bucket=true, sync_records=true) {

/* a promise to handle loading of a pouch db bucket */

// construct new promise
    var deferred = new $.Deferred()

// test existence of bucket in scope
    var bucket = null
    if (!bucket_name in window.pouch_db){
        deferred.reject(bucket_name + ' not in window.pouch_db')
    } else {
        bucket = window.pouch_db[bucket_name]
    }

// define sync function
    function _sync_bucket(_bucket){
    
        if (sync_records){
        
            const remote_name = bucket_name + '_remote'
            _bucket.sync(window.pouch_db[remote_name]).then(function(result){
            
                if (compact_bucket){
                    bucket.compact().then(function(_result){
                        logConsole(bucket_name + ' sync complete')
                        deferred.resolve(bucket)
                    }).catch(function(_err){
                        logConsole(JSON.stringify(_err))
                        deferred.resolve(bucket)
                    })
                } else {
                    logConsole(bucket_name + ' sync complete')
                    deferred.resolve(_bucket)
                }
    
            }).catch(function(err){
                logConsole(JSON.stringify(err))
                deferred.resolve(_bucket)
            })
            
        } else {
        
            if (compact_bucket){
                bucket.compact().then(function(_result){
                    deferred.resolve(bucket)
                }).catch(function(_err){
                    logConsole(JSON.stringify(_err))
                    deferred.resolve(bucket)
                })
            } else {
                deferred.resolve(_bucket)
            }
            
        }
        
    }
    
// test previous instantiation of bucket
    if (!bucket){
    
    // test authentication
        var session_patch = patchingSession()
    
    // user authenticated
        session_patch.done(function(session_token){
        
        // test gateway credentials
            var gateway_auth = ingestMap(loadRecord('gateway_auth'))
            
        // user has credentials
            if (mapSize(gateway_auth)){
                startingPouchDB().then(function(){
                // user attempted to open a view
                    if (window.client_history.length){
                        var last_index = window.client_history.length - 1
                        var func = window.client_history[last_index].func
                        var args = ingestArray(window.client_history[last_index].args)
                        if (args){
                            func(...args)
                        } else {
                            func()
                        }
                    } 
                // user came from a third source
                    else {
                        logConsole('fresh')
                        openDashboard()
                    }
                // resolve promise
                     bucket = window.pouch_db[bucket_name]
                     _sync_bucket(bucket)
                })
            }
             
        // user access has been deactivated
            else {
                deferred.reject('user deactivated')
                openAccount()
            }
            
        })
    
    // user not authenticated
        session_patch.fail(function(){
            deferred.reject('user not authenticated')
            openAuthentication()
        })
    
    } else {
    
        _sync_bucket(bucket)
        
    }
    
    return deferred.promise()

}

function loadingLibrary(source_name, library_name) {
   
    var deferred = new $.Deferred()
    
    if (!('javascript_libraries' in window)){
        window.javascript_libraries = {}
    }
    
    if (source_name in window.javascript_libraries){
        if (library_name in window.javascript_libraries[source_name]){
            if (source_name == 'google'){
                if (typeof(gapi.client[library_name]) == 'undefined'){
                    gapi.client.load(window.javascript_libraries[source_name][library_name]).then(function(){
                        deferred.resolve(gapi.client[library_name])
                    })
                } else {
                    deferred.resolve(gapi.client[library_name])
                }
            } else {
                deferred.reject()
            }
        } else {
            deferred.reject()
        }
    } else {
        deferred.reject()
    }

    return deferred.promise()
    
}

function paginateView(page_selector, original_list, retrieving_func, rendering_func, page_size){

/* a method to add pagination to a scrollable list of records */

// construct original record list
    var _record_list = deepCopy(original_list)
    
// define internal function
    function _paginate_view(){
    
    // verify paginator still exists
        if ($(page_selector).length){

        // verify paginators view is visible
            if ($(page_selector).is(':visible')){
            
            // set timeout for paginator
                setTimeout(function(){
                
                // only paginate if there are items to paginate
                    if (_record_list.length){
                        
                    // get paginator visibility
                        const _page_visible = $(page_selector).isOnScreen(function(deltas){ 
                            return deltas.top >= -100;
                        })
                        
                        if (_page_visible){
                        
                        // retrieve last record
                            previous_record = ingestMap(_record_list[_record_list.length -1])
                        
                        // run searching function
                            retrieving_func(previous_record).then(function(next_results){
                            
                            // update rendering arguments
                                _record_list = next_results
                                var _end_page = false
                                
                                if (_record_list.length){
                                
                                    if (_record_list.length < page_size){
                                        _end_page = true
                                    }
                                    
                            // run rendering function
                                    logConsole('paginating')
                                    rendering_func(_record_list, _end_page).then(function(){
                                        if (!_end_page){
                                            _paginate_view()
                                        }
                                    })
                                
                                }
        
                            })
                            
                        } else {
                       
                            _paginate_view()
                               
                        }
                        
                    }
                    
                }, 500)
        
            }    
                
        }
   
    }

// call internal function
    _paginate_view()
    
}

function tocLayout(toc_title, toc_list, top=true) {

/* a method to construct a table of contents layout */

    /** sample toc_list:
    *   [ {
    *       section_title: 'Today',
    *       section_selector: 'section_today_row'
    *   } ]
    **/

// ingest input
    if (!ingestString(toc_title)){ toc_title = 'Table of Contents' }

// reconstruct toc list
    var _toc_list = []
    if ($.isArray(toc_list)){
        for (var i = 0; i < toc_list.length; i++) {
            var details = {}
            details.title = ingestString(toc_list[i].section_title)
            if (!details.title){ details.title = 'Section ' + i.toString() }
            details.id = details.title.toLowerCase().replace(/\s/g, '_')
            details.selector = ingestString(toc_list[i].section_selector)
            if (!details.selector){ details.selector = sprintf('%s_row' % details.id)}
            _toc_list.push(details)
        }
    }

// retrieve page url
    var page_url = '/'
    if ('page_url' in window){
        var page_url = window.page_url
    }

// create top html
    var top_html = ''
    if (top){
        top_html = sprintf('\
            <div id="main_top" class="hidden-lg hidden-md hidden-sm">\
                <div id="top_section" class="section-row">\
                    <div id="top_section_title" class="form-line">\
                        <div id="top_section_title_text" class="form-text no-wrap bold" title="%s">%s</div>\
                    </div>\
                </div>\
            </div>',
            toc_title, toc_title
        )
    }

// inject table of contents framework into content
    var toc_html = sprintf('\
        <div id="content_container" class="container content-container-scroll">\
            <div id="content_row" class="row">\
                <div id="content_column_toc" class="col-sm-3 hidden-xs">\
                    <div id="toc_section" class="section-last">\
                        <div id="toc_section_title" class="form-line">\
                            <div id="toc_section_title_text" class="form-text no-wrap bold" title="%s">%s</div>\
                        </div>\
                    </div>\
                </div>\
                <div id="content_column_main" class="col-sm-9 col-xs-12">%s\
                    <div id="content_column_main_body">\
                    </div>\
                </div>\
            </div>\
        </div>',
        toc_title, toc_title, top_html
    )
    $('#content').html(toc_html)

// populate table of contents with links
    for (var i = 0; i < _toc_list.length; i++) {

        var section_selector = _toc_list[i].selector
        var section_title = _toc_list[i].title
        var section_id = _toc_list[i].id
        var section_html = sprintf('\
            <div id="toc_div_%s" class="form-line">\
                <a href="%s#%s" id="toc_link_%s" class="form-text no-wrap" title="Go to %s Section">%s</a>\
            </div>',
            section_id, page_url, section_selector, section_id, section_title, section_title
        )
        $('#toc_section').append(section_html)
        if (top) {
            var section_html = sprintf('\
                <div id="top_div_%s" class="form-line">\
                    <a href="%s#%s" id="top_link_%s" class="form-text text-nowrap" title="Go to %s Section">%s</a>\
                </div>',
                section_id, page_url, section_selector, section_id, section_title, section_title
            )
            $('#top_section').append(section_html)
        }

    }

}

function renderEpoch(epoch_timestamp) {
    
    // TODO add formatting options to transcript date generator
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString
    var _new_date = new Date(parseInt((epoch_timestamp * 1000), 10))
    return _new_date.toLocaleString()
    
}

function contentMiddle() {

/* a method for constructing a full page middle center display */

// construct content html
    var middle_html = '\
        <div id="content_container" class="content-container-fill">\
            <div id="content_row" class="row height-100">\
                <div id="content_left" class="col-lg-4 col-md-4 col-sm-3 hidden-xs"></div>\
                <div id="content_middle" class="col-lg-4 col-md-4 col-sm-6 col-xs-12 height-100">\
                    <div id="content_middle_row" class="row vertical-center">\
                        <div id="content_middle_column" class="col-lg-12 col-md-12 col-sm-12 col-xs-12"></div>\
                    </div>\
                </div>\
                <div id="content_right" class="col-lg-4 col-md-4 col-sm-3 hidden-xs"></div>\
            </div>\
        </div>'

// update DOM with content html
    $('#content').html(middle_html)

}

function updateTitle(title_kwargs) {

/* a method for updating the title fields */

// declare input schema
    var input_schema = {
        'schema': {
            'app_title': 'Collective Acuity',
            'app_subtitle': 'Welcome to the Laboratory',
            'page_title': 'Collective Acuity',
            'page_label': 'A Machine Intelligence Laboratory',
            'center_desktop': false
        },
        'metadata': {
            'example_statements': [ 'update the title fields' ]
        }
    }

// ingest arguments
    var title_dict = input_schema.schema
    unpackKwargs(title_kwargs, title_dict, 'updateTitle')

// change page title
    var title_parts = document.title.split(' : ')
    if (title_dict.app_title){
        title_parts[0] = title_dict.app_title
    }
    if (title_dict.app_subtitle){
        title_parts[1] = title_dict.app_subtitle
    }
    document.title = title_parts.join(' : ')

// change header title
    var header_ids = [ '#header_title_desktop_text', '#header_title_mobile_text' ]
    for (var i = 0; i < header_ids.length; i++) {
        header_id = header_ids[i]
        if (!title_dict.page_label) {
        $(header_id).removeAttr('title')
        } else {
            $(header_id).attr('title', title_dict.page_label)
        }
        $(header_id).text(title_dict.page_title)
    }

// toggle header center
    var desktop_title_id = '#header_title_desktop'
    if (title_dict.center_desktop){
        $(desktop_title_id).removeClass('navbar-start')
        $(desktop_title_id).addClass('navbar-center')
    } else {
        $(desktop_title_id).removeClass('navbar-center')
        $(desktop_title_id).addClass('navbar-start')
    }

}

function updateAction(action_kwargs) {

/* a method for updating the action button */
    
// declare input schema
    var input_schema = {
        'schema': {
            'name': 'Options',
            'icon': 'icon-options',
            'label': 'View Options',
            'onclick': 'slideoutDialog',
            'args': [ '#dialog_options', 'bottom' ]
        }
    }

// define action ids
    const action_id = '#header_right_mobile'
    const action_selector = '#header_right_button_link'
    
// hide button and unbind listener
    if (typeof(action_kwargs) === 'undefined'){
        
        $(action_id).hide()
        $(action_selector).off()
        
    } else {

    // ingest action kwargs    
        var action_dict = input_schema.schema
        unpackKwargs(action_kwargs, action_dict, 'updateAction')
    
    // construct action html
        var button_onclick = ingestString(action_dict.onclick)
        var button_args = ingestArray(action_dict.args)
        var action_html = sprintf('\
            <div id="header_right_button" class="navbar-title-24 navbar-end">\
                <a id="header_right_button_link" title="%s" class="%s"></a>\
            </div>',
            action_dict.label, action_dict.icon
        )
    
    // inject into DOM
        $(action_id).html(action_html)
    
    // add trigger
        bindFunction(action_selector, button_onclick, button_args)
        
    }
    
}

function updateOptions(options_kwargs) {

/* a method for updating buttons in options dialog */
    
// declare input schema
    var input_schema = {
        'schema': {
            'options': [
                {
                    'name': 'Experiments',
                    'label': 'View Experiments',
                    'onclick': 'openExperiments',
                    'args': [ 'experiments_main_body_mitchell' ]
                }
            ]
        }
    }

// ingest arguments
    var options_dict = input_schema.schema
    unpackKwargs(options_kwargs, options_dict, 'updateOptions')

// define element ids
    var options_id = '#dialog_options_buttons'
    var buttons_group = 'options_buttons'

// remove existing options and triggers
//    unbindListener(buttons_group, group=true)
    $(options_id).empty()
    
// construct options html
    for (var i = 0; i < options_dict.options.length; i++) {
        var button_details = options_dict.options[i]
        var button_name = ingestString(button_details.name)
        var button_id = 'dialog_options_button_' + button_name.toLowerCase().replace(/\s/g,'_')
        var button_selector = '#' + button_id
        var button_onclick = ingestString(button_details.onclick)
        var button_args = ingestArray(button_details.args)
        var button_label = ingestString(button_details.label)
        var button_class = 'navbar-title-24 navbar-center'
        if (i > 0){
            button_class += ' options-button'
        }
        $('<div/>', {
            id: button_id,
            class: button_class
        }).appendTo(options_id)
        var link_options = {
            id: button_id + '_link',
            text: button_name
        }
        if (button_label){ link_options['title'] = button_label }
        if (button_onclick) {
            $('<a/>').appendTo(button_selector)
            bindFunction(button_selector, button_onclick, button_args, buttons_group)
        } else {
            $('<span/>', link_options).appendTo(button_selector)
        }
    }

}

function updateNavigation(navigation_kwargs) {

/* a method to update the links/buttons in the navigation panel */
    
// define input schema
    var input_schema = {
        'schema': {
            'links': [
                {
                    'icon': 'icon-chemistry',
                    'name': 'Experiments',
                    'label': 'View Experiments',
                    'onclick': 'methodRequest',
                    'args': [ 'experimentView', { method:'GET', route:'/views/experiments' } ]
                }
            ]
        }
    }

// ingest input
    var navigation_dict = input_schema.schema
    unpackKwargs(navigation_kwargs, navigation_dict, 'updateNavigation')

// define navigation ids
    const nav_desktop_id = '#header_right_desktop'
    const nav_mobile_id = '#footer_verified_mobile'
    const nav_desktop_row = '#header_navigation_row'
    const nav_mobile_row = '#footer_navigation_row'

//// unbind any prior triggers
//    const link_group = 'navigation_buttons'
//    unbindListener(link_group, group=true)
    
// construct navigation htmls
    var footer_wrapper_html = '<div id="footer_navigation_row" class="row navbar-accent footer-border"></div>'
    var header_wrapper_html = '<div id="header_navigation_row" class="row"></div>'
    $(nav_mobile_id).html(footer_wrapper_html)
    $(nav_desktop_id).html(header_wrapper_html)

// determine width of columns
    var column_width = 12
    var middle_column = 0
    if (navigation_dict['links'].length == 2){ column_width = 6 } 
    else if (navigation_dict['links'].length == 3){ column_width = 4 } 
    else if (navigation_dict['links'].length == 4){ column_width = 3 } 
    else if (navigation_dict['links'].length < 7){
        column_width = 2
        if (navigation_dict['links'].length == 5){ middle_column = 4 }
    } else { column_width = 1 }

// inject links into navigation elements
    for (var i = 0; i < navigation_dict['links'].length; i++){

    // determine attribute values from input
        var col_width = column_width
        if (middle_column && i == 2){ col_width == middle_column }
        var link_details = ingestMap(navigation_dict['links'][i])
        var link_title = ingestString(link_details.name).toLowerCase().replace(/\s/g,'_')
        var link_icon = 'icon-chemistry'
        if (ingestString(link_details.icon)){ link_icon = ingestString(link_details.icon) }
        var link_label = ingestString(link_details.label)
        if (link_label){
            link_label = sprintf(' title="%s"', link_label)
        }

    // construct footer html
        var footer_html = sprintf('\
            <div id="footer_navigation_%s_column" class="col-xs-%s">\
                <div id="footer_navigation_%s_button" class="navbar-title-24 navbar-center">\
                    <div id="footer_navigation_%s_box">\
                        <a id="footer_navigation_%s_link" class="%s"%s></a>\
                    </div>\
                </div>\
            </div>',
            link_title, col_width,
            link_title,
            link_title,
            link_title, link_icon, link_label
        )
        $(nav_mobile_row).append(footer_html)
        

    // construct header html
        var header_html = sprintf('\
            <div id="header_navigation_%s_column" class="col-xs-%s">\
                <div id="header_navigation_%s_button" class="navbar-title-24 navbar-end">\
                    <div id="header_navigation_%s_box">\
                        <a id="header_navigation_%s_link" class="%s"%s></a>\
                    </div>\
                </div>\
            </div>',
            link_title, col_width,
            link_title,
            link_title,
            link_title, link_icon, link_label
        )
        $(nav_desktop_row).append(header_html)
     
    // add triggers
        var link_onclick = ingestString(link_details.onclick)
        if (link_onclick){
            var link_args = ingestArray(link_details.args)
            var link_selector_header = sprintf('#header_navigation_%s_link', link_title)
            var link_selector_footer = sprintf('#footer_navigation_%s_link', link_title)
            bindFunction(link_selector_header, link_onclick, link_args)
            bindFunction(link_selector_footer, link_onclick, link_args)
        }

    }

}

function toggleNavigation(view_name) {

/* a method to toggle between the active and inactive navigation links/buttons */

// define element ids
    var link_title = ingestString(view_name).toLowerCase().replace(/\s/g, '_')
    var footer_id = sprintf('#footer_navigation_%s_link', link_title)
    var header_id = sprintf('#header_navigation_%s_link', link_title)
    var footer_links = '#footer_navigation_row a'
    var header_links = '#header_navigation_row a'

// remove hidden link class
    $(footer_links).removeClass('hidden-link bold')
    $(header_links).removeClass('hidden-link bold')

// add hidden class to link name
    $(footer_id).addClass('hidden-link bold')
    console.log(footer_id, $(footer_id).attr('class')) // TODO WTF!!!!
    $(header_id).addClass('hidden-link bold')

}

function menuBindings(menu_details) {

/* a method to initialize bindings for the menu actions */
    
    const section_list = ingestArray(menu_details.sections)
    for (var i=0; i < section_list.length; i++){
        const action_list = ingestArray(section_list[i].actions)
        for (var j=0; j < action_list.length; j++){
            const action_name = ingestString(action_list[j].name).toLowerCase().replace(/\s/g, '_');
            if (action_name){
            
                var function_name = ingestString(action_list[j].onclick)
                var function_args = ingestArray(action_list[j].args)
                var menu_selector = '#menu_action_' + action_name + '_link'
                bindFunction(menu_selector, function_name, function_args)
                
            }
            
        }
    }
    
}

function landingView() {

/* a method to display the landing content */

// construct landing content
    var landing_html = '\
        <div id="landing_container" class="content-container-fill">\
            <div id="landing_row" class="row height-100">\
                <div id="landing_left" class="col-lg-4 col-md-4 col-sm-3 hidden-xs"></div>\
                <div id="landing_middle" class="col-lg-4 col-md-4 col-sm-6 col-xs-12 height-100">\
                    <div id="landing_middle_row" class="row vertical-center">\
                        <div id="landing_middle_column" class="col-lg-12 col-md-12 col-sm-12 col-xs-12">\
                            <div id="landing_box" class="font-mega text-center line-height-1 padding-vertical-20">\
                                <div id="landing_box_animation" class="burst-effect">\
                                    <a id="landing_box_icon" title="Click to Open Lab"><img src="/public/images/logos/lab-logo.svg"></a>\
                                </div>\
                            </div>\
                        </div>\
                    </div>\
                </div>\
                <div id="landing_right" class="col-lg-4 col-md-4 col-sm-3 hidden-xs"></div>\
            </div>\
        </div>'

// update DOM with content html
    $('#content').html(landing_html)

// toggle landing elements
    showLanding()
    
// add listeners
    $('#landing_box_icon').click(function(event){
        $('#landing_box_icon').off()
        $('#landing_box').fadeOut(600)
        hideLanding()
        openLab()
    })
}

function inputView(input_kwargs) {

/* a function to generate the content and listeners for a single input box */
    
// ingest variables
    var box_selector = ingestString(input_kwargs.selector)
    var title = ingestString(input_kwargs.title)
    var prefix = title.toLowerCase().replace(/\s/g, '_')
    var prompt = ingestString(input_kwargs.prompt)
    var label = ingestString(input_kwargs.label)
    var type = ingestString(input_kwargs.type)
    var promise = input_kwargs.promise
    var success = input_kwargs.success
    var options = ingestArray(input_kwargs.options)
    var placeholder = ingestString(input_kwargs.placeholder)
    var criteria = ingestMap(input_kwargs.criteria)
    var promise_args = ingestArray(input_kwargs.promise_args)
    var repeat_label = ingestString(input_kwargs.repeat_label)
    var repeat_placeholder = ingestString(input_kwargs.repeat_placeholder)
    var honeypot_label = ingestString(input_kwargs.honeypot_label)
    var honeypot_type = ingestString(input_kwargs.honeypot_type)
    var honeypot_prefix = honeypot_label.toLowerCase().replace(/\s/g, '_')

// construct repeat insert html
    var repeat_insert = ''
    if (repeat_label && label){       
        repeat_insert = sprintf('\
            <div id="%s_top_repeat" class="col-xs-12"><div class="form-label invisible">%s</div></div>\
            <div id="%s_middle_repeat" class="col-xs-12 margin-bottom-10"><div class="form-text invisible">&nbsp;</div></div>', 
            prefix, repeat_label, prefix)
    }

// construct position html
    var position_html = sprintf('\
        <div id="%s_prompt" class="col-xs-12 margin-bottom-10"><div class="form-text auto-height invisible">%s</div></div>%s\
        <div id="%s_top" class="col-xs-12"><div class="form-label">&nbsp;</div></div>\
        <div id="%s_middle" class="col-xs-12 margin-bottom-5"><div class="form-input invisible">&nbsp;</div></div>\
        <div id="%s_bottom" class="col-xs-12 margin-bottom-10"><div class="form-label">&nbsp;</div></div>',
        prefix, prompt, repeat_insert, prefix, prefix, prefix)

// construct prompt html
    if (prompt) {
        var prompt_html = sprintf('<div id="%s_msg_text" class="form-text auto-height text-wrap">%s</div>', prefix, prompt)
    }

// construct repeat html
    var repeat_input_selector = ''
    if (repeat_insert){
        var repeat_label_html = sprintf('<div id="%s_top_repeat_text" class="form-label bold">%s:</div>', prefix, repeat_label)
        var repeat_input_html = sprintf('\
            <form id="%s_form_repeat" title="%s">\
                <div id="%s_form_row_repeat" class="row">\
                    <div id="%s_form_left_repeat" class="col-xs-12">\
                        <label id="%s_form_label_repeat" for="%s_input_repeat" class="sr-only">%s</label>\
                        <input id="%s_input_repeat" type="%s" placeholder="%s" autofocus class="form-input">\
                    </div>\
                </div>\
            </form>',
            prefix, repeat_label, 
            prefix, prefix,
            prefix, prefix, repeat_label,
            prefix, type, repeat_placeholder)
        repeat_input_selector = '#' + prefix + '_input_repeat' 
    }
 
// construct honeypot html
    var honeypot_input_selector = ''
    var honeypot_input_html = ''
    if (honeypot_label){
        var honeypot_input_html = sprintf('\
            <div id="%s_form_row" class="row" style="display:none">\
                <div id="%s_form_left" class="col-xs-12">\
                    <label id="%s_form_label" for="%s_input" class="sr-only">%s</label>\
                    <input id="%s_input" type="%s" placeholder="%s" class="form-input">\
                </div>\
            </div>',
            honeypot_prefix, honeypot_prefix,
            honeypot_prefix, honeypot_prefix, honeypot_label,
            honeypot_prefix, honeypot_type, placeholder)
        honeypot_input_selector = '#' + honeypot_prefix + '_input' 
    }
    
// construct label html
    if (label){
        var label_html = sprintf('<div id="%s_top_text" class="form-label bold">%s:</div>', prefix, label)
    }

// construct input html
    if (type){
        var autofocus_attr = ' autofocus'
        if (repeat_insert) {
            autofocus_attr = ''
        }
        var input_html = sprintf('\
            <form id="%s_form" title="%s">\
                <div id="%s_form_row" class="row">\
                    <div id="%s_form_left" class="col-lg-11 col-md-11 col-sm-11 col-xs-10 padding-right-0">\
                        <label id="%s_form_label" for="%s_input" class="sr-only">%s</label>\
                        <input id="%s_input" type="%s" placeholder="%s"%s class="form-input">\
                    </div>\
                    <div id="%s_form_right" class="col-lg-1 col-md-1 col-sm-1 col-xs-2 text-right padding-left-0">\
                        <div id="%s_status" class="form-input">\
                            <span id="%s_status_error" class="icon-ban icon-error icon-overlay" style="display: none;"></span>\
                            <span id="%s_status_submit" class="icon-arrow-right-circle icon-success"></span>\
                        </div>\
                    </div>\
                </div>%s\
            </form>', 
            prefix, label,
            prefix, prefix,
            prefix, prefix, label,
            prefix, type, placeholder, autofocus_attr,
            prefix, prefix, prefix, prefix, honeypot_input_html)
    }
    
// construct options html
    if (options) {
        var options_html = sprintf('<div id="%s_bottom_row" class="row"></div>', prefix)
    }

// define selectors
    var prompt_selector = sprintf('#%s_prompt', prefix)
    var top_selector = sprintf('#%s_top', prefix)
    var middle_selector = sprintf('#%s_middle', prefix)
    var bottom_selector = sprintf('#%s_bottom', prefix)
    if (repeat_insert){
        var repeat_top_selector = sprintf('#%s_top_repeat', prefix)
        var repeat_middle_selector = sprintf('#%s_middle_repeat', prefix)
    }

// inject position html into DOM 
    if (!box_selector){
        box_selector = '#input_box'
    }
    $(box_selector).html(position_html)
    
// inject prompt field
    var prompt_delay = 0
    if (prompt) {
        prompt_delay = 300
        $(prompt_selector).html(prompt_html).hide().fadeIn(600)
    }

// inject repeat fields
    if (repeat_insert) {
        setTimeout(function(){
            $(repeat_top_selector).html(repeat_label_html).hide().fadeIn(600)
            $(repeat_middle_selector).html(repeat_input_html).hide().fadeIn(600)
            $(repeat_input_selector).focus()
        })
    }
    
// inject label field
    if (label) {
        setTimeout(function(){
            $(top_selector).html(label_html).hide().fadeIn(600)
        }, prompt_delay)   
    }

// inject input field
    if (type) {
        setTimeout(function(){ 
  
        // inject html
            $(middle_selector).html(input_html).hide().fadeIn(600)
        
        // define input selectors
            var input_selector = sprintf('#%s_input', prefix)
            var error_selector = sprintf('#%s_status_error', prefix)
            var submit_selector = sprintf('#%s_status_submit', prefix)
        
        // add repeat check to criteria
            if (repeat_input_selector){
            
                criteria['identical_to'] = {}
                criteria['identical_to'][repeat_input_selector] = sprintf('does not match %s.', repeat_label)
        
        // add autofocus on input 
            } else {
                $(input_selector).focus()
            }
            
        // create callback method with promise
            var input_callback = function(input_value){
                var promise_inputs = [ input_value ]
                if (honeypot_label){
                    var honeypot_value = $(honeypot_input_selector).val()
                    promise_inputs.push(honeypot_value)
                }
                if (promise_args){
                    for (var i=0; i < promise_args.length; i++){
                        promise_inputs.push(promise_args[i])
                    }
                }
                promise(...promise_inputs).then(success, function(error_message){
                                  
            // show error message
                    var msg_kwargs = {
                        'anchor_selector': input_selector,
                        'message_text': error_message,
                        'message_status': 'error',
                        'message_location': 'bottom',
                        'timeout': 5000
                    }
                    showMessage(msg_kwargs)
                    $(input_selector).val('')
                    $(input_selector).focus()
                    
                })
            }
            
        // bind input listeners
            var hidden_title = ''
            if (type == 'password'){
                hidden_title = 'Password'
            }
            inputHandler(input_selector, title, criteria, input_callback, enter_submit=true, auto_save=false, hidden_title=hidden_title)
            statusButtonHandler(input_selector, error_selector, submit_selector, title, criteria, input_callback, hidden_title=hidden_title)
            
        }, prompt_delay)
    }

// determine input delay
    var input_delay = prompt_delay
    if (type || label){
        input_delay = prompt_delay + 300
    }
     
// add options to DOM
    if (options) {
        setTimeout(function(){
            $(bottom_selector).html(options_html).hide()
            var options_selector = '#' + prefix + '_bottom'
            var options_row_selector = '#' + prefix + '_bottom_row'
            var options_width = 12
            if (options.length == 2) { options_width = 6 }
            else if (options.length == 3) { options_width = 4 }
            for (var i=0; i < options.length; i++){
                if (i > 2){ break }
                const option_name = ingestString(options[i].name)
                const option_onclick = ingestString(options[i].onclick)
                const option_label = ingestString(options[i].label)
                const option_args = ingestArray(options[i].args)
                const option_selector = sprintf('#%s_options_%s_link', prefix, i)
                const option_html = sprintf('\
                    <div id="%s_options_%s" class="col-xs-%s">\
                        <a id="%s_options_%s_link" title="%s" class="form-label text-left">%s</a>\
                    </div>', prefix, i, options_width,
                    prefix, i, option_label, option_name)
                $(option_html).appendTo(options_row_selector)
                bindFunction(option_selector, option_onclick, option_args)
            }
            $(options_selector).fadeIn(600)
        }, input_delay)
    }
    
}

function confirmationView(confirm_kwargs) {

/* a function to construct a confirmation message view */

// ingest variables
    var box_selector = ingestString(confirm_kwargs.selector)
    var title = ingestString(confirm_kwargs.title)
    var prefix = title.toLowerCase().replace(/\s/g, '_')
    var prompt = ingestString(confirm_kwargs.prompt)
    var label = ingestString(confirm_kwargs.label)
    var options = ingestArray(confirm_kwargs.options)
    
// construct html
    var prompt_insert = '&nbsp;'
    if (prompt){ prompt_insert = prompt}
    var label_insert = '&nbsp;'
    if (label){ label_insert = label}
    var position_html = sprintf('\
        <div id="%s_top" class="col-xs-12 margin-bottom-10"><div class="form-text auto-height invisible">%s</div></div>\
        <div id="%s_middle" class="col-xs-12 margin-bottom-10"><div class="form-label bold auto-height invisible">%s</div></div>\
        <div id="%s_bottom" class="col-xs-12 margin-bottom-10"><div class="form-label invisible">&nbsp;</div></div>',
        prefix, prompt_insert, prefix, label_insert, prefix)

// define selectors
    var top_selector = sprintf('#%s_top', prefix)
    var middle_selector = sprintf('#%s_middle', prefix)
    var bottom_selector = sprintf('#%s_bottom', prefix)
    
// inject position html into DOM 
    if (!box_selector){
        box_selector = '#input_box'
    }
    $(box_selector).html(position_html)

// inject prompt field
    var prompt_delay = 0
    if (prompt) {
        prompt_delay = 300
        var prompt_html = sprintf('<div id="%s_top_text" class="form-text auto-height">%s</div>', prefix, prompt)
        $(top_selector).html(prompt_html).hide().fadeIn(600)
    }
    
// inject label field
    var label_delay = prompt_delay
    if (label) {
        label_delay = prompt_delay + 300
        var label_html = sprintf('<div id="%s_middle_text" class="form-label bold auto-height word-wrap">%s</div>', prefix, label)
        setTimeout(function(){
            $(middle_selector).html(label_html).hide().fadeIn(600)
        }, prompt_delay)   
    }
     
// add options to DOM
    if (options) {
        setTimeout(function(){
            var options_html = sprintf('<div id="%s_bottom_row" class="row"></div>', prefix)
            $(bottom_selector).html(options_html).hide()
            var options_selector = '#' + prefix + '_bottom'
            var options_row_selector = '#' + prefix + '_bottom_row'
            var options_width = 12
            if (options.length == 2) { options_width = 6 }
            else if (options.length == 3) { options_width = 4 }
            for (var i=0; i < options.length; i++){
                if (i > 2){ break }
                const option_name = ingestString(options[i].name)
                const option_onclick = ingestString(options[i].onclick)
                const option_label = ingestString(options[i].label)
                const option_args = ingestArray(options[i].args)
                const option_selector = sprintf('#%s_options_%s_link', prefix, i)
                const option_html = sprintf('\
                    <div id="%s_options_%s" class="col-xs-%s">\
                        <a id="%s_options_%s_link" title="%s" class="form-label text-left word-wrap">%s</a>\
                    </div>', prefix, i, options_width,
                    prefix, i, option_label, option_name)
                $(option_html).appendTo(options_row_selector)
                bindFunction(option_selector, option_onclick, option_args)
            }
            $(options_selector).fadeIn(600)
        }, label_delay)
    }
    
}

function tableView(container_id, item_list, header_list, end=false) {

// a method to create a list of items as a responsive table

// determine variables
    const table_selector = '#' + container_id
    const mobile_selector = table_selector + '_mobile'
    const desktop_selector = table_selector + '_desktop'
    const tbody_selector = table_selector + '_tbody'
    var table_col = []
    var previous_items = 0
    
// construct responsive container html
    if (!($(mobile_selector).length)){
        var responsive_content = sprintf('\
            <div id="%s_mobile" class="hidden-lg hidden-md hidden-sm col-xs-12 mobile-table"></div>\
            <div id="%s_desktop" class="col-lg-12 col-md-12 col-sm-12 hidden-xs"></div>',
            container_id, container_id)
        $(table_selector).html(responsive_content)
        
    // construct table html
        var table_frame = '<table class="table"><thead class=""><tr>'
    
    // add headers
        for (var i = 0; i < header_list.length; i++){
            for (var key in header_list[i]){
                table_col.push(key)
                table_frame += '<th>' + header_list[i][key] + '</th>'
            }
        }
        
    // close table
        table_frame += sprintf('</tr></thead><tbody id="%s_tbody"></tbody></table>', container_id)
    
    // add table to desktop
        $(desktop_selector).html(table_frame)
        
    } else {
        
        for (var i = 0; i < header_list.length; i++){
            for (var key in header_list[i]){
                table_col.push(key)
            }
        }
        $(mobile_selector).find('> section').each(function(i, section){
            previous_items += 1
        })
        
    }
    
// add items
    for (var i = 0; i < item_list.length; i++){
        
        var item_html = '<tr>'
    
    // add section to mobile
        if (i < item_list.length - 1 || !end){
            $('<section class="row section-row"></section>').appendTo($(mobile_selector))
        } else {
            $('<section class="row section-last"></section>').appendTo($(mobile_selector))
        }
        mobile_col_selector = mobile_selector + ' section:nth-child(' + (i + 1 + previous_items).toString() + ')'
        
        for (var j = 0; j < table_col.length; j++){
            var key_name = table_col[j]
            var cell_value = '&nbsp;'
            if (key_name in item_list[i]){
                cell_value = item_list[i][key_name]
            }
            item_html += '<td>' + cell_value + '</td>'
            
        // add columns to mobile
            var key_title = header_list[j][key_name]
            var column_html = sprintf('<div class="col-xs-12 margin-vertical-5"><div class="col-xs-4 padding-left-0 bold">%s:</div><div class="col-xs-8 padding-right-0 text-right">%s</div></div>', key_title, cell_value)
            $(column_html).appendTo($(mobile_col_selector))
            
        }
        
    // add row to desktop
        item_html += '</tr>'
        $(item_html).appendTo($(tbody_selector))
        
    }
    
}

function loginView() {

/* a method to construct the login view */

// retrieve criteria map
    loadingSchema('lab_criteria').then(function(criteria_map){
        
    // change page title
        var title_kwargs = {
            'app_subtitle': 'Login to the Laboratory',
            'page_title': 'Account Login',
            'page_subtitle': 'Login to the Laboratory'
        }
        updateTitle(title_kwargs)
    
    // construct login fields
        var input_kwargs = {
            selector: '#input_box',
            title: 'Account Login',
            label: 'Email Address',
            prompt: 'Login to the Laboratory',
            type: 'text',
            promise: puttingSession,
            success: function(session_token, account_email, confirm_status){
                if (confirm_status){
                    console.log('Account has not been confirmed.')
                    confirmWaitView(account_email)
                } else {
                    passwordView(account_email)
                }
            },
            placeholder: 'satoshi@bitcoin.org',
            options: [ {
                name: 'Create an Account',
                label: 'Create a New Account',
                onclick: 'signupView'     
            }],
            criteria: criteria_map['email_address']
        }
        inputView(input_kwargs)
    
    })
   
}

function passwordView(account_email) {
    
/* a method to construct the password view */

// verify client history in window   
    if (!('client_history' in window)){
        window.client_history = []
    }

// retrieve criteria map
    loadingSchema('lab_criteria').then(function(criteria_map){
    
    // construct login fields
        var input_kwargs = {
            selector: '#input_box',
            title: 'Account Password',
            label: 'Account Password',
            prompt: 'Hi, ' + account_email,
            type: 'password',
            promise: postingSession,
            success: function(session_token, account_active){
                showTitle()
                showDashboard()
                if (!account_active){
                    openAccount()
                } else if (window.client_history.length){
                    var last_index = window.client_history.length - 1
                    var func = window.client_history[last_index].func
                    var args = ingestArray(window.client_history[last_index].args)
                    if (args){
                        func(...args)
                    } else {
                        func()
                    }
                } else {
                    logConsole('fresh')
                    openDashboard()
                }
            },
            placeholder: '&#8226;&#8226;&#8226;&#8226;&#8226;&#8226;&#8226;&#8226;',
            options: [ {
                name: 'Forgot Password?',
                label: 'Reset your Password',
                onclick: 'resetView',
                args: [ account_email ]    
            },
            {
                name: 'Change Account',
                label: 'Use a Different Account',
                onclick: 'loginView'
            }],
            criteria: criteria_map['account_password']
        }
        inputView(input_kwargs)
    
    })
    
}

function signupView() {
    
/* a function to construct the signup view */

// retrieve criteria map
    loadingSchema('lab_criteria').then(function(criteria_map){
    
    // change page title
        var title_kwargs = {
            'app_subtitle': 'Signup for Laboratory Access',
            'page_title': 'Account Signup',
            'page_subtitle': 'Signup for Laboratory Access'
        }
        updateTitle(title_kwargs)
            
    // construct signin fields
        var input_kwargs = {
            selector: '#input_box',
            title: 'Account Email',
            label: 'Account Email',
            prompt: 'Signup for Laboratory Access',
            type: 'text',
            promise: puttingAccount,
            success: function(session_token, account_email){
                confirmWaitView(account_email)
            },
            placeholder: 'satoshi@bitcoin.org',
            options: [ {
                name: 'Login to Account',
                label: 'Login to the Laboratory',
                onclick: 'loginView'     
            },
            {
                name: 'Lab Protocols',
                label: 'Protocols for Laboratory Access',
                onclick: 'loadingSchema',
                args: [ 'lab_protocols', 'itemizedDialog' ]
            }
            ],
            honeypot_label: 'Account Password',
            honeypot_type: 'password',
            criteria: criteria_map['email_address']
        }
        inputView(input_kwargs)
    
    })
    
}

function confirmWaitView(account_email) {
    
// change page title
    var title_kwargs = {
        'app_subtitle': 'Signup for Laboratory Access',
        'page_title': 'Account Confirmation',
        'page_subtitle': 'Waiting for Account Confirmation'
    }
    updateTitle(title_kwargs)

// construct confirmation fields
    var input_kwargs = {
        selector: '#input_box',
        title: 'Account Confirmation',
        label: 'A confirmation link has been sent to your email at ' + account_email,
        prompt: 'Check your Email!',
        type: '',
        promise: null,
        success: null,
        placeholder: '',
        options: [ {
            name: 'Resend Confirmation',
            label: 'Resend Email to Confirm Account',
            onclick: 'resendConfirmation',
            args: [ account_email ]     
        },
        {
            name: 'Change Account',
            label: 'Use a Different Account',
            onclick: 'loginView'
        } ]
    }
    inputView(input_kwargs)

// add listener for session token and open dashboard
    var confirm_listener = setInterval(function(){
        var gateway_auth = ingestMap(loadRecord('gateway_auth'))
        if (mapSize(gateway_auth)){
            startingPouchDB().done(function(){
                clearInterval(confirm_listener)
                showTitle()
                showDashboard()
                if (window.client_history){
                    var last_index = window.client_history.length - 1
                    var func = window.client_history[last_index].func
                    var args = ingestArray(window.client_history[last_index].args)
                    if (args){
                        func(...args)
                    } else {
                        func()
                    }
                } else {
                    logConsole('fresh')
                    openDashboard()
                }
            })
        }
//        var request_kwargs = {
//            method: 'GET',
//            route: '/records/oauth2-services'
//        }
//        var resource_promise = requestingResource(request_kwargs)
//        resource_promise.done(function(){
//            clearInterval(confirm_listener)
//            showTitle()
//            showDashboard()
//            if (window.client_history){
//                var last_index = window.client_history.length - 1
//                var func = window.client_history[last_index].func
//                var args = ingestArray(window.client_history[last_index].args)
//                if (args){
//                    func(...args)
//                } else {
//                    func()
//                }
//            } else {
//                logConsole('fresh')
//                openDashboard()
//            }
//        })
    }, 5000)

}

function resendConfirmation(account_email) {

/* a method to resend a confirmation email */

// send promise request to reset endpoint
    var request_promise = postingAccount(account_email, 'resend')
    request_promise.done(function(){
        var dialog_options = {
            title: 'Email Sent!',
            body: sprintf('<p>A new confirmation link has been sent to your email at %s</p>', account_email)
        }
        flexibleDialog(dialog_options)
    })
    request_promise.fail(function(msg){
        var resend_selector = '#account_confirmation_options_0_link'
        const _error_kwargs = {
            anchor_selector: resend_selector,
            message_text: msg,
            message_status: 'error',
            timeout: 5000
        }
        showMessage(_error_kwargs)
    })
    request_promise.always(function(){
        var resend_selector = '#account_confirmation_options_0_link'
        convertElement(resend_selector, 'span')
        $(resend_selector).off()
    })
     
}

function resetView(account_email) {

/* a method to display the reset password view */

// retrieve criteria map
    loadingSchema('lab_criteria').then(function(criteria_map){
    
    // change page title
        var title_kwargs = {
            'app_subtitle': 'Login to the Laboratory',
            'page_title': 'Password Reset',
            'page_subtitle': 'Reset Account Password'
        }
        updateTitle(title_kwargs)
    
    // construct reset fields
        var input_kwargs = {
            selector: '#input_box',
            title: 'Account Email',
            label: 'Email Address',
            prompt: 'Type Your Email to Reset',
            type: 'type',
            promise: postingAccount,
            promise_args: [ 'reset' ],
            success: function(session_token, account_email){
                resetWaitView(account_email)
            },
            placeholder: 'satoshi@bitcoin.org',
            options: [ {
                name: 'Change Account',
                label: 'Use a Different Account',
                onclick: 'loginView'
            } ],
            criteria: deepCopy(criteria_map['email_address'])
        }
    
    // add comparison
        input_kwargs['criteria']['equal_to'] = { 
            account_email: 'does not match cached address.'
        }
    
    // construct view
        inputView(input_kwargs)
    
    })
    
}

function resetWaitView(account_email) {

/* a method to construct a view for waiting for a password reset response */

// change page title
    var title_kwargs = {
        'app_subtitle': 'Login to the Laboratory',
        'page_title': 'Password Reset',
        'page_subtitle': 'Waiting for Password Reset'
    }
    updateTitle(title_kwargs)

// construct confirmation fields
    var confirmation_kwargs = {
        selector: '#input_box',
        title: 'Password Reset',
        label: 'A link to reset your password has been sent to your email at ' + account_email,
        prompt: 'Check your Email!',
        options: [ {
            name: 'Change Account',
            label: 'Use a Different Account',
            onclick: 'loginView'
        } ]
    }
    confirmationView(confirmation_kwargs)

// add listener for session token and open dashboard
    var reset_listener = setInterval(function(){
        var request_kwargs = {
            method: 'GET',
            route: '/records/oauth2-services'
        }
        var resource_promise = requestingResource(request_kwargs)
        resource_promise.done(function(){
            clearInterval(reset_listener)
            showTitle()
            showDashboard()
            if (window.client_history){
                var last_index = window.client_history.length - 1
                var func = window.client_history[last_index].func
                var args = ingestArray(window.client_history[last_index].args)
                if (args){
                    func(...args)
                } else {
                    func()
                }
            } else {
                logConsole('fresh')
                openDashboard()
            }
        })
    }, 5000)
    
}

function updateView(account_action, account_token) {
    
/* a method to construct a view to handle token based account password updates */

// retrieve criteria map
    loadingSchema('lab_criteria').then(function(criteria_map){
    
    // change page title
        var title_kwargs = {
            'app_subtitle': 'Signup for Laboratory Access',
            'page_title': 'Account Signup',
            'page_subtitle': 'Create your Password'
        }
        if (account_action == 'reset'){
            title_kwargs['app_subtitle'] = 'Login to the Laboratory'
            title_kwargs['page_title'] = 'Password Reset'
            title_kwargs['page_subtitle'] = 'Reset your Password'
        }
        updateTitle(title_kwargs)
        
    // construct login fields
        var input_kwargs = {
            selector: '#input_box',
            title: 'Account Password',
            label: 'Confirm Password',
            repeat_label: 'New Password',
            prompt: 'Create a Password to Finish Signup Process',
            type: 'password',
            promise: patchingAccount,
            promise_args: [ '', account_token ],
            success: function(session_token){
                updateSuccessView(account_action)
            },
            placeholder: '&#8226;&#8226;&#8226;&#8226;&#8226;&#8226;&#8226;&#8226;',
            repeat_placeholder: '&#8226;&#8226;&#8226;&#8226;&#8226;&#8226;&#8226;&#8226;',
            options: [ {
                name: 'Change Account',
                label: 'Use a Different Account',
                onclick: 'loginView'
            } ],
            criteria: criteria_map['account_password']
        }
    
    // adjust labels
        if (account_action == 'reset'){
            input_kwargs['prompt'] = 'Create a New Password to Finish Reset Process'
        }
     
    // construct input view
        inputView(input_kwargs)
    
    })
    
}

function updateSuccessView(account_action) {

/* a method to create the successful password update view */

// change page title
    var title_kwargs = {
        'app_subtitle': 'Signup for Laboratory Access',
        'page_title': 'Account Signup',
        'page_subtitle': 'Create your Password'
    }
    if (account_action == 'reset'){
        title_kwargs['app_subtitle'] = 'Login to the Laboratory'
        title_kwargs['page_title'] = 'Reset Confirmation'
        title_kwargs['page_subtitle'] = 'Reset your Password'
    }
    updateTitle(title_kwargs)

// construct confirmation fields
    var confirmation_kwargs = {
        selector: '#input_box',
        title: 'Account Password',
        prompt: 'Sweet! Account Setup Complete.',
        label: 'You can now link third-party services and access laboratory experiments.',
        options: [ {
            name: 'Open Lab',
            label: 'Click to Open Laboratory',
            onclick: 'openLab'
        } ]
    }

// alter message for reset
    if (account_action == 'reset'){
        confirmation_kwargs['prompt'] = 'Sweet! Password Reset Complete.'
        confirmation_kwargs['label'] = 'You can now access the laboratory using your new password.'
    }
    
// construct input view
    confirmationView(confirmation_kwargs)
    
}

function reportView(account_token) {

/* a function to process a behavior report */

// change page title
    var title_kwargs = {
        'app_subtitle': 'Report Behavior',
        'page_title': 'Report Confirmation',
        'page_subtitle': 'Confirmation of Reported Behavior'
    }
    updateTitle(title_kwargs)

// define success function
    function _report_success(response){

    // TODO add details from server to view
    
    // construct confirmation fields
        var confirmation_kwargs = {
            selector: '#input_box',
            title: 'Behavior Report',
            prompt: 'Thank You! Reported Abuse Recorded.',
            label: 'Reporting activity on your account which you did not perform helps the lab identify unusual behavior and keep your account safe.',
            options: [ {
                name: 'Open Lab',
                label: 'Click to Open Laboratory',
                onclick: 'openLab'
            } ]
        }
        
    // construct confirmation view
        confirmationView(confirmation_kwargs)
        
    }

// send request to report route
    var request_kwargs = {
        method: 'PUT',
        route: '/report',
        body: { 'account_token': account_token }
    }
    requestingResource(request_kwargs).always(_report_success)

}

function oauth2CallbackView(service_details) {

/* a method to construct the view after a successful oauth2 callback */

// construct title message
    var service_title = service_details['service_title'] + ' Connected'
    
// change page title
    var title_kwargs = {
        'app_subtitle': service_title
    }
    updateTitle(title_kwargs)

// construct confirmation fields
    var confirmation_kwargs = {
        selector: '#input_box',
        title: service_title,
        prompt: sprintf('Sweet! Your laboratory experiments are now connected to %s.', service_details['service_title']),
        label: 'Closing in 10...',
        options: [ {
            name: 'Close Now',
            label: 'Click to Close Window',
            onclick: 'close'  
        } ]
    }
        
// construct confirmation view
    confirmationView(confirmation_kwargs)

// set count down interval
    var count = 9
    var label_selector = sprintf('#%s_middle_text', service_title.toLowerCase().replace(/\s/g, '_'))
    var countdown_waiter = setInterval(function() {
        if (count > 0) {
            var closing_text = sprintf('Closing in %s...', count)
            $(label_selector).text(closing_text)
            count -= 1
        } else {
            clearInterval(countdown_waiter)
        }
    }, 1000)

}

function overloadView() {

/* TODO a way of handling usage limits on server */

}

function integrationsView(tokens_db, tokens_remote, service_map, token_map) {

/* a method to display the service integrations of user */

// construct list of categories
    var service_list = []
    var service_tags = {}
    var service_latest = []
    service_map = ingestMap(service_map)
    for (var key in service_map){
        var schema = service_map[key]
        service_latest.push({'name': key, 'date': ingestNumber(schema.service_added), 'type': 'oauth2' })
        for (var i = 0; i < ingestArray(schema.service_tags).length; i++) {
            if ($.inArray(schema.service_tags[i], service_list) == -1) {
                service_list.push(schema.service_tags[i])
                service_tags[schema.service_tags[i]] = []
            }
            service_tags[schema.service_tags[i]].push(key)
        }
    }

// sort collections
    service_latest.sort(function(a, b){
        return b.date - a.date
    })
    service_list.sort()
    service_list.unshift('Latest')
    if($.inArray('Important', service_list) > -1){
        service_list.splice($.inArray('Important', service_list), 1)
        service_list.unshift('Important')
    }
    for (var key in service_tags){
        service_tags[key].sort()
    }

// toggle integrations container
    var record_key = 'service_integrations'
    var container_selector = '#service_integrations_content_container'
    var container_html = '<div id="service_integrations_content_container" class="container content-container-scroll"></div>'
    toggleView(container_selector, container_html)
    
// inject settings view frame into container
    var frame_html = sprintf('\
        <div id="service_integrations_content_row" class="row">\
            <div id="service_integrations_content_column_index" class="col-sm-3 hidden-xs">\
                <div id="service_integrations_index_section" class="section-last">\
                    <div id="service_integrations_index_section_title" class="form-line">\
                        <div id="service_integrations_index_section_title_text" class="form-text no-wrap bold" title="Integration Categories">Categories</div>\
                    </div>\
                </div>\
            </div>\
            <div id="service_integrations_content_column_main" class="col-sm-9 col-xs-12">\
                <div id="service_integrations_content_column_main_body">\
                </div>\
            </div>\
        </div>'
    )
    $(container_selector).html(frame_html)

// construct empty listener groups
    var permission_groups = {}
    var contact_groups = {}
    var software_groups = {}
    var login_groups = {}

// define permission container
    function _construct_permission(scope_selector, service_id, permission_details, access_scope){
    
        const _scope_service = permission_details.service
        const _scope_description = permission_details.description
        const _scope_title = permission_details.title
        const _scope_name = _scope_title.toLowerCase().replace(/\s/g, '_')
        const _scope_id = sprintf('%s_%s_%s', service_id, _scope_service, _scope_name)
        const _scope_experiments = ingestArray(permission_details.experiments)
        const _input_id = _scope_id + '_input'
        const _scope_permit = permission_details.scope
        
    // add input selector to permission groups
        if (!(_scope_permit in permission_groups)){
            permission_groups[_scope_permit] = []
        }
        permission_groups[_scope_permit].push({
            'selector': '#' + _input_id,
            'service': _scope_service
        })
    
    // construct connected html
        var _scope_checked = ''
        var _scope_icon = 'icon-plus icon-hyperlink font-sm'
        if (access_scope.indexOf(_scope_permit) > -1){
            _scope_checked = ' checked'
            _scope_icon = 'icon-check icon-success font-sm'
        }
    
    // construct experiment links
        var _exp_links = []
        var _experiments_html = ''
        if (_scope_experiments.length){
            _experiments_html = ' Integrates with: '
            for (var exp = 0; exp < _scope_experiments.length; exp++){
                var _exp_title = _scope_experiments[exp].title
                var _exp_url = ingestString(_scope_experiments[exp].url)
                var _exp_name = _exp_title.toLowerCase().replace(/\s/g, '_')
                var _exp_id = _scope_id + '_exp_' + _exp_name
                var _exp_func = ''
                var _url_html = ''
                if (_exp_url.indexOf('http') == 0){
                    _url_html = sprintf(' href="%s"', _exp_url) 
                } else {
                    _exp_func = deepCopy(_exp_url)
                }
                if (exp){
                    _experiments_html += ', '
                }
                _experiments_html += sprintf('<a%s id="%s">%s</a>', _url_html, _exp_id, _exp_title)
                if (_exp_func){
                    const _exp_link_selector = '#' + _exp_id
                    _exp_links.push({
                        selector: _exp_link_selector,
                        func: _exp_func
                    })
                }
            }
        }
        
    // construct service html
        var _scope_html = sprintf('\
            <div id="%s_container" class="col-xs-12">\
                <div id="%s_row" class="row">\
                    <div class="col-xs-2"></div>\
                    <div id="%s_left" class="col-xs-1">\
                        <div id="%s" class="%s"></div>\
                    </div>\
                    <div id="%s_right" class="col-xs-9">\
                        <div id="%s_title" class="form-text text-left">%s</div>\
                    </div>\
                </div>\
                <div class="row">\
                    <div class="col-xs-3"></div>\
                    <div id="%s_bottom" class="col-xs-9">\
                        <div id="%s_desc" class="form-label text-left text-wrap auto-height margin-vertical-5">%s%s</div>\
                    </div>\
                </div>\
            </div>',
            _scope_id, _scope_id, _scope_id, _input_id, _scope_icon,
            _scope_id, _scope_id, _scope_title,
            _scope_id, _scope_id, _scope_description, _experiments_html
        )
        $(scope_selector).append(_scope_html)
    
    // add link listeners
        for (var i = 0; i < _exp_links.length; i++){
            const _exp_link_selector = _exp_links[i].selector
            const _exp_func = _exp_links[i].func
            $(_exp_link_selector).on('click', function(e){
                callFunction(_exp_func)
            })
        }
        
    }
    
// define permission connector
    function _update_permission(input_value, service_name, service_scope, selector_list){
    
    // TODO fix auto scroll to top problem on oauth2 callback
        // var scroll_height = $('html, body').scrollTop()
        
    // define selector update function
        function _update_selectors(access_scope){
        
            var scroll_height = $('html, body').scrollTop()
            for (var i = 0; i < selector_list.length; i++){
                const _input_params = selector_list[i]
                if ($(_input_params.selector).length){
                    if (access_scope.indexOf(service_scope) > -1){
                        $(_input_params.selector).attr('class', 'icon-check icon-success font-sm')
                    } else {
                        $(_input_params.selector).attr('class', 'icon-plus icon-hyperlink font-sm')
                    }
                }
            }
            // $('html, body').animate({ scrollTop: scroll_height }, 1)

        }
            
    // define error handler function
        function _handle_error(msg){
        
            if (msg == 'sync fail'){
                
                _update_selectors(service_scope)
                
            } else {
                for (var i = 0; i < selector_list.length; i++){
                    const _input_params = selector_list[i]
                    if ($(_input_params.selector).length){
                        const _error_kwargs = {
                            anchor_selector: _input_params.selector,
                            message_text: msg,
                            message_status: 'error',
                            timeout: 5000
                        }
                        showMessage(_error_kwargs)
                    }
                }
            }
            
        }
    
    // enable connection
        if (input_value){
              
        // open oauth2 window
            var oauth2_promise = retrievingOAuthToken(service_name, service_scope)
            
        // handle oauth2 success
            oauth2_promise.done(function(token_details){
                _update_selectors(token_details.service_scope)
            })
            
        // handle oauth2 error
            oauth2_promise.fail(function(msg){ 
                logConsole(msg)
                _handle_error(msg) 
            })
            
        } 
    
    // disable connection
        else {
        
        // retrieve existing token from bucket
            tokens_db.find({
                selector: { service_name: service_name },
                use_index: 'service_name'
            }).then(function(result){
            
            // construct default new scope
                var reduced_scope = ''
                
            // validate existence of token
                if (result.docs.length){
                
                    var token_details = result.docs[0]
                
                // determine existing scopes    
                    var existing_scopes = []
                    const existing_scope = token_details.service_scope
                    if (existing_scope){
                        existing_scopes = existing_scope.split(' ')              
                    }
                    
                // determine updated scopes
                    var update_scopes = []
                    for (var i = 0; i < existing_scopes.length; i++){
                        if (existing_scopes[i] != service_scope){
                            update_scopes.push(existing_scopes[i])
                        }
                    }
            
                // determine new scope
                    if (update_scopes){
                        if (update_scopes.length == 1){
                            reduced_scope = update_scopes[0]
                        } else {
                            reduced_scope = update_scopes.join(' ')
                        }
                    }
                
                // token update array
                    var token_updates = []
                    
                // update token or remove token if no scopes remaining
                    if (reduced_scope){
                        token_details.service_scope = reduced_scope
                        token_updates.push(tokens_db.put(token_details))
                    } else {
                        token_updates.push(tokens_db.remove(token_details))
                    }
                
                // remove extra tokens
                    if (result.docs.length > 1){
                        for (var i = 1; i < result.docs.length; i++){
                            const _token_details = result.docs[i]
                            token_updates.push(tokens_db.remove(_token_details))
                        }
                    }
                
                // synchronize changes
                    if (token_updates){
                        $.when(...token_updates).then(function(){
                            tokens_db.sync(tokens_remote).then(function(result){
                                logConsole(service_name + ' scopes updated')
                            })
                        })
                    }
                    
                }
                
            // update view
                _update_selectors(reduced_scope)

            })
            
        } 
        
    }
   
// define service container
    function _construct_service(category_selector, service_id, service_details, access_token='', access_scope=''){
    
    // declare method variables
        const _service_selector = '#' + service_id
        const _logo = service_details.service_logo
        const _url = ingestString(service_details.service_url)
        const _input_id = service_id + '_input'
        const _title = service_details.service_title
        const _description = injectLinks(service_details.service_description)
        const _org = service_details.service_organization
        const _scopes = ingestArray(service_details.service_scopes)

    // construct connected field
        var _connected_html = ''
        if (access_token){
            _connected_html = ' checked'
        }
    
    // construct link html
        var _link_html = _org
        if (_url){
            var _link_html = sprintf('<a id="%s_organization_link" href="%s" target="_blank">%s</a>', service_id, _url, _org)
        }
        
    // construct service html
        var _service_html = sprintf('\
            <div id="%s_container" class="col-lg-6 col-md-6 col-sm-12 col-xs-12">\
                <div id="%s_details" class="row">\
                    <div id="%s_left" class="col-xs-3">\
                        <img src="%s" class="icon-mega">\
                    </div>\
                    <div id="%s_right" class="col-xs-9">\
                        <div class="row">\
                            <div id="%s_title" class="col-xs-12 form-text text-left bold margin-bottom-5">%s</div>\
                        </div>\
                        <div class="row">\
                            <div id="%s_organization" class="col-xs-12 form-label text-left margin-bottom-5">by %s</div>\
                        </div>\
                        <div class="row">\
                            <div id="%s_description" class="col-xs-12 form-label text-left text-wrap auto-height margin-bottom-5">%s</div>\
                        </div>\
                    </div>\
                </div>\
                <!-- <div id="%s_label" class="row margin-bottom-5">\
                    <div class="col-xs-3"></div>\
                    <div id="%s_label_text" class="col-xs-9 form-label bold text-left">Supports the following permissions:</div>\
                </div> -->\
                <div id="%s_scopes" class="row margin-bottom-10 auto-height">\
                </div\
            </div>',
            service_id, service_id, service_id, _logo, service_id, 
            service_id, _title, service_id, _link_html, service_id, _description,
            service_id, service_id, service_id
        )
        $(category_selector).append(_service_html)
        
    // add service permissions
        const scope_selector = '#' + service_id + '_scopes'
        for (var k = 0; k < _scopes.length; k++){
            const permission_details = _scopes[k]
            _construct_permission(scope_selector, service_id, permission_details, access_scope)
        }
        
    }
    
// inject services from service list
    for (var i = 0; i < service_list.length; i++) {

        const category_title = service_list[i]
        const category_name = category_title.toLowerCase().replace(/\s/g, '_')
        const category_id = 'service_integrations_main_body_' + category_name
        const category_index_id = 'service_integrations_index_section_' + category_name + '_link'

    // create index html
        var index_html = sprintf('\
            <div id="service_integrations_index_section_%s" class="form-line">\
                <a id="%s" class="form-text no-wrap" title="Go to %s Category">%s</a>\
            </div>',
            category_name, category_index_id, category_title, category_title)
        $('#service_integrations_index_section').append(index_html)
    
    // create index listener
        var index_id = '#' + category_index_id
        $(index_id).click(function(){
            scrollDiv(category_id)
        })

    // create main wrapper html
        var main_html = sprintf('\
            <div id="%s" class="section-last">\
                <div id="%s_title" title="%s" class="form-text margin-bottom-10 bold">%s</div>\
                <div id="%s_services" class="row"></div>\
            </div>',
            category_id,
            category_id, category_title, category_title,
            category_id)
        $('#service_integrations_content_column_main_body').append(main_html)

    // add section listings
        if (category_title == 'Latest'){
            var latest_length = 3
            if (service_latest.length < 3){ latest_length = service_latest.length }
            for (var j = 0; j < latest_length; j++){
                var service_name = service_latest[j].name
                var service_type = service_latest[j].type
                var service_id = sprintf('%s_service_%s', category_id, service_name)
                var service_details = service_map[service_name]
                var access_token = ''
                var access_scope = ''
                if (service_name in token_map){
                    access_token = ingestString(token_map[service_name].access_token)
                    access_scope = ingestString(token_map[service_name].service_scope)
                }
                var category_selector = sprintf('#%s_services', category_id)
                if (service_type == 'oauth2'){
                    const service_args = [
                        category_selector,
                        service_id,
                        service_details,
                        access_token,
                        access_scope
                    ]
                    _construct_service(...service_args)
                }
            // add clear fix for bootstrap div alignment
                if (j && j % 2){
                    $('<div class="clearfix"></div>').appendTo($(category_selector))
                }
            }
        } else {
            for (var j = 0; j < service_tags[category_title].length; j++){
                var service_name = service_tags[category_title][j]
                var service_type = service_latest[j].type
                var service_id = sprintf('%s_service_%s', category_id, service_name)
                var service_details = service_map[service_name]
                var access_token = ''
                var access_scope = ''
                if (service_name in token_map){
                    access_token = ingestString(token_map[service_name].access_token)
                    access_scope = ingestString(token_map[service_name].service_scope)
                }
                var category_selector = sprintf('#%s_services', category_id)
                if (service_type == 'oauth2'){
                    const service_args = [
                        category_selector,
                        service_id,
                        service_details,
                        access_token,
                        access_scope
                    ]
                    _construct_service(...service_args)
                }
            // add clear fix for bootstrap div alignment
                if (j && j % 2){
                    $('<div class="clearfix"></div>').appendTo($(category_selector))
                }
            }
        }

    }

// add listeners to permission checkboxes
    for (var key in permission_groups){
        const service_scope = key
        const selector_list = permission_groups[key]
        for (var i = 0; i < permission_groups[key].length; i++){
            const input_params = permission_groups[key][i]
            const service_name = input_params.service
            $(input_params.selector).on('click', function(e){
                const input_class = $(this).attr('class')
                if (input_class.indexOf('icon-plus') > -1){
                    _update_permission(true, service_name, service_scope, selector_list)             
                } else {
                    _update_permission(null, service_name, service_scope, selector_list)
                }
            })
        }
    }

}

function settingsView(container_key, settings_db, settings_remote, doc_id, section_list) {

/* a method to construct a settings view */

// define input element constructor
    function _construct_input(id_prefix, field_kwargs) {

    // determine input values
        var _field_placeholder = ingestString(field_kwargs.field_placeholder)
        var _field_value = ingestString(field_kwargs.field_value)
        var _field_type = ingestString(field_kwargs.field_type)

    // determine value attribute
        var _input_value = ''
        if (_field_value) {
            _input_value = sprintf(' value="%s"', _field_value)
        }
        var _input_id = id_prefix + '_input'

    // construct input content
        if (_field_type == 'text') {
            var _input_content = sprintf('<input id="%s" type="text" placeholder="%s" class="form-input"%s>',
                _input_id, _field_placeholder, _input_value)
        } else if (_field_type == 'textarea') {
            var _input_content = sprintf('<textarea id="%s" placeholder="%s" class="form-input-textarea"%s></textarea>',
                _input_id, _field_placeholder, _input_value)
        } else if (_field_type == 'fixed') {
            var _input_content = sprintf('<div id="%s" class="form-text no-wrap">%s</div>',
                _input_id, _field_value)
        } else if (_field_type == 'password') {
            var _input_content = sprintf('<input id="%s" type="password" placeholder="%s" class="form-input"%s>',
                _input_id, _field_placeholder, _input_value)
        } else if (_field_type == 'button') {
            var _input_html = sprintf('<div class="row"><div class="col-lg-4 col-md-4 col-sm-12 col-xs-12"><div id="%s" class="form-button">%s</div></div></div>', _input_id, _field_value)
        }

    // inject input content
        $('#' + id_prefix + '_form_left').append(_input_content)

    // add event handler on textarea to resize
        if (_field_type == 'textarea') {
            var textarea_selector = '#' + _input_id
            autosize($(textarea_selector))
        }

    }

// define form constructor
    function _construct_form(id_prefix, field_kwargs){

    // inject form container
	    var _form_content = sprintf('\
            <form id="%s_form" title="%s">\
                <div id="%s_form_row" class="row auto-height margin-bottom-10"></div>\
            </form>',
            id_prefix, field_kwargs.field_description,
            id_prefix
	    )
        $('#' + id_prefix + '_middle').append(_form_content)

    // determine input column width
        var _input_class = 'col-lg-12 col-md-12 col-sm-12 col-xs-12'
        var _status_column = false
        if (ingestBoolean(field_kwargs.field_status)) {
            if (ingestString(field_kwargs.field_type) != 'textarea'){
                _input_class = 'col-lg-11 col-md-11 col-sm-11 col-xs-10 padding-right-0'
            }
            _status_column = true
        }

    // inject field input column
        var _form_left = sprintf('\
            <div id="%s_form_left" class="%s">\
                <label id="%s_form_label" for="%s_input" class="sr-only">%s</label>\
            </div>',
            id_prefix, _input_class,
            id_prefix, id_prefix, field_kwargs.field_description
        )
        $('#' + id_prefix + '_form_row').html(_form_left)

    // determine status or submission html
        var _success_html = sprintf('<span id="%s_status_success" class="icon-check icon-success"></span>', id_prefix)
        if (!(ingestBoolean(field_kwargs.field_autosave))) {
            _success_html = sprintf('<a id="%s_status_success" class="icon-arrow-right-circle icon-success"></a>', id_prefix)
        }

    // construct field status column
        var _form_right = sprintf('\
            <div id="%s_form_right" class="col-lg-1 col-md-1 col-sm-1 col-xs-2 text-right padding-left-0">\
                <div id="%s_status" class="form-input">\
                    <span id="%s_status_error" class="icon-ban icon-error icon-overlay" style="display: none;"></span>%s\
                </div>\
            </div>',
            id_prefix, _form_right_class,
            id_prefix,
            id_prefix, _success_html
        )
    // construct field status column for textarea with overlay
        var _form_textarea = sprintf('\
            <div id="%s_form_textarea" class="form-submit-overlay">\
                <div id="%s_form_textarea_row" class="row">\
                    <div id="%s_form_textarea_right" class="col-xs-1 text-right">\
                        <div id="%s_status" class="form-text">\
                            <span id="%s_status_error" class="icon-ban icon-error icon-overlay" style="display: none;"></span>%s\
                        </div>\
                    </div>\
                </div>\
            </div>',
            id_prefix,
            id_prefix,
            id_prefix,
            id_prefix,
            id_prefix, _success_html
        )
    
    // inject field status
        if (_status_column) {
            if (ingestString(field_kwargs.field_type) == 'textarea'){
                $('#' + id_prefix + '_middle').append(_form_textarea)
            } else {
                $('#' + id_prefix + '_form_row').append(_form_right)
            }
        }

    // inject input content field
        _construct_input(id_prefix, field_kwargs)

    }

// define checkbox constructor
    function _construct_toggle(id_prefix, field_kwargs){

    // decompose field properties
        var _field_options = field_kwargs.field_options
        if (!($.isArray(_field_options))){
            _field_options = []
        }
        var _field_description = ingestString(field_kwargs.field_description)
        var _field_value = ingestBoolean(field_kwargs.field_value)
        if (_field_options.length){
            _field_value = ingestString(field_kwargs.field_value)
        }

    // construct DOM ids
        var _middle_id = sprintf('%s_middle', id_prefix)
        var _middle_selector = '#' + _middle_id
        var _toggle_id = sprintf('%s_toggle', id_prefix)
        var _toggle_selector = '#' + _toggle_id
        var _input_id = id_prefix + '_input'

    // construct toggle
        var _toggle_html = sprintf('<div id="%s" class="form-text auto-height margin-bottom-10"></div>', _toggle_id)
        $(_middle_selector).html(_toggle_html)

    // inject radio element
        if (_field_options.length){
            for (var i = 0; i < _field_options.length; i++){
                var _value = _field_options[i].value
                var _title = _field_options[i].title
                var _description = _field_options[i].description
                var _input_check = ''
                if (_field_value == _value){
                    _input_check = ' checked'
                }
                var _margin = ''
                if (i + 1 < _field_options.length){
                    _margin = ' margin-bottom-5'
                }
                var _value_id = sprintf('%s_input_%s', id_prefix, _value)
                var _input_html = sprintf('\
                    <div class="row">\
                            <div class="col-xs-1">\
                                <input id="%s" type="radio" name="%s" class="radial-md" value="%s"%s>\
                            </div>\
                            <div id="%s_text" class="col-xs-11%s">%s</div>\
                    </div>',
                    _value_id, _input_id, _value, _input_check,
                    _value_id, _margin, _description)
                $(_toggle_selector).append(_input_html)
            }

    // inject checkbox element
        } else {
            var _input_check = ''
            if (_field_value){ _input_check = ' checked' }
            var _input_html = sprintf('\
                <div class="row">\
                    <div class="col-xs-1">\
                        <input id="%s" class="radial-md" type="checkbox"%s>\
                    </div>\
                    <div id="%s_text" class="col-xs-11">%s</div>\
                </div>',
                _input_id, _input_check,
                _input_id, _field_description )
            $(_toggle_selector).append(_input_html)
        }

    }

// define field constructor
    function _construct_field(section_name, section_id, fields_id, field_kwargs) {

    // define function variables
        const fields_selector = '#' + fields_id
        const field_name = ingestString(field_kwargs.field_name)
        const field_title = ingestString(field_kwargs.field_title)
        const field_type = ingestString(field_kwargs.field_type)
        const field_status = ingestBoolean(field_kwargs.field_status)
        const field_criteria = ingestMap(field_kwargs.field_criteria)
        const field_autosave = ingestBoolean(field_kwargs.field_autosave)
        const field_options = ingestArray(field_kwargs.field_options)
        const field_info = injectLinks(ingestString(field_kwargs.field_info))
        const field_id = sprintf('%s_field_%s', section_id, field_name)

    // construct selectors
        const input_selector = sprintf('#%s_input', field_id)
        const error_selector = sprintf('#%s_status_error', field_id)
        const success_selector = sprintf('#%s_status_success', field_id)

    // inject field title column
        var _title_content = sprintf('\
            <div id="%s_column padding-bottom-5">\
                <div id="%s_left" class="col-lg-3 col-md-3 col-sm-3 hidden-xs">\
                    <div id="%s_left_title" class="form-text auto-height margin-bottom-10">\
                        %s:\
                    </div>\
                </div>\
                <div id="%s_top" class="hidden-lg hidden-md hidden-sm col-xs-12">\
                    <div id="%s_left_top" class="form-label bold">\
                        %s:\
                    </div>\
                </div>\
                <div id="%s_middle" class="col-lg-9 col-md-9 col-sm-9 col-xs-12">\
                </div>\
                <div id="%s_bottom" class="col-lg-9 col-lg-offset-3 col-md-9 col-md-offset-3 col-sm-9 col-sm-offset-3 col-xs-12">\
                </div>\
			</div>',
			field_id, field_id, field_id, field_title,
			field_id, field_id, field_title,
			field_id, field_id
	    )
	    $(fields_selector).append(_title_content);

    // determine field type constructor
        var input_list = [ 'text', 'textarea', 'fixed', 'password', 'button' ]
        var toggle_list = [ 'checkbox', 'radial' ]
        if ($.inArray(field_type, input_list) > -1) {
            _construct_form(field_id, field_kwargs)
        } else if ($.inArray(field_type, toggle_list) > -1) {
            _construct_toggle(field_id, field_kwargs)
        }

    // inject field info row
        if (field_info) {
            const info_selector = '#' + field_id + '_bottom'
            var _info_content = sprintf('<div id="%s_info" class="form-label text-left text-wrap auto-height">%s</div>', field_id, field_info)
            $(info_selector).html(_info_content)
        }

    // define callback function to update records and DOM
        function _update_record(input_value){
        
            var _record_details = {}
            _record_details[section_name] = {}
            _record_details[section_name][field_name] = input_value
            settings_db.get(doc_id).then(function(_existing_details){
            
                var _client_details = upsertValues(_record_details, _existing_details)
                settings_db.put(_client_details).then(function(){
                // callback success
                    if ($(input_selector).length){
                        if ($(input_selector).get(0).isContentEditable){
                            $(input_selector).text(input_value)
                        } else {
                            $(input_selector).val(input_value)
                        }
                    }
                    settings_db.replicate.to(settings_remote).then(function(result){
                        // logConsole(result)
                    }).catch(function(err){
                        logConsole(JSON.stringify(err))
                    })
                }).catch(function(err){
                // callback failure
                    const _error_kwargs = {
                        anchor_selector: input_selector,
                        message_text: err,
                        message_status: 'error',
                        timeout: 5000
                    }
                    showMessage(_error_kwargs)
                })
                
            })

        }

    // bind input handler and icon handler
        if (field_type == 'radial'){
            if (field_options.length){
                for (var k = 0; k < field_options.length; k++){
                    const value = field_options[k].value
                    const value_selector = input_selector + '_' + value
                    $(value_selector).on('click', function(e){
                        if ($( this ).is(':checked')){
                            _update_record(value)
                        }
                    })
                }
            }
        } else if (field_type == 'checkbox'){
            $(input_selector).on('click', function(e){
                if ($( this ).is(':checked')){
                    _update_record(true)
                } else { _update_record(false)}
            })
        } else if (field_type != 'fixed' && field_type != 'button'){
            inputHandler(input_selector, field_title, field_criteria, _update_record)
            if (field_status) {
                if (field_autosave){
                    statusIconHandler(input_selector, error_selector, field_criteria)
                } else {
                    statusButtonHandler(input_selector, error_selector, success_selector, field_title, field_criteria, _update_record)
                }
            }
        }

    }

// toggle integrations container
    var container_selector = '#' + container_key + '_content_container'
    var container_html = sprintf('<div id="%s_content_container" class="container content-container-scroll"></div>', container_key)
    toggleView(container_selector, container_html)

// inject integrations view frame into container
    var frame_html = sprintf('\
        <div id="%s_content_row" class="row">\
            <div id="%s_content_column_index" class="col-sm-3 hidden-xs">\
                <div id="%s_index_section" class="section-last">\
                    <div id="%s_index_section_title" class="form-line">\
                        <div id="%s_index_section_title_text" class="form-text no-wrap bold" title="List of Sections">Sections</div>\
                    </div>\
                </div>\
            </div>\
            <div id="%s_content_column_main" class="col-sm-9 col-xs-12">\
                <div id="%s_content_column_main_body">\
                </div>\
            </div>\
        </div>', 
        container_key, container_key, container_key, container_key,
        container_key, container_key, container_key)
    $(container_selector).html(frame_html)
    
// inject fields from section list
    for (var i = 0; i < section_list.length; i++) {

        const section_title = section_list[i].section_title
        const section_name = section_list[i].section_name
        const section_id = container_key + '_main_body_' + section_name
        const section_index_id = container_key + '_index_section_' + section_name + '_link'
        const section_label = section_list[i].section_description
        const section_fields = section_list[i].section_fields
        const fields_id = section_id + '_fields'

    // create index html
        const index_selector = '#' + container_key + '_index_section'
        var index_html = sprintf('\
            <div id="%s_index_section_%s" class="form-line">\
                <a id="%s" class="form-text no-wrap" title="Go to %s Section">%s</a>\
            </div>',
            container_key, section_name, section_index_id, section_title, section_title)
        $(index_selector).append(index_html)

    // create index listener
        var index_id = '#' + section_index_id
        $(index_id).click(function(){
    // TODO figure out why scrollDiv isn't working on just this element
            scrollDiv(section_id)
        })
        
    // create main wrapper html
        const content_selector = '#' + container_key + '_content_column_main_body'
        var main_html = sprintf('\
            <div id="%s" class="section-last">\
                <div id="%s_title" title="%s" class="form-text margin-bottom-10 bold">%s</div>\
                <div id="%s" class="row"></div>\
            </div>',
            section_id,
            section_id, section_label, section_title,
            fields_id)
        $(content_selector).append(main_html)

    // add section fields
        for (var j = 0; j < section_fields.length; j++) {
            _construct_field(section_name, section_id, fields_id, section_fields[j])
        }

    }

}

function accountView(section_list, criteria_map) {

/* a method to display the account settings of user */

// define method variables
    var record_key = 'account_settings'
    var hidden_bottom = ''
    var container_selector = '#' + record_key + '_content_container'
    var hidden_selectors = container_selector + ' .hidden-bottom'
    
// define form constructor
    function _construct_form(field_id, field_kwargs){

    // determine field variables
        const _field_placeholder = ingestString(field_kwargs.placeholder)
        const _field_value = ingestString(field_kwargs.value)
        const _field_type = ingestString(field_kwargs.type)
        const _field_label = ingestString(field_kwargs.description)
        const _field_status = ingestBoolean(field_kwargs.status)
        const _field_color = ingestString(field_kwargs.color)
        
    // define DOM selectors
        const _middle_selector = '#' + field_id + '_middle'
        const _form_row_selector = '#' + field_id + '_form_row'
        
    // inject form container
	    var _form_content = sprintf('\
            <form id="%s_form" title="%s">\
                <div id="%s_form_row" class="row auto-height margin-bottom-10"></div>\
            </form>',
            field_id, _field_label,
            field_id
	    )
        $(_middle_selector).append(_form_content)

    // determine form column width
        var _input_class = 'col-lg-12 col-md-12 col-sm-12 col-xs-12'
        if (_field_status) {
            _input_class = 'col-lg-11 col-md-11 col-sm-11 col-xs-10 padding-right-0'
        }

    // determine value attribute
        var _input_value = ''
        if (_field_value) {
            _input_value = sprintf(' value="%s"', _field_value)
        }
        var _input_id = field_id + '_input'

    // determine input color
        var _input_color = ''
        if (_field_color){
            _input_color = ' ' + _field_color
        }
        
    // construct input html
        _input_html = ''
        if (_field_type == 'text') {
            var _input_html = sprintf('<input id="%s" type="text" placeholder="%s" class="form-input%s"%s>',
                _input_id, _field_placeholder, _input_color, _input_value)
        } else if (_field_type == 'textarea') {
            var _input_html = sprintf('<textarea id="%s" placeholder="%s" class="form-input-textarea%s">%s</textarea>',
                _input_id, _field_placeholder, _input_color, _field_value)
        } else if (_field_type == 'fixed') {
            var _input_html = sprintf('<div id="%s" class="form-text no-wrap%s">%s</div>',
                _input_id, _input_color, _field_value)
        } else if (_field_type == 'password') {
            var _input_html = sprintf('<input id="%s" type="password" placeholder="%s" class="form-input%s"%s>',
                _input_id, _field_placeholder, _input_color, _input_value)
        } else if (_field_type == 'button') {
            var _input_html = sprintf('<div class="row"><div class="col-lg-4 col-md-4 col-sm-12 col-xs-12"><div id="%s" class="form-button">%s</div></div></div>', _input_id, _field_value)
        }
        
    // inject form left column
        var _form_left = sprintf('\
            <div id="%s_form_left" class="%s">\
                <label id="%s_form_label" for="%s_input" class="sr-only">%s</label>%s\
            </div>',
            field_id, _input_class,
            field_id, field_id, _field_label, _input_html
        )
        $(_form_row_selector).html(_form_left)
        
    // inject form right column
        var _form_right = sprintf('\
            <div id="%s_form_right" class="col-lg-1 col-md-1 col-sm-1 col-xs-2 text-right padding-left-0">\
                <div id="%s_status" class="form-input">\
                    <span id="%s_status_error" class="icon-ban icon-error icon-overlay" style="display: none;"></span>\
                    <a id="%s_status_success" class="icon-arrow-right-circle icon-success"></a>\
                </div>\
            </div>',
            field_id, field_id, field_id, field_id
        )
        if (_field_status) {
            $(_form_row_selector).append(_form_right)
        }
        
    // add event handler on textarea to resize
        if (_field_type == 'textarea') {
            var textarea_selector = '#' + _input_id
            autosize($(textarea_selector))
        }

    }

// define field constructor
    function _construct_field(section_name, section_id, fields_id, field_kwargs) {

    // define function variables
        const fields_selector = '#' + fields_id
        const field_name = ingestString(field_kwargs.name)
        const field_title = ingestString(field_kwargs.title)
        const field_type = ingestString(field_kwargs.type)
        const field_status = ingestBoolean(field_kwargs.status)
        const field_id = sprintf('%s_field_%s', section_id, field_name)
        const field_info = injectLinks(ingestString(field_kwargs.info))
        const field_value = ingestString(field_kwargs.value)
    
    // define field criteria
        var updated_criteria = {}
        const initial_criteria = ingestMap(field_kwargs.criteria)
        for (var key in initial_criteria){
            updated_criteria[key] = initial_criteria[key]
        }
        const field_repeat = ingestString(field_kwargs.repeat)
        if (field_repeat){
            const repeat_input_selector = sprintf('#%s_field_%s_input', section_id, field_repeat)
            const repeat_label_selector = sprintf('#%s_field_%s_left_title', section_id, field_repeat)
            var repeat_label = $(repeat_label_selector).text()
            repeat_label = repeat_label.trim().slice(0,-1)
            updated_criteria['identical_to'] = {}
            updated_criteria.identical_to[repeat_input_selector] = sprintf('does not match %s.', repeat_label)
        }
        const field_criteria = deepCopy(updated_criteria)
        
    // construct selectors
        const input_selector = sprintf('#%s_input', field_id)
        const error_selector = sprintf('#%s_status_error', field_id)
        const success_selector = sprintf('#%s_status_success', field_id)

    // deactivation status
        if (field_value == 'Reactivate' && field_name == 'update_status'){
            hidden_bottom = ' style="display: none;"'
        }
        
    // inject field title column
        var _title_content = sprintf('\
            <div id="%s_column">\
                <div id="%s_left" class="col-lg-3 col-md-3 col-sm-3 hidden-xs">\
                    <div id="%s_left_title" class="form-text auto-height margin-bottom-10">\
                        %s:\
                    </div>\
                </div>\
                <div id="%s_top" class="hidden-lg hidden-md hidden-sm col-xs-12">\
                    <div id="%s_left_top" class="form-label bold">\
                        %s:\
                    </div>\
                </div>\
                <div id="%s_middle" class="col-lg-9 col-md-9 col-sm-9 col-xs-12">\
                </div>\
                <div id="%s_bottom" class="col-lg-9 col-lg-offset-3 col-md-9 col-md-offset-3 col-sm-9 col-sm-offset-3 col-xs-12 hidden-bottom"%s>\
                </div>\
			</div>',
			field_id, field_id, field_id, field_title,
			field_id, field_id, field_title,
			field_id, field_id, hidden_bottom
	    )
	    $(fields_selector).append(_title_content);

    // construct form for field
        _construct_form(field_id, field_kwargs)

    // inject field info row
        if (field_info) {
            const info_selector = '#' + field_id + '_bottom'
            var _info_content = sprintf('<div id="%s_info" class="form-label text-left text-wrap auto-height">%s</div>', field_id, field_info)
            $(info_selector).html(_info_content)
        }
        
    // define message function
        function _show_message(msg, input_selector, status){
            const _error_kwargs = {
                anchor_selector: input_selector,
                message_text: msg,
                message_status: status,
                timeout: 5000
            }
            showMessage(_error_kwargs)
        }

    // define dummy callback
        function _dummy_callback(){}
    
    // define update email function
        function _update_email(email_address){
            function _email_success(_account_password, _email_address, _input_selector){
                var patch_args = [ '', _account_password, '', _email_address ]
                var _patch_request = patchingAccount(...patch_args)
                _patch_request.done(function(){
                    _show_message('Email address update successful.', _input_selector, 'success')
                    gettingAccount()
                    $(_input_selector).val(_email_address)
                })
                _patch_request.fail(function(msg){
                    _show_message(msg, input_selector, 'error')
                })
            }
            var confirm_kwargs = {
                selector: input_selector,
                value: field_value,
                title: 'Confirm Update',
                prompt: 'To update the email address for your account, please type your current password.',
                label: 'Current Password',
                type: 'password',
                callable: _email_success,
                criteria: criteria_map['account_password'],
                args: [ email_address, input_selector ]
            }
            inputDialog(confirm_kwargs)
        }
    
    // define update password function
        function _update_password(new_password){
            function _password_success(_account_password, _new_password, _input_selector){
                var _patch_request = patchingAccount(_new_password, _account_password)
                _patch_request.done(function(){
                    _show_message('Password update successful.', _input_selector, 'success')
                })
                _patch_request.fail(function(msg){
                    _show_message(msg, input_selector, 'error')
                })
            }
            var confirm_kwargs = {
                selector: input_selector,
                value: field_value,
                title: 'Confirm Update',
                prompt: 'To update the password for your account, please type your current password.',
                label: 'Current Password',
                type: 'password',
                callable: _password_success,
                criteria: criteria_map['account_password'],
                args: [ new_password, input_selector ]
            }
            if (field_repeat){
                confirm_kwargs['repeat'] = sprintf('#%s_field_%s_input', section_id, field_repeat)
            }
            inputDialog(confirm_kwargs)
        }
    
    // define update status function
        function _update_status(status_action){
            const action_cap = status_action.toUpperCase().slice(0,1) + status_action.slice(1)
            function _status_success(_account_password, _status_action, _input_selector){
                var _patch_request = deletingAccount(_status_action, _account_password)
                _patch_request.done(function(){
                    _show_message(action_cap + ' successful.', _input_selector, 'success')
                    const _status_selector = '#' + section_id + '_field_account_status_input'
                    const _bottom_selector = '#' +  section_id + '_field_update_status_bottom'
                    gettingAccount()
                    if (_status_action == 'deactivate'){
                        $(_status_selector).text('inactive').removeClass('font-success').addClass('font-error')
                        $(_input_selector).text('Reactivate')
                        $(hidden_selectors).hide()
                    } else {
                        $(_status_selector).text('active').removeClass('font-error').addClass('font-success')
                        $(_input_selector).text('Deactivate')
                        $(hidden_selectors).show()
                    }
                    $(_input_selector).off()
                    $(_input_selector).on('click', function(e){
                        const button_text = $(this).text()
                        if (button_text.indexOf('Deactivate') > -1){
                            _update_status('deactivate')
                        } else {
                            _update_status('reactivate')
                        }
                    })
                })
                _patch_request.fail(function(msg){
                    _show_message(msg, input_selector, 'error')
                })
            }
            var confirm_kwargs = {
                selector: input_selector,
                value: field_value,
                title: 'Confirm ' + action_cap,
                prompt: sprintf('To %s your account, please type your current password.', status_action),
                label: 'Current Password',
                type: 'password',
                callable: _status_success,
                criteria: criteria_map['account_password'],
                args: [ status_action, input_selector ]
            }
            inputDialog(confirm_kwargs)
        }
    
    // bind input and icon handlers
        if (field_name == 'email_address'){
            inputHandler(input_selector, field_title, field_criteria, _update_email, enter_submit=true, auto_save=false)
            statusButtonHandler(input_selector, error_selector, success_selector, field_title, field_criteria, _update_email)
        } else if (field_name == 'new_password'){
            inputHandler(input_selector, field_title, field_criteria, _dummy_callback, enter_submit=false, auto_save=false, hidden_title='Password')
        } else if (field_name == 'account_password'){
            inputHandler(input_selector, field_title, field_criteria, _update_password, enter_submit=true, auto_save=false, hidden_title='Password')
            statusButtonHandler(input_selector, error_selector, success_selector, field_title, field_criteria, _update_password, hidden_title='Password')
        } else if (field_name == 'update_status'){
            $(input_selector).on('click', function(e){
                const button_text = $(this).text()
                if (button_text.indexOf('Deactivate') > -1){
                    _update_status('deactivate')
                } else {
                    _update_status('reactivate')
                }
            })
        }

    }

// toggle account settings container
    var container_html = sprintf('<div id="%s_content_container" class="container content-container-scroll"></div>', record_key)
    toggleView(container_selector, container_html)

// inject account view frame into container
    var frame_html = sprintf('\
        <div id="%s_content_row" class="row">\
            <div id="%s_content_column_index" class="col-sm-3 hidden-xs">\
                <div id="%s_index_section" class="section-last">\
                    <div id="%s_index_section_title" class="form-line">\
                        <div id="%s_index_section_title_text" class="form-text no-wrap bold" title="List of Sections">Sections</div>\
                    </div>\
                </div>\
            </div>\
            <div id="%s_content_column_main" class="col-sm-9 col-xs-12">\
                <div id="%s_content_column_main_body">\
                </div>\
            </div>\
        </div>', 
        record_key, record_key, record_key, record_key, record_key, record_key, record_key)
    $(container_selector).html(frame_html)

// iterate over schema sections
    for (var i = 0; i < section_list.length; i++){
    
    // define account section constants
        const section_title = section_list[i].title
        const section_name = section_list[i].name
        const section_id = record_key + '_main_body_' + section_name
        const section_index_id = record_key + '_index_section_' + section_name + '_link'
        const section_label = section_list[i].description
        const field_list = section_list[i].fields
        const fields_id = section_id + '_fields'
    
    // create section index html
        const index_selector = '#' + record_key + '_index_section'
        var index_html = sprintf('\
            <div id="%s_index_section_%s" class="form-line">\
                <a id="%s" class="form-text no-wrap" title="Go to %s Section">%s</a>\
            </div>',
            record_key, section_name, section_index_id, section_title, section_title)
        $(index_selector).append(index_html)
    
    // create index listener
        var index_id = '#' + section_index_id
        $(index_id).click(function(){
            scrollDiv(section_id)
        })
        
    // create section main wrapper html
        const content_selector = '#' + record_key + '_content_column_main_body'
        var main_html = sprintf('\
            <div id="%s" class="section-last">\
                <div id="%s_title" title="%s" class="form-text margin-bottom-10 bold">%s</div>\
                <div id="%s" class="row"></div>\
            </div>',
            section_id,
            section_id, section_label, section_title,
            fields_id)
        $(content_selector).append(main_html)
    
    // add account fields
        for (var j = 0; j < field_list.length; j++) {
            _construct_field(section_name, section_id, fields_id, field_list[j])
        }
        
    }

// define access log variables
    const log_id = record_key + '_main_body_log'
    const log_index_id = record_key + '_index_section_log_link'
    const index_selector = '#' + record_key + '_index_section'
    const content_selector = '#' + record_key + '_content_column_main_body'
    
// create section index html
    var index_html = sprintf('\
        <div class="form-line hidden-bottom"%s>\
            <a id="%s" class="form-text no-wrap" title="Go to Access Log Section">Access Log</a>\
        </div>',
        hidden_bottom, log_index_id
    )
    $(index_selector).append(index_html)

// create listener for log index button
    var log_index_selector = '#' + log_index_id
    var log_main_selector = '#' + log_id
    $(log_index_selector).click(function(){
        scrollDiv(log_main_selector)
    })

// create section main wrapper html
    var log_html = sprintf('\
        <div id="%s" class="section-last hidden-bottom"%s>\
            <div id="%s_title" title="Access Log" class="form-text margin-bottom-10 bold">Access Log</div>\
            <div class="row">\
                <div class="col-lg-3 col-md-3 col-sm-3 col-xs-12">\
                    <div id="%s_button" class="form-button">View Records</div>\
                </div>\
            </div>\
        </div>',
        log_id, hidden_bottom, log_id, log_id)
    $(content_selector).append(log_html)

// create listener for log main button
    var log_button_selector = '#' + log_id + '_button'
    $(log_button_selector).click(function(){
        openAccess()
    })
    
}

function transformAccess(access_list) {

// consolidate location details and capitalize descriptions in access list
    for (var i = 0; i < access_list.length; i++){
        if (ingestString(access_list[i].desc)){
            access_list[i]['desc'] = capitalizeString(access_list[i]['desc'])
        }
        if (ingestNumber(access_list[i].dt)){
            access_list[i]['date'] = renderEpoch(access_list[i]['dt'])
        }
        var location = ''
        if (ingestString(access_list[i].city)){
            location += access_list[i].city
        }
        if (ingestString(access_list[i].region)){
            if (location){
                location += ', '
            }
            location += access_list[i].region
        }
        if (ingestString(access_list[i].country)){
            if (location){
                location += ', '
            }
            location += access_list[i].country
        }
        if (!location){ location = 'Unknown' }
        access_list[i]['location'] = location
    }
    
    return access_list
            
}
   
function accessView(access_db, access_list) {

/* a method to display the access records of user */

// TODO persist access view across page navigations

// toggle integrations container
    const record_key = 'access_records'
    const container_selector = '#' + record_key + '_content_container'
    const container_html = sprintf('<div id="%s_content_container" class="container content-container-scroll"></div>', record_key)
    toggleView(container_selector, container_html)

// inject view frame into container
    const table_id = record_key + '_log_table'
    const frame_html = sprintf('\
        <div id="%s_content_row" class="row">\
            <div id="%s_content_column_main" class="col-xs-12">\
                <div id="%s_content_column_main_body">\
                    <div id="%s" class="row"></div>\
                    <div id="%s_paginator" class="invisible">Paginator</div>\
                </div>\
            </div>\
        </div>', 
        record_key, record_key, record_key, table_id, table_id)
    $(container_selector).html(frame_html)
        
// determine table headers
    const header_list = [ 
        { date: 'Date' }, 
        { desc: 'Description' }, 
        { platform: 'Platform' }, 
        { client: 'Client' }, 
        { ip: 'IP Address' }, 
        { location: 'Location' } 
    ]
    
// add items in access list to DOM
    tableView(table_id, access_list, header_list)

// define pagination searching function
    function _retrieve_access(previous_record){
    
        var _deferred = new $.Deferred()
        
        access_db.find({ 
            selector: { 
                dt: { $lt: previous_record.dt } 
            },
            sort: [ { dt: 'desc' } ],
            limit: 10,
            use_index: 'dt'
        }).then(function(results){
            _deferred.resolve(ingestArray(results.docs))
        }).catch(function(err){
            logConsole(err)
            _deferred.resolve([])
        })
        
        return _deferred.promise()
        
    }

// define rendering function
    function _render_access(_access_list, end_page){
    
        var _deferred = new $.Deferred()
        
        _access_list = transformAccess(_access_list)
        tableView(table_id, _access_list, header_list, end_page)
        _deferred.resolve()
        
        return _deferred.promise()
        
    }
    
// add pagination to DOM
    const access_paginator = '#' + table_id + '_paginator'
    paginateView(access_paginator, access_list, _retrieve_access, _render_access, 10)
 
}

function updateConversation(conversation_id, message_text, message_received=true, bot_name='', history_length=10) {

// define selector selector
    var conversation_selector = $(conversation_id)
    
    if (conversation_selector.length){
    
// construct new message
        var message_html = ''
        if (ingestString(bot_name)){
            logConsole(bot_name + ': ' + message_text)
            message_html = sprintf('\
                <div class="row auto-height">\
                    <div class="col-xs-10">\
                        <div class="form-line italic text-wrap">%s: %s</div>\
                    </div>\
                </div>', 
                bot_name, message_text)
        } else {
            logConsole('me: ' + message_text)
            message_html = sprintf('\
                <div class="row auto-height">\
                    <div class="col-xs-2"><div class="form-line">&nbsp;</div></div>\
                    <div class="col-xs-10">\
                        <div class="form-line text-right text-wrap italic font-faded">%s</div>\
                    </div>\
                </div>', 
                message_text)   
        }

    // fade in new message
        setTimeout(function(){
        
            $(message_html).appendTo(conversation_selector).hide().fadeIn(600)
   
   // fade out and remove messages near top
            var chat_window_top = $('#dialog_chat').offset().top
            conversation_selector.children().each(function(){
                const message_top = $(this).offset().top
                if (message_top - chat_window_top < 0){
                    $(this).remove()
                } else if ($('#dialog_chat').is(':visible')){
                    if (message_top - chat_window_top < 50){
                        $(this).fadeTo(600, .33)
                    } else if (message_top - chat_window_top < 100){
                        $(this).fadeTo(600, .66)
                    }
                }
            })
            
        }, 600) 
        
    }
    
//// define fade function
//    function fade_out(element_selector){
//        setTimeout(function(){
//            element_selector.remove()        
//        }, 600)
//        element_selector.fadeOut(600)
//    }

    // remove prior messages
//        var message_count = conversation_selector.children().length
//        if (message_count >= history_length){
//            var extra_length = message_count - history_length
//            if (extra_length >= 0){
//                for (var i=0; i < extra_length; i++){
//                    const timeout = 600 + i * 600
//                    setTimeout(function(){
//                        var first_child = conversation_selector.find('div').first()
//                        fade_out(first_child)
//                    }, timeout)
//                }
//            }
//        }

}

function toggleChannels(socket_client, channel_type, emit_update=true) {

    /* a method to add / remove a socket channel interface */
    
// validate socket channels in window
    if (!('socket_channels' in window)){
        window.socket_channels = []
    }
    
// define input box selectors
    var record_key = 'dialog_chat'
    var input_box_id = '#' + record_key + '_input_box'
    var submit_box_id = '#' + record_key + '_submit_box'
    var message_box_id = '#' + record_key + '_message_box'
    var transcript_box_id = '#' + record_key + '_transcript_box'
    var input_prefix = record_key + '_input'
    var submit_prefix = record_key + '_submit'
    var message_input_id = '#' + input_prefix + '_message_text'
    var message_submit_id = '#' + submit_prefix + '_message_success'
    var message_error_id = '#' + submit_prefix + '_message_error'
    var channel_footer_id = sprintf('#footer_navigation_%s_link', channel_type)
    var channel_footer_box_id = sprintf('#footer_navigation_%s_box', channel_type)
    var channel_header_id = sprintf('#header_navigation_%s_link', channel_type)
    var channel_header_box_id = sprintf('#header_navigation_%s_box', channel_type)

// define input constructor
    function _construct_message_input() { 
    
    // inject input form into conversation frame
        var input_html = sprintf('\
            <div id="%s_row" class="row">\
                <div id="%s_column" class="col-xs-12">\
                    <form id="%s_form" title="New Message">\
                        <div id="%s_form_row" class="row">\
                            <div id="%s_form_left" class="col-xs-12 auto-height">\
                                <textarea id="%s_message_text" placeholder="type message here..." class="form-input-textarea"></textarea>\
                            </div>\
                        </div>\
                    </form>\
                </div>\
            </div>',
            input_prefix, input_prefix, input_prefix, input_prefix, input_prefix, input_prefix)
        $(input_box_id).html(input_html)
    
    // inject submit button into conversation frame
        var submit_html = sprintf('\
            <div id="%s_row" class="row">\
                <div id="%s_column" class="col-xs-1 text-right">\
                    <div id="%s_text" class="form-text">\
                        <span id="%s_message_error" class="icon-ban icon-error icon-overlay" style="display: none;"></span>\
                        <span id="%s_message_success" class="icon-arrow-right-circle icon-success"></span>\
                    </div>\
                </div>\
            </div>',
            submit_prefix, submit_prefix, submit_prefix, submit_prefix, submit_prefix, submit_prefix)
        $(submit_box_id).html(submit_html)
    
    // add focus and autosize to input
        $(message_input_id).focus()
        autosize($(message_input_id))
    
    }
     
// define submit function    
    function _submit_message(input_value){
        if (window.socket_channels.indexOf('message') > -1){
            socket_client.emit('message', { 'msg': input_value, 'sender': 'user' }, function(callback){
                if (callback == 200){
                    updateConversation(message_box_id, input_value)
                } else {
                    updateConversation(message_box_id, input_value, false)
                }
            })
            $(message_input_id).val('')
            $(message_input_id).focus()
            autosize.update($(message_input_id))
        }
    }

// define interim speech update function
    function _update_message(transcribed_text){
    // TODO integrate parsing fluctuations of interim speech into backend logic
//        if (window.socket_channels.indexOf('speech') > -1){
//            socket_client.emit('speech_interim', { 'transcription': transcribed_text, 'sender': 'user' })
//        }
        $(message_input_id).val(transcribed_text)
        autosize.update($(message_input_id))
    }
        
// define final speech submit function
    function _submit_speech(transcribed_text){
        if (window.socket_channels.indexOf('speech') > -1){
            socket_client.emit('speech_final', { 'transcription': transcribed_text, 'sender': 'user' }, function(callback){
                setTimeout(function(){
                    if (callback == 200){
                        updateConversation(message_box_id, transcribed_text)
                    } else {
                        updateConversation(message_box_id, transcribed_text, false)
                    }
                }, 600)
            })
        }
        setTimeout(function(){
            if (window.socket_channels.indexOf('message') > -1){
                $(message_input_id).val('')
                autosize.update($(message_input_id))
            }
        }, 600)
    }
    
// update socket channels
    var channel_activate = false
    var channel_index = window.socket_channels.indexOf(channel_type)
    if (channel_index == -1){
        window.socket_channels.push(channel_type)
        channel_activate = true
    } else {
        window.socket_channels.splice(channel_index, 1)
    }

// emit update
    if (emit_update){
        socket_client.emit('channels', { media: window.socket_channels })
    }

// activate button
    if (channel_activate){
    
        var channel_label = 'Deactivate ' + capitalizeString(channel_type) 
        $(channel_footer_id).addClass('icon-attention')
        $(channel_footer_id).attr('title', channel_label)
        $(channel_header_id).addClass('icon-attention')
        $(channel_header_id).attr('title', channel_label)
    
    // restart animations in sync with each other
        var previous_animation = false
        for (var i = 0; i < window.socket_channels.length; i++){
            if (window.socket_channels[i] != channel_type){
                previous_animation = true
                const channel_foot_box_id = sprintf('#footer_navigation_%s_box', window.socket_channels[i])
                const channel_head_box_id = sprintf('#header_navigation_%s_box', window.socket_channels[i])  
                $(channel_foot_box_id).removeClass('burst-effect')
                $(channel_head_box_id).removeClass('burst-effect')
            }
        }
        if (previous_animation){
            var animation_sync = setInterval(function(){
                var animation_ended = true
                for (var i = 0; i < window.socket_channels.length; i++){
                    const channel_foot_box_id = sprintf('#footer_navigation_%s_box', window.socket_channels[i])
                    const channel_head_box_id = sprintf('#header_navigation_%s_box', window.socket_channels[i])
                    const footer_classes = ingestString($(channel_foot_box_id).attr('class'))
                    const header_classes = ingestString($(channel_head_box_id).attr('class'))
                    if (footer_classes.indexOf('burst-effect') > -1 || header_classes.indexOf('burst-effect') > -1){ 
                        animation_ended = false
                        break
                    }
                }
                if (animation_ended){
                    for (var i = 0; i < window.socket_channels.length; i++){
                        const channel_foot_box_id = sprintf('#footer_navigation_%s_box', window.socket_channels[i])
                        const channel_head_box_id = sprintf('#header_navigation_%s_box', window.socket_channels[i])  
                        $(channel_foot_box_id).addClass('burst-effect')
                        $(channel_head_box_id).addClass('burst-effect')
                    }
                    clearInterval(animation_sync)
                }
            }, 50)
        } else {
            $(channel_footer_box_id).addClass('burst-effect')
            $(channel_header_box_id).addClass('burst-effect')
        }

// deactivate button
    } else {
        var channel_label = 'Activate ' + capitalizeString(channel_type) 
        $(channel_footer_id).removeClass('icon-attention')
        $(channel_footer_id).attr('title', channel_label)
        $(channel_header_id).removeClass('icon-attention')
        $(channel_header_id).attr('title', channel_label)
        $(channel_footer_box_id).removeClass('burst-effect')
        $(channel_header_box_id).removeClass('burst-effect')
    }

// update socket channels and local environment
    if (channel_activate){
        if (channel_type == 'speech'){
            startSpeechRecognition(_submit_speech, _update_message)
            socket_client.on('speech', function(server_data){
                playAudio(server_data.audio_data, server_data.content_type, server_data.volume_level)
            })
        } else if (channel_type == 'message'){
            // restore messaging view
            showConversation()
            if (!$.trim($(input_box_id).html())){
            // add messaging input bar
                _construct_message_input()
                inputHandler(message_input_id, 'Message', {}, _submit_message, enter_submit=true, auto_save=false)
                statusButtonHandler(message_input_id, message_error_id, message_submit_id, 'Message', {}, _submit_message)
            } else {
                $(message_input_id).focus()
            }
            socket_client.on('message', function(server_data){
                var sender = ingestString(server_data.sender)
                var msg = ingestString(server_data.msg)
                updateConversation(message_box_id, msg, true, sender)
            })
        }
    } else {
        if (channel_type == 'speech'){
            stopSpeechRecognition()
            socket_client.removeAllListeners('speech')
            $(message_input_id).focus()
        } else if (channel_type == 'message'){
            hideConversation()
            $(input_box_id).empty()
            $(submit_box_id).empty()
            socket_client.removeAllListeners('message')
        }
    } 

}

function conversationView(socket_client, channel_types=null) {
    
    /* a method to construct and manage a conversation with the server */

// define record key for conversation
    var record_key = 'dialog_chat'
    
// construct channel map
    var channel_list = [ 'message', 'speech', 'video', 'location' ]
    var channel_map = {
        message: {
            icon: 'icon-bubbles',
            name: 'message',
            label: 'Activate Message',
            onclick: 'toggleChannels',
            args: [ socket_client, 'message' ]
        },
        speech: {
            icon: 'icon-microphone',
            name: 'speech',
            label: 'Activate Speech',
            onclick: 'toggleChannels',
            args: [ socket_client, 'speech' ]
        },
        video: {
            icon: 'icon-camrecorder',
            name: 'video',
            label: 'Video Not Supported',
//            onclick: toggleChannels,
//            args: [ socket_client, record_key, 'video' ]
        },
        location: {
            icon: 'icon-location-pin',
            name: 'location',
            label: 'Location Not Supported',
//            onclick: toggleChannels,
//            args: [ socket_client, record_key, 'location' ]
        }
    }
    
// define channel constructor
    function _construct_channels(){
    
    // create navigation kwargs
        var channel_links = {
            links: []    
        }
        for (var i = 0; i < channel_list.length; i++){
            channel_links.links.push(channel_map[channel_list[i]])
        }
    
    // update navigation
        updateNavigation(channel_links)
        
    }
        
// determine channels to toggle
    var channels_supported = [ 'message', 'speech' ]
    var channels_existing = ingestArray(window.socket_channels)
    var channels_updated = []

// disable speech if transcription on
    var transcript_index = channels_existing.indexOf('transcription')
    if (transcript_index > -1){
        channels_supported.splice(1, 1)
        channel_map['speech']['label'] = 'Disabled While Transcription Active'
        delete channel_map['speech']['onclick']
        delete channel_map['speech']['args']
    }
    
//// eliminate channels not supported by conversation view
//    for (var i = 0; i < channels_existing.length; i++){
//        if (channels_supported.indexOf(channels_existing[i]) == -1){
//            channels_updated.push(channels_existing[i])
//        }
//    }

// add channels not currently open
    if (ingestArray(channel_types).length){
        for (var i = 0; i < channel_types.length; i++){
            if (channels_supported.indexOf(channel_types[i]) > -1){
                if (channels_existing.indexOf(channel_types[i]) == -1){
                    channels_updated.push(channel_types[i])
                }   
            }
        }
    }

// add navigation bar
    _construct_channels()

// remove unsupported links
    for (var i = 0; i < channel_list.length; i++){
        const channel_name = channel_map[channel_list[i]]['name']
        if (channels_supported.indexOf(channel_list[i]) == -1){
            const channel_footer_id = sprintf('#footer_navigation_%s_link', channel_name)
            const channel_header_id = sprintf('#header_navigation_%s_link', channel_name)
            $(channel_footer_id).addClass('hidden-link font-faded')
            $(channel_header_id).addClass('hidden-link font-faded')
        }
    }

// toggle channels
    for (var i = 0; i < channels_updated.length; i++){
        if (i + 1 < channels_updated.length){
            toggleChannels(socket_client, channels_updated[i], emit_update=false)
        } else {
            toggleChannels(socket_client, channels_updated[i])
        }
    }

}

function openLab() {

/* a routing method to open the lab */

    console.log('Opening lab.')
    openDashboard()

}

function openAuthentication() {

/* a routing method to open the authentication sequence */

    console.log('Opening authentication.')
    openLogin()
    
}

function openDashboard() {

/* a routing method when opening to the dashboard */

    openTranscription()
    
}

function openLogin() {

/* a method to format the page and open the login view */

// define internal login view function
    function _display_login(){
    
    // enable title
        showTitle(center_desktop=true)
        
    // edit landing view
        // $('#landing_middle_row').removeClass('vertical-center').addClass('vertical-bottom-40')
        $('#landing_middle_row').removeClass('row').addClass('col-xs-12')
    
    // construct input box
        var landing_id = '#landing_middle_column'
        var box_html = '<div id="input_box" title="Login" class="form-line text-left"></div>'
    
    // add input box to DOM
        $(landing_id).append(box_html)
    
    // construct login view
        loginView()
        
    }
    
// remove landing box then display input
    if ($('#landing_box').length){
    
    // fade out landing box
        setTimeout(function(){ 
    
    // remove landing box
            $('#landing_box').remove()
        
     // add input
            _display_login() 
        
        }, 600)
        
    } else {
    
    // create landing html
        var landing_html = '\
        <div id="landing_container" class="content-container-fill">\
            <div id="landing_row" class="row height-100">\
                <div id="landing_left" class="col-lg-4 col-md-4 col-sm-3 hidden-xs"></div>\
                <div id="landing_middle" class="col-lg-4 col-md-4 col-sm-6 col-xs-12 height-100">\
                    <div id="landing_middle_row" class="row vertical-center">\
                        <div id="landing_middle_column" class="col-lg-12 col-md-12 col-sm-12 col-xs-12"></div>\
                    </div>\
                </div>\
                <div id="landing_right" class="col-lg-4 col-md-4 col-sm-3 hidden-xs"></div>\
            </div>\
        </div>'   
        $('#content').html(landing_html)
        
    // add input
        _display_login()
        
    }

}

function openUpdate(account_action, account_token) {

/* a method to construct the reset page and open the update password view */

// hide landing
    hideLanding()
    
// enable title
    showTitle(center_desktop=true)

// inject content html
    contentMiddle()
    
// edit landing view
    $('#content_middle_row').removeClass('row').addClass('col-xs-12')

// construct input box
    var landing_id = '#content_middle_column'
    var box_html = '<div id="input_box" title="Login" class="form-line text-left"></div>'

// add input box to DOM
    $(landing_id).append(box_html)

// open update view
    updateView(account_action, account_token)

}

function openReport(account_token) {

/* a function to construct the page and open the report view */

// hide landing
    hideLanding()
    
// enable title
    showTitle(center_desktop=true)

// inject content html
    contentMiddle()
    
// edit landing view
    $('#content_middle_row').removeClass('row').addClass('col-xs-12')

// construct input box
    var landing_id = '#content_middle_column'
    var box_html = '<div id="input_box" title="Login" class="form-line text-left"></div>'

// add input box to DOM
    $(landing_id).append(box_html)

// open update view
    reportView(account_token)
    
}

function openOAuth2Callback(service_name) {

/* a method to construct the page and open the report view */

// log console
    console.log('Opening callback.')
    
// update history
    updateHistory(openOAuth2Callback, [service_name])

// retrieve schema
    var service_promise = loadingService(service_name)

// define callback
    function _open_callback(service_details){
        
    // hide landing
        hideLanding()
        
    // enable title
        showTitle(center_desktop=true)
    
    // inject content html
        contentMiddle()
        
    // edit landing view
        $('#content_middle_row').removeClass('row').addClass('col-xs-12')
    
    // add service logo to DOM
        var landing_id = '#content_middle_column'
        var logo_html = sprintf('\
            <div id="logo_box" title="%s" class="col-xs-12 text-center">\
                <img src="%s" class="icon-mega margin-bottom-10">\
            </div>', 
            service_details['service_title'], service_details['service_logo'])
        $(landing_id).append(logo_html)

    // add input box to DOM
        var box_html = sprintf('<div id="input_box" title="%s" class="form-line text-left"></div>', service_details['service_title'])
        $(landing_id).append(box_html)
    
    // open update view
        oauth2CallbackView(service_details)
    
    }

// run callback when requests resolve
    service_promise.done(_open_callback)

}

function openIntegrations(div_id='') {

    /* a method to retrieve oauth2 service data and invoke integration view */
    
// log console
    console.log('Opening integrations.')
    
// update history
    updateHistory(openIntegrations, [div_id])

// define view builder
    function _open_integrations(tokens_db, tokens_remote, service_map, token_map){
     
    // replace title
        var title_kwargs = {
            app_title: window.app_title,
            app_subtitle: 'Service Integrations',
            page_title: 'Service Integrations',
            page_label: 'Manage Integrations with Existing Services'
        }
        updateTitle(title_kwargs)

    // show dashboard
        showDashboard()

    // construct view and adjust location
        integrationsView(tokens_db, tokens_remote, service_map, token_map)
        scrollDiv(div_id)
        
    }

// define token map retrieval function
    function _retrieving_tokens(tokens_db, tokens_remote){
    
    // construct new promise
        var deferred = new $.Deferred()
        
    // find tokens
        tokens_db.find({
            selector: { service_name: { $gt: null } },
            use_index: 'service_name'
        }).then(function(results){
        
        // construct token map
            var token_map = {}
            for (var i = 0; i < results.docs.length; i++){
                const doc_details = results.docs[i]
                const service_name = doc_details['service_name']
                if (service_name in token_map){
                    tokens_db.remove(doc_details)   
                } else {
                    token_map[service_name] = doc_details
                } 
            }
            
        // define renewal promise    
            function _renewal_promise(service_name, token_details){
                var _deferred = new $.Deferred()
                var _renewing_token = renewingOAuthToken(service_name)
                _renewing_token.done(function(updated_details){
                    _deferred.resolve(updated_details)
                })
                _renewing_token.fail(function(msg){ 
                // delete non-renewable tokens
                    tokens_db.remove(token_details).then(function(){
                        _deferred.resolve({ service_name: service_name })
                    }) 
                })
                return _deferred.promise()
            }
        
        // attempt to renew any expired tokens    
            var renewal_promises = []
            for (var key in token_map){
                const expires_at = token_map[key].expires_at
                if (expires_at && expires_at < $.now() / 1000){
                    const service_name = key
                    const token_details = token_map[key]
                    renewal_promises.push(_renewal_promise(service_name, token_details))
                }
            }
        
        // resolve promise
            if (renewal_promises.length){
            
                $.when(...renewal_promises).then(function(){
                    const renewed_tokens = arguments
                    tokens_db.replicate.from(tokens_remote).then(function(result){
                        for (var i = 0; i < renewed_tokens.length; i++){
                            const service_name = renewed_tokens[i].service_name
                            if ('access_token' in renewed_tokens[i]){
                                token_map[service_name] = renewed_tokens[i]
                            } else {
                                delete token_map[service_name]
                            }
                        }
                        deferred.resolve(token_map)
                    }).catch(function(err){
                        logConsole(JSON.stringify(err))
                        for (var i = 0; i < renewed_tokens.length; i++){
                            const service_name = renewed_tokens[i].service_name
                            if ('access_token' in renewed_tokens[i]){
                                token_map[service_name] = renewed_tokens[i]
                            } else {
                                delete token_map[service_name]
                            }
                        }
                        deferred.resolve(token_map)
                    })
                    
                })
            } else {
                deferred.resolve(token_map)
            }

        })
        
        return deferred.promise()
        
    }

// load oauth2 token bucket
    loadingBucket('oauth2_tokens').then(function(tokens_db){
    
    // define remote db
        var tokens_remote = window.pouch_db['oauth2_tokens_remote']
        
    // load schemas
        var token_promise = _retrieving_tokens(tokens_db, tokens_remote)
        var service_promise = loadingServices()
        var experiment_promise = loadingSchema('lab_experiments')
        var scope_promise = loadingSchema('lab_scopes')
    
    // wait for callback
        $.when(service_promise, experiment_promise, scope_promise, token_promise).then(function(service_map, experiment_map, scope_map, token_map){
            
        // transform experiment map to map scope property instead
            var experiment_scopes = {}
            for (var key in experiment_map){
                for (var i = 0; i < experiment_map[key]['integrations'].length; i++){
                    const req_details = experiment_map[key]['integrations'][i]
                    for (var j = 0; j < req_details['scopes'].length; j++){
                        const scope_name = req_details['scopes'][j]
                        if (!(scope_name in experiment_scopes)){
                            experiment_scopes[scope_name] = []
                        }
                        const experiment_details = {
                            'title': experiment_map[key]['title'],
                            'name': experiment_map[key]['name'],
                            'type': experiment_map[key]['type'],
                            'enabled': experiment_map[key]['enabled'],
                            'logo': experiment_map[key]['logo'],
                            'url': experiment_map[key]['url'],
                            'added': experiment_map[key]['added']
                        }
                        experiment_scopes[scope_name].push(experiment_details) 
                    }
                }
            }
        
        // sort experiments by date added
            for (var key in experiment_scopes) {
                experiment_scopes[key].sort(function(a, b){
                    return b.added - a.added
                })
            }
        
        // create scopes list, merge experiments and sort scopes alphabetically
            var scope_list = []
            for (var key in scope_map){
                var scope_details = {
                    scope: key,
                    experiments: experiment_scopes[key]
                }
                for (var k in scope_map[key]){
                    scope_details[k] = scope_map[key][k]
                }
                scope_list.push(scope_details)
            }
            scope_list.sort(function(a, b){
                if (a.scope > b.scope){ return 1 }
                if (a.scope < b.scope){ return -1 }
                return 0
            })
        
        // sort scopes list by service
            var ordered_scopes = {}
            for (var i = 0; i < scope_list.length; i++){
                const service_name = scope_list[i]['service']
                if (!(service_name in ordered_scopes)){
                    ordered_scopes[service_name] = []
                }
                ordered_scopes[service_name].push(scope_list[i])
            }
            
        // update service map with ordered scopes
            for (var key in scope_map){
                const service_name = scope_map[key]['service']
                if (service_name in service_map && service_name in ordered_scopes){
                    service_map[service_name]['service_scopes'] = ordered_scopes[service_name]
                }
            }
            
        // call view builder
            _open_integrations(tokens_db, tokens_remote, service_map, token_map)
            
        })
       
    })
    
// TODO view for connectivity error
    
}

function openPreferences(div_id='') {

/* a method to open the settings view with user data */
    
// log console
    console.log('Opening preferences.')
    
// update history
    updateHistory(openPreferences, [div_id])

// define callback
    function _open_preferences(preferences_db, preferences_remote, schema_details, record_details){

    // ingest variables
        var settings_key = 'user_preferences'
        var record = ingestMap(record_details)
        var section_list = ingestArray(schema_details)

    // update section list with user records
        for (var i = 0; i < section_list.length; i++){
            var section_name = section_list[i].section_name
            if (section_name in record){
                var fields_list = section_list[i].section_fields
                for (var j = 0; j < fields_list.length; j++){
                    var field_name = fields_list[j].field_name
                    if (field_name in record[section_name]){
                        var field_value = record[section_name][field_name]
                        section_list[i].section_fields[j].field_value = field_value
                    }
                }
            }
        }

    // replace title
        var title_kwargs = {
            app_title: window.app_title,
            app_subtitle: 'User Preferences',
            page_title: 'User Preferences',
            page_label: 'Update Preferences for Laboratory Account'
        }
        updateTitle(title_kwargs)

    // show dashboard
        showDashboard()

    // construct view and adjust location
        settingsView(settings_key, preferences_db, preferences_remote, record_details._id, section_list)
        scrollDiv(div_id)
    }
    
// load user preferences bucket
    loadingBucket('user_preferences').then(function(preferences_db){
    
    // define remote db
        var preferences_remote = window.pouch_db['user_preferences_remote']
        
    // retrieve schema and lab preference record
        var schema_promise = loadingSchema('lab_preferences')
        var record_promise = preferences_db.allDocs({ include_docs: true })
        
        $.when(schema_promise, record_promise).then(function(schema_details, results){
       
        // create a new preferences doc if none exists
            if (!results.rows.length){
                const gateway_auth = loadRecord('gateway_auth')
                var record_details = {
                    "uid": gateway_auth.uid,
                    "dt": $.now() / 1000,
                    "laboratory_settings": {
                        "research_level": "beta"
                    }
                }
                preferences_db.post(record_details).then(function(response){
                    record_details['_id'] = response['id']
                    record_details['_rev'] = response['rev']
                    _open_preferences(preferences_db, schema_details, record_details)
                })
                
            } else {
                var record_details = results.rows[0].doc
                _open_preferences(preferences_db, preferences_remote, schema_details, record_details)
            }
            
        })
        
    })

}

function openAccount(div_id='') {

/* a method to retrieve account and access records and open account view */
    
// log console
    console.log('Opening account.')
    
// update history
    updateHistory(openAccount, [div_id])
    
// retrieve schemas and request account settings
    var accounts_promise = loadingSchema('lab_accounts')
    var criteria_promise = loadingSchema('lab_criteria')
    var account_promise = gettingAccount()
    
// run callback when requests resolve
    $.when(accounts_promise, criteria_promise, account_promise).then(function(section_list, criteria_map, record){
    
    // ingest variables
        var record_map = ingestMap(record)
        
    // update schema list with record variables
        for (var i = 0; i < section_list.length; i++){
            var section_name = section_list[i].name
            if (section_name in record_map){
                var field_list = section_list[i].fields
                for (var j = 0; j < field_list.length; j++){
                    var field_name = field_list[j].name
                    if (field_name in record_map[section_name]){
                        var field_value = record_map[section_name][field_name]
                        section_list[i].fields[j].value = field_value
                        if (field_name == 'email_address'){
                            section_list[i].fields[j].placeholder = field_value
                        } else if (field_name == 'account_status'){
                            if (field_value == 'inactive' ){
                                section_list[i].fields[2].value = 'Reactivate'
                                section_list[i].fields[j].color = 'font-error'
                            }
                        }
                    }
                    if (field_name in criteria_map){
                        section_list[i].fields[j].criteria = deepCopy(criteria_map[field_name])
                    }
                }
            }
        }
        
    // replace title
        var title_kwargs = {
            app_title: window.app_title,
            app_subtitle: 'Account Settings',
            page_title: 'Account Settings',
            page_label: 'Update Settings for Laboratory Account'
        }
        updateTitle(title_kwargs)

    // show dashboard
        showDashboard()

    // construct view and adjust location
        accountView(section_list, criteria_map)
        scrollDiv(div_id) 
    
    })

// TODO view for connectivity error

}

function openAccess(div_id='') {

/* a method to retrieve access log records and open access view */

// log console
    console.log('Opening access.')

// update history
    updateHistory(openAccess, [div_id])
    
// define callback for db retrieval
    function _open_access(access_db, access_list){
        
    // replace title
        var title_kwargs = {
            app_title: window.app_title,
            app_subtitle: 'Access Records',
            page_title: 'Access Records',
            page_label: 'Account Access Logs'
        }
        updateTitle(title_kwargs)

    // show dashboard
        showDashboard()
        
    // construct view and adjust location
        accessView(access_db, access_list)
        scrollDiv(div_id)
    
    }
        
// load access records bucket
    loadingBucket('access_records').then(function(access_db){
        
    // search bucket for records
        access_db.find({ 
            selector: { 
                dt: { $gt: null } 
            },
            sort: [ { dt: 'desc' } ],
            limit: 10,
            use_index: 'dt'
        }).then(function(results){
       
        // compact db and list results
            var access_list = ingestArray(results.docs)
            access_list = transformAccess(access_list)
        
        // invoke callback
            _open_access(access_db, access_list)
            
        })
        
    })
    
}

function openConversation(channels='') {

    /* a method to connect to socket client and construct conversation dialog */
    
// parse channels
    var channel_types = []
    if (ingestString(channels)){
        channel_types = channels.split(' ')
    }

// ensure socket is open
    var socket_request = handlingSocket(window.server_url)
    
// define open conversation function
    function _open_conversation(socket_client){
        
        if (!$('#header_navigation_message_link').length){
    
            conversationView(socket_client, channel_types)
           
        } else if (!$('#dialog_chat').is(':visible')){
        
            $('#dialog_chat').show()
            
        }
        
    }  
    
// initiate callback
    $.when(socket_request).then(_open_conversation)
   
}

function signOut() {

    /* a method to clear client records and connections and open landing page */

// log process
    console.log('Signing out.')
    
// restore landing title
    var title_kwargs = {}
    updateTitle(title_kwargs)

// remove navigation links
    const nav_desktop_id = '#header_right_desktop'
    const nav_mobile_id = '#ooter_verified_mobile'
    $(nav_desktop_id).empty()
    $(nav_mobile_id).empty()

// remove action and option links
    $('#header_right_mobile').empty()
    $('#dialog_options_buttons').empty()
    
// remove chat dialog entries
    $('#dialog_chat_message_box').empty()
    $('#dialog_chat_input_box').empty()
    $('#dialog_chat_submit_box').empty()
    hideConversation()
    
// hide dashboard
    hideDashboard()

// restore landing view
    landingView();

// disconnect speech recognition
    if ('speech_recognition_client' in window){
        stopSpeechRecognition()
    }

// disconnect speech transcription
    if ('speech_transcription_client' in window){
        stopSpeechTranscription()
    }

// disconnect pouch db remotes
    if ('pouch_db' in window){
        stoppingPouch(window.pouch_db)
    }

// disconnect any active socket process
    if ('socket_client' in window){
        disconnectClient()
    }

// disconnect any active maps
    if ('map_object' in window){
        delete window.map_object
        window.map_markers = []
        $('#google_map_script').remove()
    }

// clear records
    clearRecords()

// get a new session token
    gettingSession()
    
// clear history
    window.client_history = []

// clear fingerprint
    window.client_fingerprint = {}

// clear listeners
    if ('client_listeners' in window){
        for (var key in window.client_listeners){
            try {
                clearInterval(window.client_listeners[key])
            } catch(err) {}
        }
    }
    window.client_listeners = {}
    
// get a new client fingerprint
    initializeFingerprint()
    
}

// TODO Loading Records View (for signin wait)
/**
* DATA JAVASCRIPT EXTENSION
* @author rcj1492
* @license Â©2017-2018 Collective Acuity
* @email support@collectiveacuity.com
*
* requirements:
* jquery
* lab.js
* pouchdb (https://pouchdb.com/)
* modernizr (https://modernizr.com/) 
* * localstorage
**/

//// import dependencies
//import $ from 'jquery'
//import Modernizr from 'modernizr'
//import PouchDB from 'pouchdb'
//import { deepCopy, ingestMap, ingestString, mapSize, isMap, ingestNumber, logConsole, callFunction } from 'lab'

function upsertValues(upsert_map, existing_map) {

/* a method to upsert changes into an existing map */

// TODO create a fully recursive upsertion method (which includes arrays)

    var updated_map = null
    upsert_map = deepCopy(ingestMap(upsert_map))
    if (!(mapSize(upsert_map))){
        updated_map = deepCopy(upsert_map)
    } else {
        updated_map = ingestMap(existing_map)
        for (key in upsert_map) {
            if (!(mapSize(ingestMap(upsert_map[key])))){
                updated_map[key] = upsert_map[key]
            } else {
                if (!(key in updated_map)){ updated_map[key] = {} }
                for (k in upsert_map[key]){
                    updated_map[key][k] = upsert_map[key][k]
                }
            }
        }
    }
    return updated_map
    
}

function saveRecord(record_key, record_details, record_timestamp=null, overwrite=true, callback=null) {

    /* a method to save record details to local device */    

// verify client records in window
    if (!('client_records' in window)){
        window.client_records = {}
    }

// determine timestamp to add to record
    var timestamp_value = null
    var timestamp_key = record_key + '_record_timestamp'
    var timestamp_map = ingestMap(record_timestamp)
    if (mapSize(timestamp_map)){
        timestamp_value = timestamp_map
    } else {
        timestamp_value = ingestNumber(record_timestamp)
        if (!timestamp_value) {
            timestamp_value = ($.now() / 1000)
        }
    }
      
// overwrite record
    if (overwrite) {

        if (Modernizr.localstorage){
            var stored_details = JSON.stringify({ value: record_details })
            var stored_timestamp = JSON.stringify({ value: timestamp_value })
            localStorage.setItem(record_key, stored_details)
            localStorage.setItem(timestamp_key, stored_timestamp)
            logConsole(record_key + ' record saved in Local Storage.')
        } else {
            window.client_records[record_key] = record_details
            window.client_records[timestamp_key] = timestamp_value
            logConsole(record_key + ' record saved in Window.')
        }
        if (callback){
            callFunction(callback, [record_details])
        }
        
        return record_details

// update record
    } else {

        var existing_details = loadRecord(record_key)
        var updated_record = upsertValues(record_details, existing_details)
        
        if (Modernizr.localstorage){
            var stored_details = JSON.stringify({ value: updated_record })
            var stored_timestamp = JSON.stringify({ value: timestamp_value })
            localStorage.setItem(record_key, stored_details)
            localStorage.setItem(timestamp_key, stored_timestamp)
            logConsole(record_key + ' record updated in Local Storage.')
        } else {
            window.client_records[record_key] = updated_record
            window.client_records[timestamp_key] = timestamp_value
            logConsole(record_key + ' record updated in Window.')
        }
        if (callback){
            callFunction(callback, [updated_record])
        }
        
        return updated_record
        
    }
    
//// use chrome storage
//    // https://developer.chrome.com/extensions/storage
//    chrome.storage.local.get(record_key, function(data){
//        callback(data[record_key])
//    })
//    chrome.storage.local.set({record_key: record_details}, function(){
//        logConsole(record_key + ' record created in Chrome.')
//    })

}

function loadRecord(record_key, callback=null) {

    /* a function to load record details from local device */

// verify client records in window
    if (!('client_records' in window)){
        window.client_records = {}
    }

// retrieve record
    if (Modernizr.localstorage) {
        var returned_details = localStorage.getItem(record_key)
        try {
            returned_details = JSON.parse(returned_details)
            var record_details = returned_details.value
        } catch(e) {
            var record_details = null
        }
    } else {
        var record_details = window.client_records[record_key]
    }
    if (callback){
        callFunction(callback, [record_details])
    }
    
    return record_details

//// use chrome storage
//    // https://developer.chrome.com/extensions/storage
//    chrome.storage.local.get(record_key, function(data){
//        callback(data[record_key])
//    })

}

function deleteRecord(record_key, timestamp_value=0) {

    /* a function to remove a record from local device */

// verify client records in window
    if (!('client_records' in window)){
        window.client_records = {}
    }

// construct timestamp key
    var timestamp_key = record_key + '_record_timestamp'

// update storage records
    if (Modernizr.localstorage) {
        localStorage.removeItem(record_key)
        if (!timestamp_value){
            localStorage.removeItem(timestamp_key)
        } else {
            var stored_timestamp = JSON.stringify({ value: timestamp_value })
            localStorage.setItem(timestamp_key, stored_timestamp)
        }
        logConsole(record_key + ' record deleted from Local Storage.')
    } else if (record_key in window.client_records) {
        delete window.client_records[record_key]
        if (!timestamp_value){
            delete window.client_records[timestamp_key]
        } else {
            window.client_records[timestamp_key] = timestamp_value
        }
        logConsole(record_key + ' record deleted from Window.')
    }

//// use chrome storage
//    // https://developer.chrome.com/extensions/storage
//    chrome.storage.local.remove(record_key, function(){
//        logConsole(record_key + ' record deleted from Chrome.')
//    })

}

function cleanRecord(record_key) {

    /* a method to remove the deletion marker for a record from the local device */
    
// load existing record timestamps
    var timestamp_key = record_key + '_record_timestamp'

// update
    if (loadRecord(timestamp_key)){
        if (!(loadRecord(record_key))){
            if (Modernizr.localstorage) {
                localStorage.removeItem(timestamp_key)
                logConsole('Deletion marker for ' + record_key + ' removed from Local Storage.')
            } else {
                delete window.client_records[timestamp_key]
                logConsole('Deletion marker for ' + record_key + ' removed from Window.')
            }
        }
    } 
    
}

function clearRecords() {

    /* a function to remove all records from local device */
    
    if (Modernizr.localstorage) {
        for (var i = 0; i < localStorage.length; ++i ) {
            var record_key = localStorage.key(i)
            localStorage.removeItem(record_key)   
        }
        logConsole('All records deleted from Local Storage.')
    } else {
        window.client_records = {}
        logConsole('All records deleted from Window')
    }

}
  
function startingPouchDB(await_sync=true, live_sync=false) {

/* a promise to startup pouch db records */

// construct new promise
    var deferred = $.Deferred()

// validate records in window
    if (!('pouch_db' in window)){
        window.pouch_db = {}
    }
    if (!('pouch_index' in window)){
        window.pouch_index = {}
    }
    if (!('pouch_ddoc' in window)){
        window.pouch_ddoc = {}
    }
    
// retrieve gateway variables
    var gateway_auth = ingestMap(loadRecord('gateway_auth'))
    var gateway_url = ingestString(window.gateway_url)
    var uid = ingestString(gateway_auth.uid)
    var password = ingestString(gateway_auth.password)
    
// initialize pouch databases
    var initialize_promise = initializingPouch(window.pouch_db, gateway_url, uid, password)

// start indexing and syncing
    initialize_promise.done(function(){
    
    // begin indexing
        var index_promise = indexingPouch(window.pouch_db, window.pouch_index, window.pouch_ddoc)
        $.when(index_promise).then(function(){ deferred.resolve() })
        
//    // begin synchronization
//        var sync_promise = syncingPouch(window.pouch_db, gateway_url, uid, password)
//        if (await_sync){
//            $.when(sync_promise, index_promise).then(function(){
//                if (live_sync){
//                    syncingPouch(window.pouch_db, gateway_url, uid, password, live=true)
//                }
//                deferred.resolve()
//            })
//        } else {
//            $.when(index_promise).then(function(){ deferred.resolve() })
//            if (live_sync){
//                $.when(sync_promise).then(function(){
//                    syncingPouch(window.pouch_db, gateway_url, uid, password, live=true)
//                })
//            }
//        }   
        
    })
    
    return deferred.promise()
    
}

function initializingPouch(bucket_map, gateway_url, uid='', password='') {

/* a promise to initialize pairs of local and remote pouchdb databases */

// construct new promise
    var deferred = $.Deferred()

// determine database url
    var db_url = gateway_url
    if (uid){
        const db_cred = '://' + uid + ':' + password + '@'
        db_url = gateway_url.replace(/(:\/\/)/g, db_cred)
    }
    
// construct pouchdb options
    var local_options = {
        // https://pouchdb.com/adapters.html
        // adapter: 'localstorage' 
    }
    var remote_options = {
        ajax: {
            cache: false,
            timeout: 12000,
            crossDomain: true
        },
        skip_setup: true
    }
    var close_promises = []

// iterate over keys in bucket map
    for (var key in ingestMap(bucket_map)){
    
        if (!key.match(/_remote$/) && !key.match(/_handler$/)){
        
        // construct bucket variables
            const local_key = key
            const remote_url = db_url + '/' + key
            const remote_key = key + '_remote'
            
        // if local database does not currently exist
            if (!bucket_map[local_key]){
            
            // create local database and catch adapter errors
                try {
                    bucket_map[local_key] = new PouchDB(local_key, local_options)
                    logConsole(key + ' db created')
                } catch(err) {
                    logConsole(err)
                    if (JSON.stringify(err).indexOf('idb') > -1){
                        local_options['adapter'] = 'websql'
                        bucket_map[local_key] = new PouchDB(local_key, local_options)
                        logConsole(key + ' db created')
                    } else {
                        throw err
                    }
                }
            
            // create remote database
                bucket_map[remote_key] = new PouchDB(remote_url, remote_options)
        
            }
            
        }
        
    }

// resolve promise
    if (close_promises.length){
        $.when(...close_promises).then(function(){
            deferred.resolve(bucket_map) 
        })
    } else {
        deferred.resolve(bucket_map)
    }
    
    return deferred.promise()

}

function syncingPouch(bucket_map, gateway_url, uid='', password='', live=false) {

/* a promise to synchronize pairs of local and remote pouchdb databases */

// construct new promise
    var deferred = new $.Deferred()

// determine database url
    var db_url = gateway_url
    if (uid){
        const db_cred = '://' + uid + ':' + password + '@'
        db_url = gateway_url.replace(/(:\/\/)/g, db_cred)
    }
    
// construct sync variables
    var sync_options = { live: true, retry: true };
    var sync_array = []

// iterate over keys in bucket map
    for (var key in ingestMap(bucket_map)){
    
        if (!key.match(/_remote$/) && !key.match(/_handler$/)){
        
        // construct bucket variables
            const local_key = key
            const remote_url = db_url + '/' + key
            const remote_key = key + '_remote'
            const sync_key = key + '_handler'
            const storage_key = 'pouch_sync_' + key + '_handler'
            const canceled_message = key + ' syncing canceled'
            const started_message = key + ' sync started'
            const starting_message = key + ' syncing started'
            const restarted_message = key + ' sync restarted'
            const completed_message = key + ' sync complete'
        
//        // define a sync promise
//            function _sync_promise(sync_process, sync_key){
//                var _deferred = new $.Deferred()
//                localStorage.setItem(storage_key, '1')
//                sync_process.on('complete', function(info){
//                    localStorage.removeItem(storage_key)
//                    _deferred.resolve()
//                    logConsole(completed_message)
//                })
//                return _deferred.promise()
//            }

        // define a sync promise
            function _sync_promise(sync_process, sync_key){
                var _deferred = new $.Deferred()
                sync_process.on('complete', function(info){
                    delete bucket_map[sync_key]
                    _deferred.resolve()
                    logConsole(completed_message)
                })
                return _deferred.promise()
            }
        
        // determine whether sync is already running
            if (!(ingestString(localStorage.getItem(storage_key)))){

            // begin live synchronize process
                if (live){

                    bucket_map[sync_key] = PouchDB.sync(local_key, remote_url, sync_options)

                // lock sync process
                    // localStorage.setItem(storage_key, '1')
                    bucket_map[sync_key].on('complete', function(info){
                        delete bucket_map[sync_key]
                        // localStorage.removeItem(storage_key)
                        logConsole(canceled_message)
                    }).on('error', function(err){
                        delete bucket_map[sync_key]
                        // localStorage.removeItem(storage_key)
                        logConsole(err)
                    }).on('change', function(change){
                        logConsole('change')
                        logConsole(change)
                    }).on('paused', function(info){
                        // logConsole('paused')
                        // logConsole(info)
                    }).on('active', function(){
                        // logConsole('active')
                    })   
                    logConsole(starting_message)

            // or sync once
                } else {
                    bucket_map[sync_key] = PouchDB.sync(local_key, remote_url)
                    sync_array.push(_sync_promise(bucket_map[sync_key], sync_key))
                    logConsole(started_message)
                }

            }

        }
        
    }

// resolve promise
    if (sync_array.length){
        $.when(...sync_array).then(function(){
            deferred.resolve(bucket_map)
        })
    } else {
        deferred.resolve(bucket_map)
    }
    
    return deferred.promise()
    
}

function indexingPouch(bucket_map, index_map, ddoc_map=null) {

/* a promise to create an index for a local pouch db database */

// construct new promise
    var deferred = new $.Deferred()
    
// initialize indexes
    var index_promises = []
    for (var key in index_map){
        if (key in bucket_map){
            const index_array = ingestArray(index_map[key])
            for (var i = 0; i < index_array.length; i++){
                const index_options = ingestMap(index_array[i])
                const local_key = key
                if (mapSize(index_options)){
                    index_promises.push(bucket_map[local_key].createIndex(index_options))
                    logConsole(local_key + ' index created')
                } 
            }     
        }   
    }

// initialize design docs
    if (ddoc_map){
        for (var k in ddoc_map){
            if (k in bucket_map){
                const ddoc_array = ingestArray(ddoc_map[k])
                for (var j = 0; j < ddoc_array.length; j++){
                    const ddoc_options = ingestMap(ddoc_array[j])
                    const local_k = k
                    if (mapSize(ddoc_options)){
                        function _create_ddoc(){
                            var _deferred = new $.Deferred()
                            bucket_map[local_k].put(ddoc_options).catch(function(err){
                            // report conflicts
                                if (err.name !== 'conflict') {
                                    throw err;
                                }
                                _deferred.resolve()
                            // ignore if doc already exists
                            }).then(function(){
                                _deferred.resolve()
                                logConsole(local_k + ' ddoc created')
                            })
                            return _deferred.promise()
                        }
                        index_promises.push(_create_ddoc())
                    }
                }
            }
        }
    }

// resolve promise
    if (!index_promises.length){
        deferred.resolve()
    } else {
        $.when(...index_promises).then(function(){
            deferred.resolve() 
        })
    }
    return deferred.promise()

}

function stoppingPouch(bucket_map, error_handler=null) {

    /* a promise method to deconstruct PouchDB processes and remove local databases */
    
// construct new promise
    var deferred = new $.Deferred()

// define a recursive sync job
    function _sync_job(syncing_queue){
            
        var _deferred = new $.Deferred()
        
        if (syncing_queue.length){
            const sync_job = syncing_queue.pop()
            bucket_map[sync_job.local].sync(bucket_map[sync_job.remote]).then(function(){
                logConsole(sync_job.local + ' sync complete')
                _sync_job(syncing_queue).done(function(){
                    _deferred.resolve()
                }).fail(function(err){
                    _deferred.reject(err)
                })
            }).catch(function(err){
                _deferred.reject(err)
            })
        } else {
            _deferred.resolve()
        }
        
        return _deferred.promise()
    
    }
        
// define a final syncing process
    function _last_sync(){
    
        var _deferred = new $.Deferred()
        
        var syncing_processes = []
        var syncing_queue = []
        for (var key in ingestMap(bucket_map)){
            if (!key.match(/_handler$/) && !key.match(/_remote$/)){
                const remote_key = key + '_remote'
                if (remote_key in bucket_map){
                    syncing_queue.push({ local: key, remote: remote_key })
                }
            }
        }

        if (syncing_queue.length){
            _sync_job(syncing_queue).done(function(){
                _deferred.resolve()
            }).fail(function(err){
                _deferred.reject(err)
            })
        } else {
            _deferred.resolve()
        }
      
        return _deferred.promise()
        
    }
    
// perform a final synchronization
    var last_sync = _last_sync()

// when synchronization finishes
    last_sync.done(function(){
    
    // determine if there are any on-going sync process
        var canceling_sync = []
        var closing_keys = []
        for (var key in ingestMap(bucket_map)){
            if (key.match(/_handler$/)){
                canceling_sync.push(bucket_map[key].cancel())
            } else if (key.match(/_remote$/)) {
                closing_keys.push(key)
            } else {
                closing_keys.push(key)
            }
        }
    
    // cancel syncing
        if (canceling_sync.length){
            $.when(...canceling_sync).then(function(){
            
            // close remote databases and destroy local databases
                var closing_dbs = []
                for (var i = 0; i < closing_keys.length; i++){
                    const db_key = closing_keys[i]
                    try {
                        if (db_key.match(/_handler$/) || db_key.match(/_remote$/)){
                            closing_dbs.push(bucket_map[db_key].close())
                        } else {
                            closing_dbs.push(bucket_map[db_key].destroy())
                        }
                    } catch(err) {
                        logConsole(err)
                    }
                }
            
            // reset pouch db fields to null and resolve promise
                if (closing_dbs.length){
                    $.when(...closing_dbs).then(function(){
                        for (var key in bucket_map){
                            if (!key.match(/_remote$/) && !key.match(/_handler$/)){
                                logConsole(key + ' destroyed')
                            }
                            bucket_map[key] = null
                        }
                        deferred.resolve(closing_keys)
                    })
                } else {
                    deferred.resolve([])
                }
             
            })
            
        } else {
        
        // close remote databases and destroy local databases
            var closing_dbs = []
            for (var i = 0; i < closing_keys.length; i++){
                const db_key = closing_keys[i]
                try {
                    if (db_key.match(/_handler$/) || db_key.match(/_remote$/)){
                        closing_dbs.push(bucket_map[db_key].close())
                    } else {
                        closing_dbs.push(bucket_map[db_key].destroy())
                    }
                } catch(err) {
                    logConsole(err)
                }
                
            }
        
        // reset pouch db fields to null and resolve promise
            if (closing_dbs.length){
                $.when(...closing_dbs).then(function(){
                    for (var key in bucket_map){
                        if (!key.match(/_remote$/) && !key.match(/_handler$/)){
                            logConsole(key + ' destroyed')
                        }
                        bucket_map[key] = null
                    }
                    deferred.resolve(closing_keys)
                })
            } else {
                deferred.resolve([])
            }
            
        }
    
    })

// handle failed sync
    last_sync.fail(function(err){
    
        if (error_handler){
            error_handler(err)
        }
        
    })
     
    return deferred.promise()

}

function stoppingPouchSync(bucket_map) {

// construct new promise
    var deferred = new $.Deferred()
    
// cancel synchronization processes
    var canceling_sync = []
    for (var key in ingestMap(bucket_map)){
        if (key.match(/_handler$/)){
            if (bucket_map[key]){
                canceling_sync.push(bucket_map[key].cancel())
            }
        }
    }

// resolve promise
    if (canceling_sync.length){
        $.when(...canceling_sync).then(function(){
            deferred.resolve()
        })
    } else {
        deferred.resolve()
    }
    
    return deferred.promise()
    
}

function searchingPouchRevs(bucket, doc_id, query_criteria) {

// TODO function to search through revision history on pouch db

// define a recursive search function
    function _find_rev(bucket, doc_id, query_criteria, rev_queue){
            
        var _deferred = new $.Deferred()
        
        if (rev_queue.length){
            const _rev_id = rev_queue.pop()
            bucket.get(doc_id, { rev: _rev_id }).done(function(_rev_result){
                if (_rev_result.dt <= dt){
                    _deferred.resolve(_rev_result)
                } else {
                    _find_rev(doc_id, dt, rev_queue).done(function(_found_result){
                        _deferred.resolve(_found_result)
                    })
                }
            }).catch(function(err){
                _deferred.reject(err)
            })
        } else {
            _deferred.reject()
        }
        
        return _deferred.promise()
    
    }

// construct rev queue
    var rev_queue = []
    for (var j = 0; j < rev_results._revs_info.length; j++){
        rev_queue = rev_results._revs_info[j].rev
        
    }
    
}

// custom-made localstorage db classes

function saveItem(table_key, item_key, item_details, item_timestamp=0.0, overwrite=true, callback=null) {

    /* a method to save an item to a table in storage on local device */
    
    var title = 'saveItem'
    
// verify client tables in window
    if (!('client_records' in window)){
        window.client_records = {}
    }

// validate inputs
    if (!ingestString(table_key)){
        throw title + '(table_key="") value must be a string.'
    } else if (!ingestString(item_key)){
        throw title + '(item_key="...") value must be a string.'
    } else if (!isMap(item_details)){
        throw title + 'item_details={...}) value must be a map.'
    }

// determine timestamp to add to item
    var timestamp_value = $.now() / 1000
    if (ingestNumber(item_timestamp)){
        timestamp_value = item_timestamp
    }

// retrieve table records from local storage
    if (Modernizr.localstorage) {
        var returned_details = localStorage.getItem(table_key)
        try {
            returned_details = JSON.parse(returned_details)
            var table_records = returned_details.value
        } catch(e) {
            var table_records = {}
        }
    } else {
        var table_records = window.client_records[table_key]
        if (typeof(table_records) == 'undefined'){
            var table_records = {}
        }
    }
 
// update item in table
    var storage_action = ' updated in '
    if (!(item_key in table_records)){
        storage_action = ' added to '
        table_records[item_key] = {
            dt: timestamp_value,
            item: item_details
        }
    } else if (overwrite){
        storage_action = ' overwritten in '
        table_records[item_key] = {
            dt: timestamp_value,
            item: item_details
        }
    } else {
        table_records[item_key] = {
            dt: timestamp_value,
            item: upsertValues(item_details, table_records[item_key].item)
        }
    }
 
// save table records to local storage
    if (Modernizr.localstorage){
        var stored_details = JSON.stringify({ value: table_records })
        localStorage.setItem(table_key, stored_details)
        logConsole('Item ' + item_key + storage_action + table_key + ' on Local Storage.')
    } else {
        window.client_records[table_key] = table_records
        logConsole('Item ' + item_key + storage_action + table_key + ' in window.')
    }

// invoke callback
    var callback_map = {
        key: item_key,
        item: item_details,
        dt: timestamp_value
    }
    if (callback){
        callFunction(callback, [callback_map])
    }

    return callback_map
    
}

function loadItem(table_key, item_key, callback=null) {

    /* a method to load an item and its timestamp from a table in storage on local device */
    
    var title = 'loadItem'
    
// verify client tables in window
    if (!('client_records' in window)){
        window.client_records = {}
    }

// validate inputs
    if (!ingestString(table_key)){
        throw title + '(table_key="") value must be a string.'
    } else if (!ingestString(item_key)){
        throw title + '(item_key="...") value must be a string.'
    }

// retrieve table records from local storage
    if (Modernizr.localstorage) {
        var returned_details = localStorage.getItem(table_key)
        try {
            returned_details = JSON.parse(returned_details)
            var table_records = returned_details.value
        } catch(e) {
            var table_records = {}
        }
    } else {
        var table_records = window.client_records[table_key]
        if (typeof(table_records) == 'undefined'){
            var table_records = {}
        }
    }

// retrieve item value
    var callback_map = null
    if (!(item_key in table_records)){
        throw title + '(item_key="' + item_key + '") does not exist in table ' + table_key + '.'
    } else {
        var item_metadata = table_records[item_key]
        callback_map = {
            key: item_key,
            item: item_metadata.item,
            dt: item_metadata.dt
        }
    }

// invoke callback    
    if (callback){
        callFunction(callback, [callback_map])
    }
    
    return callback_map
    
}

function listItems(table_key, sort_criteria=null, filter_criteria=null, max_results=0, callback=null) {
    
    /* a method to find an array of items (and their timestamps) from a table in storage on local device */
    
    var title = 'listItems'
    
// verify client tables in window
    if (!('client_records' in window)){
        window.client_records = {}
    }

// validate inputs
    if (!ingestString(table_key)){
        throw title + '(table_key="") value must be a string.'
    }
    max_results = ingestNumber(max_results)
    sort_criteria = ingestArray(sort_criteria)

// retrieve table records from local storage
    if (Modernizr.localstorage) {
        var returned_details = localStorage.getItem(table_key)
        try {
            returned_details = JSON.parse(returned_details)
            var table_records = returned_details.value
        } catch(e) {
            var table_records = {}
        }
    } else {
        var table_records = window.client_records[table_key]
        if (typeof(table_records) == 'undefined'){
            var table_records = {}
        }
    }

// sort items
    var sorted_records = []
    var table_keys = $.map(table_records, function(v, i){ return i })
    table_keys.sort()
    var metadata_key = table_key + '_item_metadata_' + $.now().toString()
    for (var i = 0; i < table_keys.length; i++){
        var item_key = table_keys[i]
        var item_details = table_records[item_key].item
        item_details[metadata_key] = {
            key: item_key,
            dt: table_records[item_key].dt
        }
        sorted_records.push(item_details)
    }
    if (sort_criteria.length){
        sorted_records = sortArray(sorted_records, sort_criteria)
    }

// filter items
    var filtered_records = filterArray(sorted_records, filter_criteria, max_results)
    
// reconstruct callback array
    var callback_array = []
    for (var i = 0; i < filtered_records.length; i++){
        callback_array.push(filtered_records[i][metadata_key].key)
    }

// invoke callback
    if (callback){
        callFunction(callback, [callback_array])
    }

    return callback_array

}

function deleteItem(table_key, item_key, marker_timestamp=0.0, callback=null) {

    /* a method to delete an item to a table in storage on local device */
    
    var title = 'deleteItem'
    
// verify client tables in window
    if (!('client_records' in window)){
        window.client_records = {}
    }

// validate inputs
    if (!ingestString(table_key)){
        throw title + '(table_key="") value must be a string.'
    } else if (!ingestString(item_key)){
        throw title + '(item_key="...") value must be a string.' 
    }
    
// retrieve table records from local storage
    if (Modernizr.localstorage) {
        var returned_details = localStorage.getItem(table_key)
        try {
            returned_details = JSON.parse(returned_details)
            var table_records = returned_details.value
        } catch(e) {
            var table_records = {}
        }
    } else {
        var table_records = window.client_records[table_key]
        if (typeof(table_records) == 'undefined'){
            var table_records = {}
        }
    }

// retrieve marker records from local storage
    if (ingestNumber(marker_timestamp)){
        
        var marker_key = table_key + '_deletion_markers'
        if (Modernizr.localstorage) {
            var returned_details = localStorage.getItem(marker_key)
            try {
                returned_details = JSON.parse(returned_details)
                var table_markers = returned_details.value
            } catch(e) {
                var table_markers = {}
            }
        } else {
            var table_markers = window.client_records[marker_key]
            if (typeof(table_markers) == 'undefined'){
                var table_markers = {}
            }
        }
    }

// delete item from table records
    var callback_status = false
    if (item_key in table_records){
        delete table_records[item_key]
        callback_status = true
        
    // save updated table records to local storage
            if (Modernizr.localstorage){
                var stored_details = JSON.stringify({ value: table_records })
                localStorage.setItem(table_key, stored_details)
                logConsole('Item ' + item_key + ' deleted from ' + table_key + ' on Local Storage.')
            } else {
                window.client_records[table_key] = table_records
                logConsole('Item ' + item_key + ' deleted from ' + table_key + ' in window.')
            }
        
        if (ingestNumber(marker_timestamp)){
            table_markers[item_key] = marker_timestamp
            
        // save updated deletion markers to local storage
            if (Modernizr.localstorage){
                var stored_details = JSON.stringify({ value: table_markers })
                localStorage.setItem(marker_key, stored_details)
            } else {
                window.client_records[marker_key] = table_markers
            }
            
        }
    }

// invoke callback
    if (callback){
        callFunction(callback, [callback_status])
    }

    return callback_status
    
}


/**
* FORMS JAVASCRIPT EXTENSION
* @author rcj1492
* @license Â©2016-2018 Collective Acuity
* @email support@collectiveacuity.com
*
* requires: 
* jquery
* lab.js
**/

//// import dependencies
//import $ from 'jquery'
//import { logConsole, unpackKwargs, ingestMap, convertElement } from 'lab'

function showMessage(message_kwargs) {

/* a method to display a message next to an element */

// declare default properties
    var message_dict = {
        'anchor_selector': '#header_middle',
        'message_text': 'Status Message',
        'message_html': '',
        'message_status': 'success',
        'message_location': 'bottom',
        'timeout': 0
    }

// unpack kwargs input
    unpackKwargs(message_kwargs, message_dict, 'showMessage')

// define layout variables
    var anchor_selector = message_dict.anchor_selector
    var message_text = message_dict.message_text
    var message_status = message_dict.message_status
    var message_location = message_dict.message_location
    var message_html = message_dict.message_html
    var timeout = message_dict.timeout
    var anchor_position = $(anchor_selector).offset()
    var anchor_width = $(anchor_selector).width()
    var anchor_height = $(anchor_selector).height()
    var scroll_amount = $('html, body').scrollTop()
    var dialog_id = 'dialog_status_message_' + anchor_selector.replace('#','').toLowerCase()
    var dialog_selector = '#' + dialog_id

// remove any previous dialogs with same name
    if ($(dialog_selector).length){
        $(dialog_selector).remove()
    }

// construct HTML content
    var dialog_html = '<div id="' + dialog_id + '" style="display: none;"></div>'
    var class_list = [ 
        'dialog-tooltip',
        'padding-vertical-5', 
        'padding-horizontal-5', 
        'font-mini',
        'text-wrap'
    ]
    if (message_status == 'success') {
        class_list.push('font-success');
    } else if (message_status == 'error') {
        class_list.push('font-error');
    }
    if (message_html){
        class_list.push('page-tooltip')
    } else {
        class_list.push('page-status-message')
    }
    var class_string = class_list.join(' ')

// inject dialog into DOM
    $('body').append(dialog_html)
    var message_dialog = $(dialog_selector)
    message_dialog.addClass(class_string)
    if (message_html){
        message_dialog.html(message_html)
    } else {
        message_dialog.text(message_text)
    }
    
// calculate position for message
    if (message_location == 'bottom'){
        var message_width = message_dialog.width();
        var message_padding_top = message_dialog.css('padding-top')
        var message_padding_top = parseFloat(message_padding_top.replace(/[^-\d\.]/g, ''))
        var message_top = anchor_position.top + anchor_height + message_padding_top - scroll_amount
        var message_left = anchor_position.left + (anchor_width / 2) - (message_width / 2)
    } else if (message_location == 'top'){
        var message_width = message_dialog.width();
        var message_height = message_dialog.height();
        var message_padding_bottom = message_dialog.css('padding-bottom')
        var message_padding_bottom = parseFloat(message_padding_bottom.replace(/[^-\d\.]/g, ''))
        var message_top = anchor_position.top - message_height - (message_padding_bottom * 3) - scroll_amount
        var message_left = anchor_position.left + (anchor_width / 2) - (message_width / 2)
    } else if (message_location == 'right'){
        var message_padding_top = message_dialog.css('padding-top')
        var message_padding_top = parseFloat(message_padding_top.replace(/[^-\d\.]/g, ''))
        var message_padding_right = message_dialog.css('padding-right')
        var message_padding_right = parseFloat(message_padding_right.replace(/[^-\d\.]/g, ''))
        var message_top = anchor_position.top - message_padding_top - scroll_amount
        var message_left = anchor_position.left + anchor_width + message_padding_right
    } else if (message_location == 'left'){
        var message_width = message_dialog.width();
        var message_padding_top = message_dialog.css('padding-top')
        var message_padding_top = parseFloat(message_padding_top.replace(/[^-\d\.]/g, ''))
        var message_padding_right = message_dialog.css('padding-right')
        var message_padding_right = parseFloat(message_padding_right.replace(/[^-\d\.]/g, ''))
        var message_top = anchor_position.top - message_padding_top - scroll_amount
        var message_left = anchor_position.left - message_width - (message_padding_right * 2.5)
    } else {
        var message_width = message_dialog.width();
        var message_padding_top = message_dialog.css('padding-top')
        var message_padding_top = parseFloat(message_padding_top.replace(/[^-\d\.]/g, ''))
        var message_top = anchor_position.top - message_padding_top
        var message_left = anchor_position.left + (anchor_width / 2) - (message_width / 2)
    }

// correct width coordinates for viewport
    var viewport_width = $(window).width()
    if (message_left < 0){
        message_left = 0
    }
    if (message_left + message_width > viewport_width){
        message_left = viewport_width - message_width
    }
    
// inject position values into DOM
    message_dialog.css({top: message_top, left: message_left})
    if (timeout){
        setTimeout(function(){ message_dialog.fadeOut() }, timeout)
    }
    message_dialog.fadeIn()

}

function hideMessage(anchor_selector) {

/* a method to hide the message associated with an element */

// retrieve div variable
    var dialog_selector = '#dialog_status_message_' + anchor_selector.replace('#','').toLowerCase()

// update the DOM
    $(dialog_selector).hide()

}

function inputValidator(input_value, field_criteria) {

/* a method to test string input for valid criteria */

// validate input
    var must_contain = ingestMap(field_criteria.must_contain)
    var must_not_contain = ingestMap(field_criteria.must_not_contain)
    var identical_to = ingestMap(field_criteria.identical_to)
    var equal_to = ingestMap(field_criteria.equal_to)
    var max_length = ingestNumber(field_criteria.max_length)

// construct empty values
    var required_error = ''
    var prohibited_error = ''

// test input for required regex
    for (var key in must_contain){
        var test_pattern = new RegExp(key,'i');
        if (!test_pattern.test(input_value)){
            required_error = must_contain[key];
            break;
        };
    };

// test input for matching other input
    for (var key in identical_to){
        if (!($(key).length)){
            logConsole(key + ' is not a valid selector.')
        } else if ($(key).val() != input_value){
            required_error = identical_to[key];
            break;
        }
    }

// test input for expected value
    for (var key in equal_to){
        if (key != input_value){
            required_error = equal_to[key];
            break;
        }
    }

// test input for prohibited regex
    for (var key in must_not_contain){
        var test_pattern = new RegExp(key,'i');
        if (test_pattern.test(input_value)){
            prohibited_error = must_not_contain[key];
            break;
        };
    };

// test input for max length
    if (max_length){
        if (input_value.length > max_length){
            prohibited_error = 'contain contain more than ' + max_length.toString() + ' characters.'
        }
    }

// return errors found as map
    return {
        required: required_error,
        prohibited: prohibited_error
    }

}

function submitValidator(input_value, field_title, field_criteria, anchor_selector, hidden_title=''){

/* a method to validate an input value prior to submission */

// retrieve error report from error finder method
    var error_report = inputValidator(input_value, field_criteria);

// construct default message
    var message_kwargs = {
        'anchor_selector': anchor_selector,
        'message_text': 'Status Message',
        'message_status': 'error',
        'message_location': 'bottom'
    }

// update DOM to reflect report
    if (error_report.prohibited){
        var error_message = 'Oops! '
        if (!field_title){
            error_message += 'Input '
        } else if (hidden_title){
            error_message += hidden_title + ' ' + error_report.required
        } else {
            error_message += field_title + ' '
        }
        error_message += error_report.prohibited
        message_kwargs.message_text = error_message
        showMessage(message_kwargs)
        return null
    }
    else if (error_report.required){
        var error_message = 'Errr! '
        if (!input_value){
            error_message += field_title + ' cannot be empty.'
        } else if (hidden_title){
            error_message += hidden_title + ' ' + error_report.required
        } else {
            error_message += '"' + input_value + '" ' + error_report.required
        }
        message_kwargs.message_text = error_message
        showMessage(message_kwargs)
        return null;
    }
    else {
        return input_value
    }

}

function inputHandler(input_selector, field_title, field_criteria, callback, enter_submit=true, auto_save=true, hidden_title='') {

/* a method to bind a validation & request handler to an input field */

// block normal enter behavior
    $(input_selector).keypress(function( event ){
        var key_code = event.keyCode
        if (key_code === 10 || key_code === 13){
            event.preventDefault();
        }
    })

// add typing event handler
    $(input_selector).keyup(function( event ){
    
    // retrieve key code
        var key_code = event.keyCode;

    // retrieve input value
        if ($(this).get(0).isContentEditable){
            var input_value = $(this).text()
        } else {
            var input_value = $(this).val()
        }

    // retrieve error report from error finder method
        var error_report = inputValidator(input_value, field_criteria);

    // construct default message
        var message_kwargs = {
            'anchor_selector': input_selector,
            'message_text': 'Status Message',
            'message_status': 'error',
            'message_location': 'bottom'
        }

    // update DOM to reflect report
        if (error_report.prohibited){
            var error_message = 'Oops! '
            if (!field_title){
                error_message += 'Input '
            } else {
                error_message += field_title + ' '
            }
            error_message += error_report.prohibited
            message_kwargs.message_text = error_message
            showMessage(message_kwargs)
        }
        else if ((key_code == 10 || key_code == 13) && enter_submit){

            if (error_report.required){

                var error_message = 'Errr! '
                if (!input_value){
                    error_message += field_title + ' cannot be empty.'
                } else if (hidden_title){
                    error_message += hidden_title + ' ' + error_report.required
                } else {
                    error_message += '"' + input_value + '" ' + error_report.required
                }
                message_kwargs.message_text = error_message
                showMessage(message_kwargs)

            } else {
                callback(input_value)
            }

        }
        else {
            hideMessage(input_selector);
        }

    })

// add focusout event handler
    if (auto_save){

        $(input_selector).focusout(function( event ){

        // retrieve input value
            if ($(this).get(0).isContentEditable){
                var input_value = $(this).text()
            } else {
                var input_value = $(this).val()
            }

        // validate input value
            var valid_input = submitValidator(input_value, field_title, field_criteria, input_selector, hidden_title)

        // submit input to endpoint
            if (valid_input === null){

            } else {
                callback(valid_input)
            }

        })

    }
    
}

function statusIconHandler(input_selector, error_selector, field_criteria) {

/* a method to bind a validation handler to a status icon linked to an input field */

// add typing event trigger
    $(input_selector).keyup(function(){

    // retrieve input value and success element tag name
        if ($(this).get(0).isContentEditable){
            var input_value = $(this).text()
        } else {
            var input_value = $(this).val()
        }
        console.log(input_value)

    // retrieve error report from error finder method
        var error_report = inputValidator(input_value, field_criteria)

    // update DOM according to error report
        if (input_value == ''){
            $(error_selector).hide()
        }
        else if (error_report.required || error_report.prohibited){
            $(error_selector).show()
        }
        else {
            $(error_selector).hide()
        }
        
    })

}

function statusButtonHandler(input_selector, error_selector, submit_selector, field_title, field_criteria, callback, hidden_title='') {

/* a method to bind a validation & request handler to a button linked to an input field */

// construct submit handling sub-method
    function _submit_handling(){

        $(submit_selector).click(function(){

        // retrieve input value
            var input_value = $(input_selector).val();

        // validate input value
            var valid_input = submitValidator(input_value, field_title, field_criteria, input_selector, hidden_title)

        // submit input to endpoint
            if (valid_input === null){

            } else {
                callback(valid_input)
            }

        })

    }

// add typing event trigger
    $(input_selector).keyup(function(event){
        
    // retrieve input value and success element tag name
        if ($(this).get(0).isContentEditable){
            var input_value = $(this).text()
        } else {
            var input_value = $(this).val()
        }
        var submit_tag = 'a'
        if ($(submit_selector).length){
            submit_tag = $(submit_selector)[0].tagName.toLowerCase()
        }

    // retrieve error report from error finder method
        var error_report = inputValidator(input_value, field_criteria);

    // update DOM according to error report
        if (input_value == ''){

        // remove blocking icon
            $(error_selector).hide();

        // convert span into button
            if (submit_tag == 'span') {

                convertElement(submit_selector, 'a')

            // add back submit handling
                _submit_handling()

            }

        }
        else if (error_report.required || error_report.prohibited){

        // add blocking icon
            $(error_selector).show()

        // convert button into span
            if (submit_tag == 'a') {
                convertElement(submit_selector, 'span')
            }
        }
        else {

        // remove blocking icon
            $(error_selector).hide();

        // convert span into button
            if (submit_tag == 'span') {

                convertElement(submit_selector, 'a')

            // add back submit handling
                _submit_handling()

            }

        }

    })

// add submit handling for starting value
    _submit_handling()

}

//// WIP
 
function successMessage(response, anchor_selector, message_location) {

/* a method to inject a tooltip message into the DOM from a successful ajax request */

// retrieve variables from response
    try {
        var response_body = JSON.parse(response)
    } catch(e) {
        var response_body = {}
    }

// construct message variables from response body
    var message_status = response_body.status
    var message_content = response_body.message
    var dialog_title = response_body.status
    var dialog_message = '<p>' + response_body.message + '</p>'

// update DOM
    if (typeof(anchor_selector) === 'string'){
        if (typeof(message_location) != 'string') {
            var message_location = ''
        }
        showMessage(anchor_selector, message_content, message_status, message_location, 2000)
    } else {
        $('#dialog_middle_center_header_title').text(dialog_title);
        $('#dialog_middle_center_content_middle').html(dialog_message);
        openDialog('#dialog_middle_center');
    }

}

function errorMessage(response, exception, anchor_selector, message_location) {

/* a method to inject a tooltip message into the DOM from a failed ajax request */

// retrieve variables from response
    var response_code = response.status
    try {
        var response_body = JSON.parse(response.responseText)
    } catch(e) {
        var response_body = {}
    }

// construct html variables from error codes
    var message_content = 'Errr! '
    if (response_code === 0) {
        message_content += 'No connection. Check network settings.'
    } else if (response_code == 404) {
        message_content += 'Page not found. [404]'
    } else if (response_code == 500) {
        message_content += 'Internal Server Error [500].'
    } else if (exception === 'timeout') {
        message_content += 'Request timeout.'
    } else if (exception === 'abort') {
        message_content += 'Request aborted.'
    }

// modify message depending upon response text
    if (typeof(response_body.status) === 'string') {
        var message_status = response_body.status
        var dialog_title = response_body.status
    } else {
        var message_status = 'error'
        var dialog_title = response_code
    }
    if (typeof(response_body.message) === 'string' ){
        var message_content = response_body.message
        var dialog_message = '<p>' + response_body.message + '</p>'
    } else {
        var dialog_message = '<p>' + message_content + '</p>'
    }

// update DOM
    if (typeof(anchor_selector) === 'string'){
        if (typeof(message_location) != 'string') {
            var message_location = ''
        }
        showMessage(anchor_selector, message_content, message_status, message_location)
    } else {
        $('#dialog_middle_center_header_title').text(dialog_title);
        $('#dialog_middle_center_content_middle').html(dialog_message);
        openDialog('#dialog_middle_center');
    }

}

function waitMessage(anchor_selector, base_message, message_status, message_location) {

/* a method to inject a tooltip message into the DOM while waiting for a callback */

// validate optional inputs
    if (typeof(message_status) === 'undefined'){ var message_status = '' }
    if (typeof(message_location) === 'undefined'){ var message_location = 'overlay' }

// retrieve page variables
    var dialog_id = 'dialog_status_message_' + anchor_selector.replace('#','').toLowerCase()
    var dialog_selector = '#' + dialog_id;

// update DOM with progress message
    var start_message = new String(base_message)
    var base_length = base_message.length
    for (var i = 0; (i + base_length) < (base_length * 2); i++){
        start_message += '&nbsp;'
    };
    showMessage(anchor_selector, start_message, message_status, message_location)

// recursive progress message until wait completes
    function _update_message(base_message) {

        var base_length = base_message.length
        var updated_message = new String(base_message);
        var message_box = $(dialog_selector);

        function _increment(count){

            if (!(count % base_length)){
                updated_message = new String(base_message)
            } else {
                updated_message += '.'
            }
            var total_message = new String(updated_message)
            var message_length = updated_message.length
            for (var i = 0; (i + message_length) < (base_length * 2); i++){
                total_message += '&nbsp;'
            };
            message_box.html(total_message)
            setTimeout(function() {
                if (message_box.is(':visible')){ _increment(++count); }
            }, 125);
        }

        _increment(0);

    }

    _update_message(base_message);

}
/**
* STACKOVERFLOW JAVASCRIPT EXTENSION
* @license https://creativecommons.org/licenses/by-sa/2.5/
*
* VisibilityListener
* @source https://stackoverflow.com/a/1060034/4941585
* @author community wiki
*
* BrowserDetect
* @source https://stackoverflow.com/a/13480430/4941585
* @author https://stackoverflow.com/users/1582029/code-uniquely
*
* syntaxHighlight
* @source https://stackoverflow.com/a/7220510/4941585
* @author https://stackoverflow.com/users/27862/user123444555621
**/

function VisibilityListener(callback=null) {

    /**
    * @source https://stackoverflow.com/a/1060034/4941585
    * @author community wiki
    **/
    
    var hidden = "hidden";

// Standards:
    if (hidden in document){
        document.addEventListener("visibilitychange", onchange);
    } else if ((hidden = "mozHidden") in document){
        document.addEventListener("mozvisibilitychange", onchange);
    } else if ((hidden = "webkitHidden") in document){
        document.addEventListener("webkitvisibilitychange", onchange);
    } else if ((hidden = "msHidden") in document){
        document.addEventListener("msvisibilitychange", onchange);
    }
// IE 9 and lower:
    else if ("onfocusin" in document){
        document.onfocusin = document.onfocusout = onchange;
    }
// All others:
    else {
        window.onpageshow = window.onpagehide = window.onfocus = window.onblur = onchange;
    }

// define function for change of status
    function onchange (evt) {
        var v = "visible"
        var h = "hidden"
        var evtMap = {
            focus:v, 
            focusin:v, 
            pageshow:v, 
            blur:h, 
            focusout:h, 
            pagehide:h
        }
        
        evt = evt || window.event;
        if (evt.type in evtMap){
            document.body.className = evtMap[evt.type];
        } else {
            document.body.className = this[hidden] ? "hidden" : "visible";
        }
        if (callback){
            callback(document.body.className)
        }
    }

// set the initial state (but only if browser supports the Page Visibility API)
    if ( document[hidden] !== undefined ){
        onchange({type: document[hidden] ? "blur" : "focus"});
    }
    
}

var BrowserDetect = {

    /**
    * @source https://stackoverflow.com/a/13480430/4941585
    * @author https://stackoverflow.com/users/1582029/code-uniquely
    **/
    
    init: function () {
        this.browser = this.searchString(this.dataBrowser) || "Other";
        this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "Unknown";
    },
    searchString: function (data) {
        for (var i = 0; i < data.length; i++) {
            var dataString = data[i].string;
            this.versionSearchString = data[i].subString;

            if (dataString.indexOf(data[i].subString) !== -1) {
                return data[i].identity;
            }
        }
    },
    searchVersion: function (dataString) {
        var index = dataString.indexOf(this.versionSearchString);
        if (index === -1) {
            return;
        }

        var rv = dataString.indexOf("rv:");
        if (this.versionSearchString === "Trident" && rv !== -1) {
            return parseFloat(dataString.substring(rv + 3));
        } else {
            return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
        }
    },

    dataBrowser: [
        {string: navigator.userAgent, subString: "Edge", identity: "MS Edge"},
        {string: navigator.userAgent, subString: "MSIE", identity: "Explorer"},
        {string: navigator.userAgent, subString: "Trident", identity: "Explorer"},
        {string: navigator.userAgent, subString: "Firefox", identity: "Firefox"},
        {string: navigator.userAgent, subString: "Opera", identity: "Opera"},  
        {string: navigator.userAgent, subString: "OPR", identity: "Opera"},  

        {string: navigator.userAgent, subString: "Chrome", identity: "Chrome"}, 
        {string: navigator.userAgent, subString: "Safari", identity: "Safari"}       
    ]
    
}

function syntaxHighlight(json) {

    /**
    * @source https://stackoverflow.com/a/7220510/4941585
    * @author https://stackoverflow.com/users/27862/user123444555621
    **/
    
    if (typeof(json) != 'string') {
         json = JSON.stringify(json, undefined, 2);
    }
    
    json = json.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
        var cls = 'number';
        if (/^"/.test(match)) {
            if (/:$/.test(match)) {
                cls = 'key';
            } else {
                cls = 'string';
            }
        } else if (/true|false/.test(match)) {
            cls = 'boolean';
        } else if (/null/.test(match)) {
            cls = 'null';
        }
        return '<span class="' + cls + '">' + match + '</span>';
    });
    
}
